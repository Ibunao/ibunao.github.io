<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2017%2F07%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[test]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站优化-静态化]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[ab测试工具 -n 请求的总数量 -c 并发数 -t 请求的总时间 单位秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//在并发数100的情况下，发出5000个请求，所消耗的时间 ding:github-blog echo-ding$ ab -n 5000 -c 100 http://www.yiifirst.com///在并发100的情况下，持续10秒，可以完成多少请求数//ding:github-blog echo-ding$ ab -t 10 -c 100 http://www.yiifirst.com/----------------输出-------------------//软件信息This is ApacheBench, Version 2.3 &lt;$Revision: 1796539 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org///测试进度Benchmarking www.yiifirst.com (be patient)Completed 500 requestsCompleted 1000 requestsCompleted 1500 requestsCompleted 2000 requestsCompleted 2500 requestsCompleted 3000 requestsCompleted 3500 requestsCompleted 4000 requestsCompleted 4500 requestsCompleted 5000 requestsFinished 5000 requests//服务器信息Server Software: Apache/2.4.26Server Hostname: www.yiifirst.comServer Port: 80//响应信息Document Path: /Document Length: 25938 bytes//测试结果Concurrency Level: 100 #并发级别Time taken for tests: 61.459 seconds #测试总用时Complete requests: 5000 #完成请求数量Failed requests: 0 #请求失败数Total transferred: 132882558 bytes #总的数据传输量HTML transferred: 129690000 bytes #总的数据量，响应主体Requests per second: 81.36 [#/sec] (mean) #请求数量／每秒Time per request: 1229.171 [ms] (mean) #每组请求消耗的时间Time per request: 12.292 [ms] (mean, across all concurrent requests) #平均每个请求消耗的时间Transfer rate: 2111.47 [Kbytes/sec] received #传输效率//结果的统计//最佳，最差，平均结果Connection Times (ms) min mean[+/-sd] median maxConnect: 0 2 7.7 0 120Processing: 77 1223 264.1 1219 2608Waiting: 47 1146 235.2 1166 1998Total: 78 1225 264.0 1221 2608//统计结果Percentage of the requests served within a certain time (ms) 50% 1221 66% 1310 75% 1372 80% 1413 90% 1539 95% 1658 98% 1793 //98%的请求可以在 1793ms内完成 99% 1909 100% 2608 (longest request) 静态化 页面静态化，就是将需要后段数据配合生成的页面缓存起来，下次访问将不再需要对后段的各种请求解析，直接访问存取的静态页面框架正常都带有方便的缓存设置功能方法，不需要手动写ob了 ob缓存简单操作123456789101112131415161718192021222324252627282930313233343536ob_start()开启输出缓冲 之后的任意的响应主体输出，都会存储到该缓冲区。 ob_get_content() 获取缓冲中内容 所有的响应主体都输出完毕后，需要获取到。 Ob_get_clean();// 获取后清空;之前的输出将不会在客户端输出Ob_get_flush();// 获取后刷新；之前的输出立刻输出到客户端ob_end_clean(); 关闭同时清空输出缓冲；将不会输入 file_put_contents($filename, $content); //将获取到的内容输出到文件开启 startOb_start()获取 getOb_get_contents();// 获取内容Ob_get_clean();// 获取后清空Ob_get_flush();// 获取后刷新刷新 flush将缓冲内容向下传输Ob_flush();// 直接刷新 在需要将内容立即在浏览器端显示时，通常使用！Ob_end_flush(); 刷新后关闭Ob_get_flush(); 获取后刷新即使没有刷新，脚本结束时，PHP核心会自动刷新。清空 clean清空缓存区内容Ob_clean(); 直接清空Ob_get_clean(); 获取后清空Ob_end_clean(); 清空关闭关闭 endOb_end_clean(); 清空后关闭Ob_end_flush(); 刷新后关闭。后续的输出就不会再出现在输出缓存中。 多obob缓冲区，允许开启多次每当执行一次OB_start()就会开启一次输出缓存。而对OB的操作，都是针对于当前的活跃缓存区。–最新开启的这个缓存区。 1Ob_get_level()获取当前缓存的深度。 PHP默认会开启一个输出缓冲。12php.inioutput_buffering = 4096 开启缓冲，并设置最大缓冲大小 4096byte 缓冲处理器开启缓冲时，可以制定一个函数，用于处理当缓冲内容被刷新时，处理缓存数据。 典型的处理器：ob_gzhandler();根据浏览器所能够接受的压缩类型，对缓冲数据进行压缩。 使用缓存压缩 –开启的时候加入处理器名字即可1ob_start( 'ob_gzhandler'); 程序缓存PHP默认的缓冲区。一直在，几乎不能操作。一个函数对该缓存进行操作：123flush(); #刷新程序缓存Ob_flush(); #输出ob缓冲 如果需要将数据立即在浏览器端显示时。使用 ob_flush() 和 flush() 配合使用。 12345678910// 浏览器在没有收到一定量的数据可能不给渲染// echo str_repeat('--', 1024);for ($i=0; $i &lt; 10; $i++) &#123; echo $i; //刷新ob输出缓存 ob_flush(); //刷新程序缓存 flush(); sleep(1);&#125;]]></content>
      <categories>
        <category>网站优化</category>
      </categories>
      <tags>
        <tag>静态化 - ab测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化-Mysql]]></title>
    <url>%2F2017%2F07%2F02%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-Mysql%2F</url>
    <content type="text"><![CDATA[4个方向的优化 其一：设计方面。存储引擎的选择，列类型的选择 其二：功能方面。索引，查询缓存，分区。 其三：架构层面。读写分离，负载均衡。 其四：SQL层面。经验。 设计方面存储引擎的选择 存储数据的格式，方式常用的有两种，innodb 和 MyISAM 查看mysql支持的引擎情况1show engines\G MyISAM引擎 记录按照顺序插入进行存储的 12345678910USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 数据和索引分别存储 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 表压缩myisam支持压缩存储制作一张大量数据的表，利用蠕虫复制(自身复制)技术，完成大量数据；1insert into myisam_1 select null,title from myisam_1; 多次执行后查看如果文件大小没有更新，可以刷新表写入到文件1flush table myisam_1; 查看文件大小 工具压缩查找123456find / -name myisampack发现工具目录 /usr/local/Cellar/mysql/5.7.18_1/binmyisampack 打包压缩myisamchk 检测修复 进入到数据库目录中/usr/local/var/mysql/test 可以通过 find / -name *.frm 查找 执行1myisampack myisam_1 //myisam_1是带压缩的表名 最后会显示1Remember to run myisamchk -rq on compressed tables 可以看出数据文件压缩，但是索引文件出问题了，需要重建修复索引1myisamchk -rq myisam_1 修复后索引正常 压缩后为只读表，不能再进行插入操作，仅仅可以完成更快速的查询工作 表解压如果需要对压缩过的表进行修改需要进行解压同样进入到要解压的数据库目录中1myisamchk --unpack myisam_1 执行后即可,如果文件大小没变，需要进入到mysql中执行1flush table 修复表myisam新增数据时，都是在表末尾完成的插入如果存在被删除的记录。所占用的记录空间就会空下来，但是不会再存放记录。最好定时，完成修复表空间漏洞！删除数据后myisam表的大小并不会发生改变 ，需要进行修复进入到需要修复的数据库的目录中12myisamchk -rq myisam_1 #修复索引 myisamchk -r myisam_1 #修复数据 myisam 不支持行锁，支持表锁，导致并发性降低 ；提供高效的查询、插入操作；不擅长大量更新、删除业务； innodb引擎mysql默认存储引擎支持事务，行级锁定，外键 存储机制数据按照主键顺序进行排序导致innodb的表的记录与逐渐索引存在一个结构中(聚簇)插入数据时，因为要额外的执行排序工作，导致插入速度相对较慢 创建innodb表12345678910USE test; #选用数据库CREATE TABLE innodb_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = innodb CHARSET=utf8;#innodb引擎的INSERT INTO innodb_1 VALUES (23, '李牧');INSERT INTO innodb_1 VALUES (12, '王翦');INSERT INTO innodb_1 VALUES (34, '廉颇');INSERT INTO innodb_1 VALUES (15, '白起'); 查看文件 innodb_1.frm innodb的结构文件ibdata1 默认的innodb表空间文件，所有的innodb表的数据和索引都在该文件中(最新的默认为每个表分开存储)innodb_1.ibd innodb表空间文件(每个表单独存储的时候会有这个文件) 如果默认为所有的表存储在一个文件中，可以进行配置来实现每个表分开存储1show variables like 'innodb_file_per_table'; 如果值为 OFF 则为所有表存在一个文件中，进行设置更改即可1set global innodb_file_per_table = 1; innodb额外支持事务，外键约束，行级锁定擅长处理复杂数据完整性，一致性。擅长处理并发。 列类型的选择在满足需求的情况下尽可能占用小的存储空间尽可能使用整数类型整数行的运算速度最快，也可以考虑 Enum枚举 和 Set集合 类型，不过这两种也可以配合代码用数值型实现例如：存储 ipv4； varchar(15) 15+个字节可以将ip转换为int型的 int unsigned 就只需要4个字节ip转整1select inet_aton('192.168.1.234'); 整数转ip1select inet_ntoa(3232236010); 尽可能使用 not nullNull值，特殊值，mysql需要额外的存储空间存储。无论在计算，存储上都需要消耗资源。 逆范式 范式：规范的格式： 满足三范式：1NF：原子性。2NF：消除部分依赖。3NF：消除传递依赖。每张表，存储一类实体的信息。实体间通过关联字段进行联系。 但 有时需要 打破规范，来提升某种操作的效率：例如：1234567891011121314151617181920商品表：GoodsGoods_id, goods_name, cat_id分类表：categoryCat_id, cat_title,业务逻辑：分类列表分类ID，分类标题，分类下商品数量典型的实现：连接查询。Select c.cat_id, c.cat_title, count(g.goods_id) as goods_count from category as c left join goods as g On c.cat_id=g.cat_id group by c.cat_id where Condition如果 在查询分类列表时，通常需要 商品数量：则可以采用下面的设计：在分类表，增加商品数量的字段：分类表：categoryCat_id, cat_title,goods_count每当 商品 增，删，改的时候，修改相关分类的goods_count的值。但是，如果执行查询分类列表了，就不需要 连接操作：Select * from category; 优化根据具体的业务需求对表结构进行优化 功能方面索引在终端执行 select 语句的时候会显示执行时间例如：128388608 rows in set (2.79 sec)执行了2.79秒 可以通过设置索引对查询进行优化 索引就好比字典的目录，通过关键词获取记录所在位置通过使用 数据中的部分数据作为关键字，建立该关键字与数据间位置的对应关系，称之为索引。 在没有索引的情况下，定位记录，需要采用的是全表扫描，从第一条记录扫描到最后一条记录，确定要找的数据而索引的关键词是排序过的，查找的时候先在索引中进行检索，快速的定位该关键词对应的记录位置 索引的增删改查看 mysql基础 执行计划在执行sql之前，mysql会形成执行计划，内包含了当前的sql执行所采用的策略 mysql执行计划获取通过 explain select 语法1explain select * from test where id = 123456\G 123456789101112131415mysql&gt; explain select * from myisam_1 where id = 123456\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: myisam_1 partitions: NULL type: const #这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL，all为全表扫描possible_keys: PRIMARY #查询可能会使用到索引 key: PRIMARY #实际使用的索引 key_len: 4 #使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref: const rows: 1 #MYSQL认为必须检查的用来返回请求数据的行数 filtered: 100.00 Extra: NULL #关于MYSQL如何解析查询的额外信息1 row in set, 1 warning (0.00 sec) 索引使用场景条件检索 wherewhere 后的字段如果有索引是可以使用索引的 排序 order byorder by 后的字段如果有索引是可以使用索引的 联表join 关联字段联接查询是，关联字段 (on后面的条件) 可以使用索引两个表的关联字段都要创建索引 索引使用语法细节字段独立字段需要使用索引时，要求，字段独立存在于表达式的一侧。不能参与表达式运算。函数调用。例如：12where id = 123456; #字段独立where id+1 = 123455; #字段未独立 左原则like模糊查询匹配字符串，左侧必须要固定才可以使用索引。即 like abc% 复合索引创建复合索引时，在使用索引的时候左边的字段才能直接使用该索引。左边字段确定时，右边字段的索引才可以使用。 原因：复合索引的关键字顺序，先按照左边字段排序，如果左边字段相同，则按照右边字段排，以此类推。 or原则要保证 OR两侧的条件表达式中的字段都有索引可以使用，才会用到索引。 mysql自动判断当搜索的记录数比较多时，mysql可能会放弃使用索引来减少大量的随机io开销，而选择使用顺序开销来代替例如：1where empno &gt; 1121212; 如果查询的记录数太多，会放弃索引 前缀索引 可以使用 某个字段的前一部分（左边）数据，作为索引的关键字，而不是使用全部的字段内容。称之为前缀索引。字段 32 字节长度。只使用前10个长度，作为索引关键字。目的：减少 关键字的长度，索引的速度就会提升！实际中，前缀 具有 足够的标识度，才可以使用前缀索引。 例如：以 密码为例： 首先需要计算当前缀达到多长时，标识度就够了。 先计算整体的标识度 1select 总记录条数／count(distinct epassword) from emp; #计算总条数除以不重复密码的比值 计算使用不同的前缀是的标识度的值，找到最接近的即可 1select 总记录条数／count(distinct substring(epassword, 1, n)) from emp; 随着 n 的不断增大，将会越来越接近整体标识度，并且随着增大标识度将会不变，这时去不变时的最小值最为前缀长度 建立前缀索引 1alter table emp add index 'index_password' (epassword(n)); #n为计算出的长度 查询缓存mysql服务器提供的可以缓存查询结果的缓存区12345678910mysql&gt; show variables like 'query_cache_%';+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 1048576 |#缓存大小| query_cache_type | OFF |#开关| query_cache_wlock_invalidate | OFF |+------------------------------+---------+ 看出默认是开着的 设置配置变量：12set global query_cache_type = 1;#打开set global query_cache_size = 1024*1024*64;--64M 注意：一旦开启查询缓存，则只要执行的时Select操作，通常结果都会被缓存。无论客户端是否要求。 实际使用时：有些数据仅仅需要使用一次。数据很大。不希望数据被缓存。通过 SQL_NO_CACHE 语法，进行提示 MySQL 该select不需要缓存1select sql_no_cache from emp where empno = 12345; 动态数据不能缓存1select * ,now() from emp where empno=12345; 缓存是基于 select 语句的如果多打了空格或字母大小写不一样都会导致不会使用缓存 索引的状态的查看123456789101112mysql&gt; show status like 'handler_read_%';+-----------------------+----------+| Variable_name | Value |+-----------------------+----------+| Handler_read_first | 4 || Handler_read_key | 5 |#该选项值高 则证明系统高效使用了索引| Handler_read_last | 0 || Handler_read_next | 0 || Handler_read_prev | 0 |#上面的数量越高，索引利用率越高| Handler_read_rnd | 0 |#下面两项数值高的需要优化，执行全表扫面的| Handler_read_rnd_next | 27264190 |+-----------------------+----------+ 管理查询缓存12345678910111213mysql&gt; show status like 'Qcache_%';+-------------------------+---------+| Variable_name | Value |+-------------------------+---------+| Qcache_free_blocks | 1 || Qcache_free_memory | 1031832 || Qcache_hits | 0 | #查询命中数| Qcache_inserts | 0 | #缓存项数量| Qcache_lowmem_prunes | 0 || Qcache_not_cached | 30 || Qcache_queries_in_cache | 0 || Qcache_total_blocks | 1 |+-------------------------+---------+ 重置／清空缓存1reset query cache; 缓存失效如果对数据表进行更改操作(增、删、改)，则会删除该表对应的所有的缓存； 分表分区当表中的记录数很多时，采用多张表进行存储，策略就是分表策略 将大量数据按照算法分开存储，可以提高查询的效率和io开销吧 mysql服务器可以实现表的分区分区后mysql服务器将会根据分区算法和数量创建多个表，然后像普通正常使用就行 分区将一个表分成多个区(partition),将数据分散到不同的区中。就是横向分表区：就是一个物理表， 4种分区算法key、hash、range、list hash分区分区的字段要求是整数类型的如果是要对非整型字段进行hash分区，需要自己用表达式将非整形转换成整形12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by hash(id) partition 10;--或通过 birthday 划分成10个 ,要将date转换成int类型的partition by hash(YEAR(birthday)) partition 10; key分区针对任意类型字段与hash相似，只不过转成 int 的函数不是用户指定，而是由mysql指定12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by key(id) partition 10;--或通过 birthday 划分成10个partition by key(birthday) partition 10; range范围分区为每一个分区的条件指定一个范围123456789101112131415create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据年代划分partition by key(YEAR(birthday)) ( partition p_old values less than (1970), -- 小于 &lt; (value) partition p_70 values less than (1980), partition p_80 values less than (1990), partition p_90 values less than (2000), partition p_new values less than MAXVALUE, -- 最大值); list 列表值条件分区12345678910111213create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据月份划分partition by key(month(birthday)) ( partition p_chun values in (3,4), partition p_xia values in (5,6,7,8), partition p_80 values in (9,10), partition p_90 values in (11,12,1,2),); 分区管理求余类型的 hash和key分区类型减少分区将原来的10个分区减少至7个分区123alter table student coalesce partition 3;--查看 show create table student\G 增加分区123alter table add partition partitions 5;--查看 show create table student\G 条件类型的 range和list分区类型添加具体的条件分区123alter table student_list add partition( partition p_undefined values in (0);) 删除具体的条件分区1alter table student_list drop partition p_qiu; 删除分区时会导致分区内的数据同时被删除 垂直分表可以根据表的字段使用情况将一张表垂直拆分成几个表常用信息一个表，不常用信息一个表 架构优化读写分离web项目，读写比例大概 7:1，配置一台住服务器负责写，多台从服务器负责读 负载均衡将访问数据均匀的分配到不同的读服务器，nginx反向代理 mysql配置优化my.ini最大连接数1max_connections = 100; myisam键缓存1key_buffer_size = 55M innodb的缓冲池1innodb_buffer_pool_size = 107M 表文件句柄缓存可以缓存打开的table的句柄1table_cache=256 sql优化找到执行慢的sql将执行超过多久的sql记录下来 1234567mysql&gt; show variables like 'slow_query_%';+---------------------+------------------------------------+| Variable_name | Value |+---------------------+------------------------------------+| slow_query_log | OFF |#慢查询开关,默认打开| slow_query_log_file | /usr/local/var/mysql/ding-slow.log |#慢查询日志位置+---------------------+------------------------------------+ 123456mysql&gt; show variables like 'long_query_%';+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 | #记录 慢 的临界值+-----------------+-----------+ 12set global slow_query_log = 1；#开启慢查询 set long_query_time = 1; #设置记录慢查询时间临界值,超过的将都会记录下来 通过查询慢查询日志，找到需要优化的sql 插入大量数据建议将索引关闭(每条记录维护索引，相比一起维护索引，一起维护更容易)也可以现将索引删除，插入数据后再创建索引 order by null禁止排序group by的时候，默认的按照分组字段排序；执行explain计划可以看到 extra: useing filesort如果排序没有意义，可以通过添加 order by null 来禁用排序 select查询的字段尽可能是自己需要的，尽量不要使用 * 会导致数量变大，拖慢速度 单表查询一次操作仅仅操作一张表，当数据量较大的时候使用连表操作将会导致内存不够单表查询的好处 一次占用一个表，减少并发 消耗内存少 提高查询缓存的利用率缺点由于多次执行sql会多次向mysql服务器进行联接，联接响应也是影响速度的重要原因 能用join的尽量不要用子查询，mysql对子查询的支持不是太好，效率略低]]></content>
      <categories>
        <category>网站优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础操作]]></title>
    <url>%2F2017%2F07%2F01%2Fmysql-mac%2F</url>
    <content type="text"><![CDATA[终端使用安装数据库brew 安装 启动 连接数据库12345678910mysql -uroot -p``` **数据库存放位置** `/usr/local/var/mysql/`&gt; 可以通过 `find / -name *.frm` 查找 **创建数据库** ```sqlcreate database 数据库名 [charset 字符编码名] [collate 排序规则名]; 查看mysql中的所有字符编码名(字符集) 1show charset; 查看所有的排序规则名 1show collation; 创建数据库1CREATE DATABASE test CHARSET utf8; 修改数据库1alter database 数据库名 [charset 字符编码名] [collate 排序规则名]; 数据文件 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 退出quit 或者 exit备份数据库 mysqldump -h要备份的数据库所在的服务器 -u用户名 -p 数据库名 &gt; 完整目标文件名不需要进入mysql服务执行 1mysqldump -hlocalhost -uroot -p test &gt; /Users/echo-ding/Documents/ding/test.sql 恢复数据库1234567先把原来的删除 drop database test;#删除数据库show databases;#显示所有的数据库CREATE DATABASE test CHARSET utf8;还原 注意：先要创建还原的数据库testmysql -hlocalhost -uroot -p test &lt; /Users/echo-ding/Documents/ding/test.sql 命名规则 本身并不区分大小写，但是由于在unix、linux上的文件名区分大小写，所以数据库名字和表名、视图是区分大小写的对于可能用到系统关键词的 使用反撇号 ` 包裹 删除数据库 drop database 数据库名 查看所有数据库 show databases; 选择数据库 use 数据库名称; 表的一般操作查看当前数据库下的表1show tables; 删除表1drop 表名； 查看表结构1desc 表名; 查看表的创建语句1show create table 表名; 复制表结构1create table [if not exists] 新表名 like 原表名; 清空一张表1truncate 表名; 相当于删除一张表重新创建 添加列1alter table 表名 add 字段 类型; 更改表名1alter table oldtablename to newtablename; 创建表123456789create table [if not exists] 表名(键名 类型 , ……)``` 创建指定编码格式的表 ```sqlcreate table 表名(键名 类型 , ……) charset utf8;``` 例子： ```sqlcreate table msg(id int primary key auto_increment,title varchar(60)) charset utf8; 123456USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的 字段属性 索引 primary key (fields1[,fields2,……]) :设定主键，每个表需要(必须,只能)有一个,字段值不能重复。可以多个字段共同组成一个主键。unique key (fields1[,fields2,……]) ：用于设定该字段的值，在这个表中，不可以重复（即是唯一的）key (fields1[,fields2,……]) : 普通索引，仅仅是建立了索引fulltext key (fields1[,fields2,……]) ：全文索引，目前对中文支持不好foreign (fields1[,fields2,……]) references 其他表(fields1[,fields2,……]) : 设定外键，附加外键索引和外键约束 外键：构建两个表之间的联系，表1中的外键和另表2的主键(只要是不重复的应该都可以)对应，这样通过表1的外键就可以在表2，查出对应的数据。表1的外键和表2的主键字段的类型必须一致。 一张表可以有多个外键指向不同的表 创建索引可以加快查找的速度，但是添加的速度会变慢，但一般程序查的功能较多 . 其它 auto_increment ：用于设定一个字段值(整型的)的自动增长(自增)，而且，它设定后还必须同时设定在一个字段为一个“key”(比如:priamry key 或 unique key)not null： 用于设定一个字段的值不能为空值（null）——如果不设定，则就是可为空值；非空约束null是一种类型,比较时,只能用专门的is null 和 is not null来比较.碰到运算符,一律返回null,效率不高,影响提高索引效果 default XX值：用于设定某个字段的值，在插入数据的时候如果没有给值，就使用该默认值；comment ‘说明文字’：就是一个说明字段含义的文字，备注 修改表的字段／属性／索引1234567891011121314151617181920212223242526272829//添加字段(添加列)：alter table 表名 add 新字段名 字段类型 [附加属性];//删除字段(删除列):alter table 表名 drop 字段名;//修改字段:alter table 表名 change 旧字段名 新字段名 新字段属性;//修改表名:alter table 表名 rename 新表名;#操作索引//添加普通索引alter table xiugai_test add key (realname);//添加唯一索引alter table xiugai_test add unique key(realname);//添加主键索引alter table xiugai_test add primary key(id);//添加外键索引alter table xiugai_test add foreign key(xuehao) references students(id);//添加字段默认值alter table xiugai_test alter realname set default 0;//删除字段默认值alter table xiugai_test alter realname drop default;//删除主键alter table xiugai_test drop primary key; 如果要删除主键，需要先删除自动增长 alter table xiugai_test modify column id int unsigned not null;//删除外键alter table xiugai_test drop foreign key xuehao;//删除索引alter table xiugai_test drop key realname; 查12基本查询语句select 字段 from 表名 where 条件; ###where字句###算数运算符12+ - * / %例子：select * from 表名 where 字段名 + 100 &lt; 200;//筛选出相应列加上100依旧小于200的数据 //最好不要字段参与运算，不利于索引 比较运算符1234&gt; &gt;= &lt; &lt;= =(等于) &lt;&gt;或!=(不等于) 最常用比较运算符可以在字段中使用，返回的值是0(不满足时)或1(满足时)例如 SELECT goods_name ,cat_id&lt;8 FROM goods; //cat_id&lt;8列显示的是0或1这样方便在用sum等函数统计，如sum(cat_id&lt;8) 逻辑运算符12and(与) or(或) not(非) 例子：select * from 表 where id&lt;6 and c5&gt;1; is运算符12345只能对特殊的几个数据进行判断xx字段 is truexx字段 is falsexx字段 is nullxx字段 is not null between运算符123用法： 字段x between 值1 and 值2;值1 和 值2 范围之内的都符合条件例如： where id between 3 and 6; //id在3和6之间都符合要求 in运算符12用法： 字段x in (值1,值2,……) // not in() 相反 只要字段x的值满足括号中给定的任意的数值就算满足条件 like运算符——模糊查找123456用法：字段x like '要查找的字符'要查找的字符需要配合 % _ 才能完成模糊查询% 匹配任意长度的任意字符_ 匹配一个长度的任意字符如果要特意的匹配数据中包含 % 或 _ 的数据，需要进行转义例如：9_\% 表示匹配 9x% (x为任意字符) group by 字句 —分组 group by 根据 select 查询语句查询出的结果进行分组 用法1group by 字段名 [asc|desc]，字段名 [asc|desc] , …… 1，group by子句是用于将“前面”取得的数据，按某种标准（依据）——也就是字段——来进行分组的。分组，基本上就是，按给定字段的值，相同的值，分在相同的组中，不同的值分在不同的组中。2，asc表示分组后，按组的值的大小正序排列，desc是倒序——默认是正序，可以不写。3，一个最重要的理解（观念）：分组之后的结果，也是一行一行数据，只是每一行代表“一组” 特别注意：分组之后，结果行中的数据，都只能出现“组信息”——描述该组的“应有信息”。具体来说，对于分组查询的结果数据（select子句部分），只能出现如下几类数据：1， 分组依据本身——即该字段；2， 原始字段信息中的数字类型的最大值，最小值，平均值，总和值；max(字段)：获得该字段的在组中的最大值；min(字段)：获得该字段的在组中的最小值；avg(字段)：获得该字段的在组中的平均值；sum(字段)：获得该字段的在组中的总和值；3， 每一组中所包含的原始数据行的行数，获得方式为：count(*) 123例子：select 字段1,max(字段2) as 最大值,min(字段3) as 最小值,avg(字段4)as 平均值,sum(字段5)as 总和,count(*)as 总条数, from 表名 group by 字段1;as 用来给查询出的字段设置别名，用来表头的显示，也可以在条件部分使用别名代替原字段按照 字段1 进行分组，分别显示分组后对应字段的一组所有数据的最小值，最大值等等 如果没有使用聚合函数直接使用字段，默认显示该字段的第一个值 having字句 having条件语句和where条件语句的区别，使用的目标不一样，where是对原始数据(表数据)进行的筛选行为，而having是对group by分组后形成的数据进行的筛选(可以把group by分组后的结果当成一张表)，having能用的筛选条件只能是select子句中出现的字段 用法：1having 条件判断 例子：123select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having count(*) &gt; 2;或条件用as别名：select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having 数量 &gt; 2; //和上面的一样 order by排序子句 对查询结果进行排序 用法：1order by 字段名 [ [asc|desc] , 字段名[asc|desc] ,……]; 按照字段名进行顺序或倒序排序，多个字段名时，先按照第一个字段名排序，再按照第二个字段名进行排序…… limit 子句用法：123limit [offset,]n offset:偏移量(跳过几行) n取出的条目 offset省略相当于 limit 0,n DISTINCT关键字合并查询记过重复行合并查询字段结果的重复的行1SELECT DISTINCT mobile, nationality FROM `person`; 子查询就是通过把查询语句的值作为条件进行查询的 子查询方便，但是性能原因略低，一般也会回用，省略 执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。 union 子查询 合并两个查询的结果 用法：12345select 语句1union [distinct | all ]select语句2[order by 子句][limit 子句] ; 说明： distinct | all用于设定是否消除重复行，默认不写就是distinct，表示会消除重复行； order by子句和limit子句，是对整个联合之后的数据结果进行排序和数量限定； 这两个select语句，要求字段数量必须一致，对应字段类型最好一致； 联合查询的结果数据中，字段名以第一个select语句中的字段名为准； 第一个select语句中的字段名如果有别名，则后续的order by子句就必须使用该别名； 将两个“字段一致”的查询语句所查询到的结果以“纵向堆叠”的方式合并到一起，成为一个新的结果集。结果集的行数是两个独立select查询语句的结果行数的和例子：12 连表查询用法：1select XX1, XX2, .... from 表1 [连接方式] join 表2 [ on 连接条件] where ... 常用的两个连表查询 内连接 inner join1from 表1 inner join 表2 on 表1.字段1 = 表2.字段2 结果：是在交叉连接的结果(两表之间做全相乘的结果)中筛选出符合 on 后面条件的也是左连接和右连接的交集 左(外)连接 left [outer] join1from 表1 left [outer] join 表2 on 表1.字段1 = 表2.字段2 假设A表在左，不动。B表在A表的右侧滑动，A表和B表通过一个关系(条件)来筛选B表的行，如果符合条件，则B表取出对应的行与A表对应的行组成新的一行数据，添加到结果集中，形成的结果集可以看成一张表，设为C，形成的结果集(表c)最少的行数为左边表(表A)的行数。也可以理解为 内连接的结果添加上没有匹配上的表A的没有匹配上数据的行(右边部分填充null)此时，可以对C表进行查询操作，where ，group，having，order by，limit依旧可以使用 视图和将查询出来的数据存放到一张新表里一样，不常用。略 增1234567891011形式1：常用insert [into] 表名 [(字段1,2,3，……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //插入多行时用逗号分开形式2：replace [into] 表名[(字段1,2,……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //和insert的区别是插入的数据的主键值在表中已存在时插入的将会替换这行数据，而insert将执行失败形式3：insert [into] 表名 [(字段1,2,3，……)] select 字段1,字段2,……from 其他表表名; //插入select中查询到的数据形式4：insert [into] 表名 字段1=值表达式,字段2=值表达式,字段3=值表达式，……;形式5：load data 导入数据 加载数据文件 load data infile '完整的数据文件路径.文件格式后缀' into table 表名;可以在txt中创建，数据与数据之间需要用tab进行隔开 ，注意需要使用utf-8格式的，还有与表的字段定义的类型保持一致(数据不用加引号)，路径中的\可以用/也可以进行转义\\使用 插入数据1234INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 删1234delete from 表名 [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定]; 1.where 几乎必须，如果省略将删除所有数据2.order by 排序设定用于设定删除这些数据的时候指定的字段的顺序来删除，3.limit 用于删除数据的时候指定只删除“前面的多少行” 改12update 表名 set 字段1=新值,字段2=新值,…… [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定];和删的用法相似 列类型整数类型 名称 字节 最小值(带符号／不带符号) 最大值(带符号／不带符号) tinyint 1 -128/0 127/255 smallint 2 -32768/0 …… mediumint 3 -8388608/0 …… int 4 -2147483648/0 …… bigint 8 -9223372036854775808/0 …… 1字节(byte)有8位(bit),当显示负数的时候需要占用首位进行表示，所以表示数值的只有7位 使用形式 类型名 [M(长度)] [unsigned] [zerofill] 其中M表示“显示长度”，其需与zerofill结合使用才有效，即不够该长度的会自动左侧补0，当然如果超出也不影响。长度，就是用来设定要显示的长度位数(数字个数) unsigned表示“无符号数”，表示其中的数值是“非负”数字 如果设置了zerofill，则自动也就表示同时具备了unsigned修饰 如果设置了zerofill但没有设定长度M，则其会默认将所有数的左边补0到该类型的最大位数 小数类型 类型 名称 字节 精度 浮点型 单精度 float(m,d) 4 6-7位 双精度 double(m,d) 8 15位 定点型 decimal(m,d) 如果M&gt;D，为M+2否则为D+2 总精度65位/小数部分精度30位 m叫“精度”，代表“总位数”， d表示“标度”，代表小数位浮点型的小数，内部是二进制形式，所以很可能是非精确的，基本多有语言都有的毛病 字符串类型 类型 大小(字节) 用途 CHAR 0-255(字符) 固定长度 VARCHAR 0-65535 变化长度 TEXT 0-65535 长文本数据 enum 最多65535选项 单选类型 set 最多64选项 多选类型 char(m)类型:定长字符串，m表示设定的字符长度，存储内容和编码格式无关，其存储的时候，就是该长度——不够就会自动补空格填满；最大可设定为255，表示可存储255个 字符； varchar(m)类型：变长字符串，m表示设定的字节数长度，存储内容和编码格式有关，是可存储的最大长度，实际存储长度可以小于该长度；该类型存储的时候，还需要在字段内的最前面额外存储该字段的实际长度；最大可设定为65533，表示最大可存储65533个 字节；因为考虑因素：一行 的总的存储空间限制是65535 字节，但有考虑字符编码的问题，又会出现：如果存储的是纯英文字符，则实际最多可存储65533个字符；如果存储的是纯gbk的中文字符，则实际最多可存储的是65533/2个字符；如果存储的是纯utf8的中文字符，则实际最多可存储的是65533/3个字符； text类型：它通常用于存储“大文本”，因为其可存储65535个字节，并且， 不受行存储空间的限制；不能设置默认值 varchar和text存储结构上是有区别的，text是单独存储的，不受行存储空间限制;对于大文本的字段最好分拆成单独一个表从存储上来讲大于255的varchar可以说是转换成了text.这也是为什么varchar大于65535了会转成mediumtext 字段的额外开销 varchar 小于255byte 1byte overhead varchar 大于255byte 2byte overhead tinytext 0-255 1 byte overhead text 0-65535 byte 2 byte overhead mediumtext 0-16M 3 byte overhead longtext 0-4Gb 4byte overhead 备注 overhead是指需要几个字节用于记录该字段的实际长度。在固定的长度下 char 类型比 varchar 占用空间更少，并且由于 char 是固定长度，所以更利于搜索速度 . enum类型：用于存储若干个“可选项之一”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为单选项，实际存储数据的时候，就可以选择其中一个存入数据库。它适合于存储在网页中的“单选项”数据，比如：单选按钮，下拉列表选项值等等；形式：enum(‘单选项1’, ‘单选项2’, ‘单选项3’, ……. ); //最多65535个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 3, 4, 5, 6, …. set类型：用于存储若干个“多选项”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为多选项，实际存储数据的时候，就可以选择其中若干个选项值存入数据库。它适合于存储在网页中的“多选项”数据，比如：多选按钮；形式：set(‘多选项1’, ‘多选项2’, ‘多选项3’, ……. ); //最多64个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 4, 8, 16, …. 3表示选择类1和2 时间类型 类型 大小(字节) 范围 DATE 3 1000-01-01/9999-12-31 TIME 3 -838:59:59/838:59:59 YEAR 1 1901/2155 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 TIMESTAMP 8 1970-01-01 00:00:00/2037 年某时 timestamp和datetime基本相似timestamp额外特性：用于记录一个“当前时间”的精确的时间戳——也就是某个时刻的对应整数值；该整数值，表示，从1970年1月1日0时0分0秒开始算起到该时候所经历的秒数；而且，其有如下特征：该字段的值，会在一个表的某行数据执行insert或update的时候，自动获取该时刻的时间戳值；显示格式 YYYY-MM-DD HH:MM:SS特性:不用赋值,该列会为自己赋当前的具体时间 ，但是要添加not null属性1`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', //默认值为插入的时间 更新数据时也自动更新为当前时间 注意：作为时间日期类型的数据，如果是在代码中插入一个具体的字面数据值，则需要用单引号引起来——跟字符类型一样。 用户管理添加用户mysql中的用户数据，都存储在mysql的系统数据库“mysql”中的user表中1create user ‘用户名’@’允许登录的网络位置’ identified by ‘密码’; “允许登录的网络位置”表示，该用户，在输入正确的用户名和密码的同时，也必须在“指定”的位置来登录该服务器。位置就是网络地址，通常是ip地址；其中，localhost表示只允许在本机（本地）登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。 添加权限1grant 权限名1，权限名2，.... on 某库．某下级单位 to ‘用户名’@’允许登录的网络位置’ identified by ‘密码’ 说明： 权限名，就是上述那些单词或单词组合，比如：select，insert，delete，等等； 某下级单位，指的是，一个数据库中的下级可操作对象，比如表，视图， 2.1 举例：shuangyuan.join1, 或者shuangyuan.tab1, mysql.user 2.2 特例1：*.*表示整个系统中的所有数据库的所有下级单位； 2.3 特例2：某库名.*，表示该指定数据库的所有下级单位； identified 用于给现有的该用户改密码。如果不改密码，就可以不写； 该grant语句，还可以给“不存在的用户”进行授权，此时实际上，会同时创建该用户。如果是这种情况，则此时，identified部分就不可以省略，而是必须给出密码； 例子：1grant select,insert on test.test to 'test'@'localhost'; 权限列表： 取消权限1revoke 权限名1，权限名2，.... on 某库．某下级单位 from ‘用户名’@’允许登录的网络位置’]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F06%2F29%2FHello%20world%2F</url>
    <content type="text"><![CDATA[文章md头部设置 123456789---title: test #标题名称date: 2017-06-29 11:56:02 #时间tags: #创建标签 - Testing #标签名称 - begin #标签名称categories: hello world #分类--- 添加图片 123456在source下创建images文件夹。![&apos;tupian&apos;](/images/my.jpg) images 是source下的文件夹也可以吧图片放在七牛进行引用。 使用 进入到目录没有权限的加 sudo 1/Users/echo-ding/Documents/ding/www/github-blog 创建文章1hexo new &quot;My New Post&quot; #my new post 为文章名 也可以直接在source中创建md文档 启动服务1hexo server 生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 写博客 写完之后直接。生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 本地测试(s 就是 server的缩写) 12hexo s --debug #默认以4000端口启动sudo hexo s --debug -p 80 #以80端口启动 代码高亮 在代码块开头后添加php表示php代码，用来高亮显示。 12345678class ClassName extends AnotherClass&#123; public function FunctionName($value='') &#123; echo "string"; &#125;&#125;]]></content>
      <categories>
        <category>hello world</category>
      </categories>
      <tags>
        <tag>begin</tag>
      </tags>
  </entry>
</search>