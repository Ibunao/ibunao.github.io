<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Yii的路由功能]]></title>
    <url>%2F2018%2F11%2F10%2Fyii%2F%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言路由规则的原理就是根据请求的参数A ---&gt; 找到要执行的B，项目中生成url刚好是相反的方向 B ---&gt; A 。原理很简单，yii的路由通过正则的方式进行匹配和映射。我们的重点看一下使用 urlManagerurlManager 作为一个url管理者，所有的路由规则 UrlRule 通过它来管理在匹配路由的时候会根据配置的先后顺序从上到下进行对 UrlRule 进行匹配，匹配到的直接返回1234567891011121314[ 'components' =&gt; [ 'urlManager' =&gt; [ 'enablePrettyUrl' =&gt; true,// 开启 url美化 'showScriptName' =&gt; false,//隐藏入口文件 index.php 'enableStrictParsing' =&gt; false,//true严格按照rules匹配，也就是必须匹配定义的rules才能解释，正常默认是的失效 'suffix' =&gt; '.html',// 后缀 // 路由规则 'rules' =&gt; [ // ... ], ], ],] 动态的添加路由规则添加规则，模块在bootstrap启动的会后有的需要注册自己规则的通过这个添加，如gii、debug模块就用到1public function addRules($rules, $append = true) 路由规则 UrlRule将配置的路由规则进行拆解创建成 UrlRule 对象，用来进行后续的解析和生成url 规则举例直接映射1['index' =&gt; 'ding/bunao'] 当访问 /index 时实际访问的是 /ding/bunao 左边正则匹配型1['test/&lt;id:\d+&gt;' =&gt; 'test/bunao'] 当访问 /test/10 的时候实际访问的是 /test/bunao?id=10 1[test/&lt;year:\d&#123;4&#125;&gt;/&lt;category&gt;' =&gt; 'test/bunao'], 当访问 /test/1000/ding 的时候实际访问的是 /test/bunao?year=1000&amp;category=ding 1234567[test-&lt;year:\d&#123;4&#125;&gt;' =&gt; 'test/bunao'],``` &gt; 当访问 `/test-1000` 的时候实际访问的是 `/test/bunao?year=1000`#### 两边匹配 ```php['&lt;ding:(test|comment)&gt;/&lt;id:\d+&gt;/&lt;bunao:(bunao|update|delete)&gt;' =&gt; '&lt;ding&gt;/&lt;bunao&gt;'] 当访问 /test/100/bunao 的时候实际访问的是 /test/bunao?id=100 通常会写成下面的形式，方便阅读1['&lt;controller:(test|comment)&gt;/&lt;id:\d+&gt;/&lt;action:(bunao|update|delete)&gt;' =&gt; '&lt;controller&gt;/&lt;action&gt;'] 其他实例1['&lt;controller:(post|comment)&gt;/&lt;id:\d+&gt;' =&gt; '&lt;controller&gt;/view'] 当访问 /post/100 的时候实际访问的是 /post/view?id=100 带有默认值的1234567[ [ 'pattern' =&gt; 'posts/&lt;page:\d+&gt;/&lt;tag&gt;',// 请求部分 'route' =&gt; 'post/index',// 解析部分 'defaults' =&gt; ['page' =&gt; 1, 'tag' =&gt; ''],// 默认值 ],] 当请求 /posts 时实际请求的是 /post/index?page=1&amp;tag=&#39;&#39; 限制请求方式的1['POST post/&lt;id:\d+&gt;' =&gt; 'post/create'] 表示请求 /post/100 如果要访问到 /post/create?id=100 必须是 POST 请求 1['POST,PUT post/&lt;id:\d+&gt;' =&gt; 'post/create'] 表示允许 post 和 pub 方式请求。多个用 , 隔开 域名匹配 一个项目配置了好几个域名，根据域名来控制访问，比如说pc、mobile、api三个用不同的域名 123456789101112131415161718192021[ 'http://&lt;language:\w+&gt;.example.com/posts' =&gt; 'post/index', 'http://admin.example.com/login' =&gt; 'admin/user/login', 'http://www.example.com/login' =&gt; 'site/login',]``` &gt; 用不同的域名访问请求#### 详细配置 UrlRule详细配置```php[ 'pattern' =&gt; 'posts/&lt;page:\d+&gt;/&lt;tag&gt;',// 请求匹配部分 'verb' =&gt; ['post', 'get'], //可以请求的方法 'route' =&gt; 'post/index',// 解析规则部分 'host' =&gt; 'www.bunao.win', //域名，可以多个域名指向同一项目，且可以根据域名的不同来执行不同的解析，一般不填写，也可以把域名和pattern写在一起, 和pattern拼写在一起的时候要带上:// 或 // 来让知道有域名 'mode' =&gt; UrlRule::PARSING_ONLY ,// 该路由的模式，如只能解析或只能创建 'defaults' =&gt; ['page' =&gt; 1, 'tag' =&gt; ''],// 默认值，要和pattern中的参数对应上 'name' =&gt; '', // 路由规则名称，一般不写，默认是 pattern的值], 总结 如果左边有 &lt;&gt; 而右边没有对应的，则 &lt;&gt; 中定义的匹配到的作为 $_GET 的一组值。 如果右边有和左边对应的(值相等的) &lt;&gt; ，表示左边匹配到的替换到右边就行了 &lt;&gt; 中的 :\xx 定义的是正则匹配的规则，如：:\d+ 匹配任意个数字， :\d{4} 只能匹配4位的数值, :(test|comment) 只能匹配 test 或 comment 中的其中一个 action支持驼峰形式请求增加支持驼峰形式请求12345678910111213141516171819202122232425262728293031323334353637383940414243namespace common\components;use \yii\web\Controller;//使用webuse yii\base\InlineAction;class zController extends Controller&#123; /** * Author:Steven 原作者 * Desc:重写路由，处理访问控制器支持驼峰命名法 * @param string $id * @return null|object|InlineAction */ public function createAction($id) &#123; if ($id === '') &#123; $id = $this-&gt;defaultAction; &#125; $actionMap = $this-&gt;actions(); if (isset($actionMap[$id])) &#123; return \Yii::createObject($actionMap[$id], [$id, $this]); &#125; elseif (preg_match('/^[a-z0-9\\-_]+$/', $id) &amp;&amp; strpos($id, '--') === false &amp;&amp; trim($id, '-') === $id) &#123; $methodName = 'action' . str_replace(' ', '', ucwords(implode(' ', explode('-', $id)))); if (method_exists($this, $methodName)) &#123; $method = new \ReflectionMethod($this, $methodName); if ($method-&gt;isPublic() &amp;&amp; $method-&gt;getName() === $methodName) &#123; return new InlineAction($id, $this, $methodName); &#125; &#125; // 驼峰形式,支持第一个字母小写 &#125; else &#123; $id = ucfirst($id); $methodName = 'action' . $id; if (method_exists($this, $methodName)) &#123; $method = new \ReflectionMethod($this, $methodName); if ($method-&gt;isPublic() &amp;&amp; $method-&gt;getName() === $methodName) &#123; return new InlineAction($id, $this, $methodName); &#125; &#125; &#125; return null; &#125;&#125; 需要驼峰的控制器继承此类就行了参考 Yii2使用驼峰命名的形式访问控制器官方文档]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii的依赖注入容器和服务定位器]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%26%26%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言Yii提供这两个类来进行解耦，功能有多强大呢？yii中创建的对象几乎都是通过容器的方式创建的, 可以看一下 Yii::createObject() 方法，而 $app 本身就是一个服务定位器。由于具体的细节比较多，如果需要详细代码可以参考深入理解Yii2.0和看源码，这里只说一下大概的原理 依赖注入容器 Container为了解决两个类的强耦合，通常我们的做法是通过 构造方法 或者 属性赋值 的方式将一个对象注入到另一个对象中。小项目其实也没什么问题，但是当项目大起来的时候，依赖关系复杂的时候，就会让这个流程变得复杂起来， 容器就很好的解决类这个问题，只需要将依赖关系注册到容器，获取对象的时候容器自动将完成各对象之间的依赖关系。容器这里用的是 构造方法 注入的方式。下面举个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace app\models;use yii\base\Object;use yii\db\Connection;use yii\di\Container;interface UserFinderInterface&#123; function findUser();&#125;class UserFinder extends Object implements UserFinderInterface&#123; public $db; public function __construct(Connection $db, $config = []) &#123; $this-&gt;db = $db; parent::__construct($config); &#125; public function findUser() &#123; &#125;&#125;class UserLister extends Object&#123; public $finder; public function __construct(UserFinderInterface $finder, $config = []) &#123; $this-&gt;finder = $finder; parent::__construct($config); &#125;&#125;／*容器的方式创建 */$container = new Container;$container-&gt;set('yii\db\Connection', [ 'dsn' =&gt; '...',]);$container-&gt;set('app\models\UserFinderInterface', [ 'class' =&gt; 'app\models\UserFinder',]);$container-&gt;set('userLister', 'app\models\UserLister');$lister = $container-&gt;get('userLister');// 和下面的相同/*正常流程的创建 */$db = new \yii\db\Connection(['dsn' =&gt; '...']);$finder = new UserFinder($db);$lister = new UserLister($finder); 原理可以看着上面的例子理解一下，首先我们先将所有的依赖关系注册进去，然后获取对象的时候会通过反射拿取到该类构造方法中定义的所依赖的对象，然后会在所注册的依赖中找到这个依赖，之后就是层层的递归不断的解析新出现的依赖。 服务定位器 ServiceLocator上面已经所说 $app 就是一个服务定位器，其实服务定位器就是一个注册树，将组件注册到了它的上面看一个例子应该就很明白了123456789101112131415$locator = new \yii\di\ServiceLocator;// 在配置文件配置的Components参数，其实就是下面要完成的 $locator-&gt;setComponents([ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'dsn' =&gt; 'sqlite:path/to/file.db', ], 'cache' =&gt; [ 'class' =&gt; 'yii\caching\DbCache', 'db' =&gt; 'db', ],]);// 调用服务定位中注册的组件，组件的创建是通过容器进行创建的 $db = $locator-&gt;get('db'); // or $locator-&gt;db$cache = $locator-&gt;get('cache'); // or $locator-&gt;cache 没看明白的看源码吧，比较好理解]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>yii</tag>
        <tag>容器</tag>
        <tag>服务定位器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii类了解一下]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2F%E5%9F%BA%E7%A1%80%E7%B1%BB-Yii%2F</url>
    <content type="text"><![CDATA[前言Yii这个类相对比较简单，主要做的功能应该就是自动加载，和一些其他全局使用的方法 自动加载Yii自带的自动加载比较简单，一个亮点是为了更快的加载使用了一个自定义的类-路径映射，我们在优化的时候也开把自己要加载的提前放进这个数组中。Composer 自带的自动加载这里也不打算分析了composer自动加载分析] 注册自动加载123456789class Yii extends \yii\BaseYii&#123;&#125;// 注册自动加载，注册到在此之前已经注册的所有自动加载的最前端，也就是会先使用Yii的自动加载进行加载spl_autoload_register(['Yii', 'autoload'], true, true);// 设置类与路径的加载映射，加快自动加载Yii::$classMap = require(__DIR__ . '/classes.php');// 容器Yii::$container = new yii\di\Container(); 自动加载逻辑123456789101112131415161718192021222324public static function autoload($className)&#123; // 是否在定义的 类加载映射文件 if (isset(static::$classMap[$className])) &#123; $classFile = static::$classMap[$className]; if ($classFile[0] === '@') &#123; $classFile = static::getAlias($classFile); &#125; // 下面两个else在找不到的时候会直接return，会交给其他自动加载进行处理 &#125; elseif (strpos($className, '\\') !== false) &#123; $classFile = static::getAlias('@' . str_replace('\\', '/', $className) . '.php', false); if ($classFile === false || !is_file($classFile)) &#123; return; &#125; &#125; else &#123; return; &#125; // 加载类文件 include($classFile); // 判断类、接口、trait类是否存在 if (YII_DEBUG &amp;&amp; !class_exists($className, false) &amp;&amp; !interface_exists($className, false) &amp;&amp; !trait_exists($className, false)) &#123; throw new UnknownClassException("Unable to find '$className' in file: $classFile. Namespace missing?"); &#125;&#125; 别名别名一般用来简化路径和url，像框架的基础路径就是通过别名设置的 设置别名 setAlias12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static function setAlias($alias, $path)&#123; //如果不是以 @ 开头的添加 @ if (strncmp($alias, '@', 1)) &#123; $alias = '@' . $alias; &#125; // 别名是否带有 / ;例如：@yii/ding $pos = strpos($alias, '/'); $root = $pos === false ? $alias : substr($alias, 0, $pos); if ($path !== null) &#123; //$alias 的第一个字符和 @ 比较，如果相等返回0，不相等返回的结果可能是1或-1 为 true // 如果 $path 中含有别名，获取别名路径 $path = strncmp($path, '@', 1) ? rtrim($path, '\\/') : static::getAlias($path); if (!isset(static::$aliases[$root])) &#123; if ($pos === false) &#123; static::$aliases[$root] = $path; &#125; else &#123; // 别名中如果带有 / ;存为二维数组 static::$aliases[$root] = [$alias =&gt; $path]; &#125; // 如果已经设置过别名，而且为字符串 &#125; elseif (is_string(static::$aliases[$root])) &#123; if ($pos === false) &#123; // 直接覆盖 static::$aliases[$root] = $path; &#125; else &#123; // 字符串改成数组形式 static::$aliases[$root] = [ $alias =&gt; $path, $root =&gt; static::$aliases[$root], ]; &#125; // 本身就是数组，则直接添加，并排序 &#125; else &#123; static::$aliases[$root][$alias] = $path; krsort(static::$aliases[$root]); &#125; &#125; elseif (isset(static::$aliases[$root])) &#123; //删除 if (is_array(static::$aliases[$root])) &#123; unset(static::$aliases[$root][$alias]); &#125; elseif ($pos === false) &#123; unset(static::$aliases[$root]); &#125; &#125;&#125; 获取别名 getAlias12345678910111213141516171819202122232425262728293031public static function getAlias($alias, $throwException = true)&#123; //$alias 的第一个字符和 @ 比较，如果相等返回0，不相等返回的结果可能是1或-1进入if if (strncmp($alias, '@', 1)) &#123; // not an alias // 不是别名，不是以 @ 开头 return $alias; &#125; // 别名是否带有 / ;例如：@yii/ding $pos = strpos($alias, '/'); $root = $pos === false ? $alias : substr($alias, 0, $pos); if (isset(static::$aliases[$root])) &#123; // 如果是字符串，则表示存的是路径 if (is_string(static::$aliases[$root])) &#123; return $pos === false ? static::$aliases[$root] : static::$aliases[$root] . substr($alias, $pos); &#125; foreach (static::$aliases[$root] as $name =&gt; $path) &#123; // 在 $alias/ 中匹配 $name/ ,如果存在，就截取路径 if (strpos($alias . '/', $name . '/') === 0) &#123; return $path . substr($alias, strlen($name)); &#125; &#125; &#125; if ($throwException) &#123; throw new InvalidParamException("Invalid path alias: $alias"); &#125; return false;&#125; 其他小方法创建对象创建对象最终是通过容器进行创建的，方便解决依赖1234567891011121314151617181920public static function createObject($type, array $params = [])&#123; // 字符串，代表一个类名、接口名、别名。 if (is_string($type)) &#123; // 全局容器获取实例，并解决其依赖关系 return static::$container-&gt;get($type, $params); // 是个数组，代表配置数组，必须含有 class 元素。 &#125; elseif (is_array($type) &amp;&amp; isset($type['class'])) &#123; $class = $type['class']; unset($type['class']); return static::$container-&gt;get($class, $params, $type); // 是个PHP callable则调用其返回一个具体实例。 &#125; elseif (is_callable($type, true)) &#123; // 解决回调函数的依赖 return static::$container-&gt;invoke($type, $params); &#125; elseif (is_array($type)) &#123; throw new InvalidConfigException('Object configuration must be an array containing a "class" element.'); &#125; throw new InvalidConfigException('Unsupported configuration type: ' . gettype($type));&#125; 配置对象属性值通过数组配置对象对应的属性值12345678public static function configure($object, $properties)&#123; foreach ($properties as $name =&gt; $value) &#123; $object-&gt;$name = $value; &#125; return $object;&#125; 获取对象属性与值 数组1234public static function getObjectVars($object)&#123; return get_object_vars($object);&#125; 获取Yii版本1234public static function getVersion()&#123; return '2.0.12';&#125;]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>别名</tag>
        <tag>自动加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yii基础类Object]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2F%E5%9F%BA%E7%A1%80%E7%B1%BB-Object%2F</url>
    <content type="text"><![CDATA[前言object 作为Yii的最基础的类，只是简单的实现了属性的功能 方法解析构造函数–配置对象通过数组来对对象的属性进行配置 1234567891011121314151617public function __construct($config = [])&#123; if (!empty($config)) &#123; Yii::configure($this, $config); &#125; //调用初始化方法 $this-&gt;init(); &#125;//Yii::configure($this, $config); 给对象的属性赋值如下public static function configure($object, $properties)&#123; foreach ($properties as $name =&gt; $value) &#123; $object-&gt;$name = $value; &#125; return $object;&#125; 获取当前类名获取当前类的类名包含命名空间 12345public static function className()&#123; //后期绑定的类的名称，也就是继承Object类的子类调用此方法是获取的是子类的类名 return get_called_class();&#125; 示例123456789101112131415namespace app\controllers;use Yii;use yii\web\Controller;class TestController extends Controller&#123; public function actionTest() &#123; echo $this-&gt;className(); &#125;&#125;输出app\controllers\TestController 魔术方法通过魔术方法实现了属性功能。属性和成员变量的区别，简单的来理解成员变量是反应结构的(也就是代码实体)，而属性来反应概念的(成员变量的含义)详解 在读取和写入对象的一个不存在的成员变量时，__get() __set()会被自动调用。 Yii正是利用这点，提供对属性的支持的。可以用来实现成员变量的只读或只写功能 __get()当成员变量不存在或者为私有的时候，获取 值时调用这个方法 可以实现一个好处是，如果需要对输出的成员变量的值做一定的处理可以在对应的 getXXX() 方法中实现 1234567891011public function __get($name) &#123; $getter = 'get' . $name; if (method_exists($this, $getter)) &#123; return $this-&gt;$getter(); &#125; elseif (method_exists($this, 'set' . $name)) &#123; throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name); &#125; else &#123; throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name); &#125; &#125; __set()当成员变量不存在或者为私有的时候，设置 值时调用这个方法 可以实现一个好处是，如果需要对赋值的成员变量的值做一定的处理可以在对应的 setXXX() 方法中实现，比如用 trim()去除空格 123456789101112131415161718192021222324public function __set($name, $value)&#123; $setter = 'set' . $name; if (method_exists($this, $setter)) &#123; $this-&gt;$setter($value); &#125; elseif (method_exists($this, 'get' . $name)) &#123; throw new InvalidCallException('Setting read-only property: ' . get_class($this) . '::' . $name); &#125; else &#123; throw new UnknownPropertyException('Setting unknown property: ' . get_class($this) . '::' . $name); &#125;&#125;``` #### `__isset()`测试属性是否存在且值不为 null ，在 `isset($object-&gt;property)` 时被自动调用。 ```phppublic function __isset($name)&#123; $getter = 'get' . $name; if (method_exists($this, $getter)) &#123; return $this-&gt;$getter() !== null; &#125; else &#123; return false; &#125;&#125; __unset()将属性设置成 null 时调用123456789public function __unset($name)&#123; $setter = 'set' . $name; if (method_exists($this, $setter)) &#123; $this-&gt;$setter(null); &#125; elseif (method_exists($this, 'get' . $name)) &#123; throw new InvalidCallException('Unsetting read-only property: ' . get_class($this) . '::' . $name); &#125;&#125; __call()当调用类中的 方法 不存在的时候调用1234public function __call($name, $params)&#123; throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");&#125; 检查是否存在成员变量12345678910111213141516public function hasProperty($name, $checkVars = true)&#123; return $this-&gt;canGetProperty($name, $checkVars) || $this-&gt;canSetProperty($name, false);&#125;public function canGetProperty($name, $checkVars = true)&#123; // 检查对象是否有该方法或属性 return method_exists($this, 'get' . $name) || $checkVars &amp;&amp; property_exists($this, $name);&#125;public function canSetProperty($name, $checkVars = true)&#123; return method_exists($this, 'set' . $name) || $checkVars &amp;&amp; property_exists($this, $name);&#125; 检查是否对象是否存在某方法1234public function hasMethod($name)&#123; return method_exists($this, $name);&#125;]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类级别事件]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2F%E5%9F%BA%E7%A1%80%E7%B1%BB-Event%2F</url>
    <content type="text"><![CDATA[前言Event类有两个作用，一个是作为触发事件时携带的一个事件对象，另一个就是定义类级别的事件，其实和对象级别( Component 中定义)的基本一致 类级别和对象级别的事件有什么区别呢？ 注册对象级别的事件，只能通过所注册的对象进行触发 注册的类级别的事件，可以触发的情况就比较多； 对象触发事件的时候在最后是调用一下类级别的触发事件 Event::trigger() ，如果该对象的 所有继承的父类、所有实现接口上绑定了这个事件，将会触发 也就是说通过对象或类进行触发事件，如果对象或类的父类中或实现的接口中包含了当前注册事件的类，如果这个类有这个事件，将都会导致触发这个类注册的这个事件 解析属性1234public $name; // 事件名public $sender; // 事件发布者，通常是调用了 trigger() 的对象或类。public $handled = false; // 是否终止事件的后续处理public $data; // 事件相关数据，事件绑定on时传递的数据 绑定类级别事件1234567891011121314151617181920212223242526/** * 绑定类级别的事件 * * 实例，在插入数据后触发记录日志 * * Event::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) &#123; * Yii::trace(get_class($event-&gt;sender) . ' is inserted.'); * &#125;); * * * @param string $class 类全名() * @param string $name 事件名称 * @param callable $handler 事件处理程序 * @param mixed $data 绑定时要传递的数据 * @param bool $append 插入到事件处理数组的头部还是尾部 */public static function on($class, $name, $handler, $data = null, $append = true)&#123; $class = ltrim($class, '\\'); if ($append || empty(self::$_events[$name][$class])) &#123; self::$_events[$name][$class][] = [$handler, $data]; &#125; else &#123; //数组头部插入 array_unshift(self::$_events[$name][$class], [$handler, $data]); &#125;&#125; 解绑事件12345678910111213141516171819202122232425262728293031323334/** * 解绑类级别的事件 * * * @param string $class 类全名 * @param string $name 事件名称 * @param callable $handler 事件处理程序 * @return bool whether a handler is found and detached. */public static function off($class, $name, $handler = null)&#123; $class = ltrim($class, '\\'); if (empty(self::$_events[$name][$class])) &#123; return false; &#125; //解绑 class 上事件名为 $name 的所有事件处理程序 handler if ($handler === null) &#123; unset(self::$_events[$name][$class]); return true; &#125; $removed = false; foreach (self::$_events[$name][$class] as $i =&gt; $event) &#123; if ($event[0] === $handler) &#123; unset(self::$_events[$name][$class][$i]); $removed = true; &#125; &#125; if ($removed) &#123; //重新排序数组，将unset掉的位置补上 self::$_events[$name][$class] = array_values(self::$_events[$name][$class]); &#125; return $removed;&#125; 1234567/** * 解绑所有事件 */public static function offAll()&#123; self::$_events = [];&#125; 触发事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 触发一个类级别的事件，同时会触发父类的和实现接口的同样的事件 * This method will cause invocation of event handlers that are attached to the named event * for the specified class and all its parent classes. * @param string|object $class 对象或类全名 * @param string $name 事件名称 * @param Event $event 事件对象，用来携带数据 */public static function trigger($class, $name, $event = null)&#123; if (empty(self::$_events[$name])) &#123; return; &#125; if ($event === null) &#123; $event = new static; &#125; $event-&gt;handled = false; $event-&gt;name = $name; if (is_object($class)) &#123; if ($event-&gt;sender === null) &#123; //设置发送者 $event-&gt;sender = $class; &#125; //获取对象类名 $class = get_class($class); &#125; else &#123; $class = ltrim($class, '\\'); &#125; // 将会触发当前类、所有继承的父类、所有实现接口上绑定的同一事件 $classes = array_merge( [$class], // 所继承的所有父类--祖祖辈辈 class_parents($class, true), // 所实现的所有接口--祖祖辈辈 class_implements($class, true) ); foreach ($classes as $class) &#123; if (empty(self::$_events[$name][$class])) &#123; continue; &#125; foreach (self::$_events[$name][$class] as $handler) &#123; $event-&gt;data = $handler[1]; // 执行事件处理程序 call_user_func($handler[0], $event); if ($event-&gt;handled) &#123; return; &#125; &#125; &#125;&#125; 查看是事件的绑定 查看一个类在某个事件上是否绑定事件处理程序 1234567891011121314151617181920212223242526272829303132/** * * * @param string|object $class 对象或类全名 * @param string $name 事件名 * @return bool whether there is any handler attached to the event. */public static function hasHandlers($class, $name)&#123; if (empty(self::$_events[$name])) &#123; return false; &#125; if (is_object($class)) &#123; $class = get_class($class); &#125; else &#123; $class = ltrim($class, '\\'); &#125; $classes = array_merge( [$class], class_parents($class, true), class_implements($class, true) ); foreach ($classes as $class) &#123; if (!empty(self::$_events[$name][$class])) &#123; return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>事件Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Component实现行为和事件]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2F%E5%9F%BA%E7%A1%80%E7%B1%BB-Component-Behavior%2F</url>
    <content type="text"><![CDATA[前言Component 算是yii最核心的基础类了，同时实现了事件和 BehaviorComponent 虽然继承与 Object ，但为了实现 Behavior 对象的属性和方法的注入， Component 重写了 Object 中所有和调用属性和方法有关的方法。原理也很简单，就是在当前对象找不到的属性或方法，在绑定的行为里再找一遍 例如调用不存在的方法的时候12345678910111213public function __call($name, $params)&#123; // 先确保注册的behaviors绑定 $this-&gt;ensureBehaviors(); // 检查绑定的behaviors中有没有要调用的方法 foreach ($this-&gt;_behaviors as $object) &#123; if ($object-&gt;hasMethod($name)) &#123; return call_user_func_array([$object, $name], $params); &#125; &#125; throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . "::$name()");&#125; Event-事件功能 $handler 事件处理程序 相关属性12//绑定的事件及事件处理程序存储private $_events = []; 事件的绑定123456789101112131415161718192021222324252627282930313233/** * 给当前对象的事件绑定事件处理程序 * * $handler 事件处理程序的格式 * * function ($event) &#123; ... &#125; // anonymous function * [$object, 'handleClick'] // $object-&gt;handleClick() * ['\Page', 'handleClick'] // \Page::handleClick() * 'handleClick' // global function handleClick() * * * 事件处理程序必须是下面的这种形式，$event 是 Event 对象 * * function ($event)&#123;&#125; * * * @param string $name 事件名称 * @param callable $handler 事件处理程序 * @param mixed $data 传递的数据 * @param bool $append 插入到事件处理数组的头部还是尾部 * @see off() */public function on($name, $handler, $data = null, $append = true)&#123; //确定行为已将绑定 $this-&gt;ensureBehaviors(); if ($append || empty($this-&gt;_events[$name])) &#123; $this-&gt;_events[$name][] = [$handler, $data]; &#125; else &#123; //在数组开头插入 array_unshift($this-&gt;_events[$name], [$handler, $data]); &#125;&#125; 事件的解除1234567891011121314151617181920212223242526272829303132/** * 解绑事件 * * @param string $name 事件名称 * @param callable $handler 要解除的事件处理程序 * @return bool if a handler is found and detached */public function off($name, $handler = null)&#123; //确定行为绑定 $this-&gt;ensureBehaviors(); if (empty($this-&gt;_events[$name])) &#123; return false; &#125; if ($handler === null) &#123; unset($this-&gt;_events[$name]); return true; &#125; $removed = false; foreach ($this-&gt;_events[$name] as $i =&gt; $event) &#123; if ($event[0] === $handler) &#123; unset($this-&gt;_events[$name][$i]); $removed = true; &#125; &#125; if ($removed) &#123; //重新排序数组，将unset掉的位置补上 $this-&gt;_events[$name] = array_values($this-&gt;_events[$name]); &#125; return $removed;&#125; 事件的触发1234567891011121314151617181920212223242526272829303132333435363738/** * 触发事件 * 事件发生时，触发事件处理程序 * * @param string $name 事件名称 * @param Event $event 事件对象，如果没有给，将会创建 Event 对象 */public function trigger($name, Event $event = null)&#123; //确定行为绑定 $this-&gt;ensureBehaviors(); if (!empty($this-&gt;_events[$name])) &#123; if ($event === null) &#123; $event = new Event; &#125; if ($event-&gt;sender === null) &#123; //设置发送者 $event-&gt;sender = $this; &#125; $event-&gt;handled = false; $event-&gt;name = $name; foreach ($this-&gt;_events[$name] as $handler) &#123; // 赋值要传递的数据 $event-&gt;data = $handler[1]; //调用事件处理程序handler call_user_func($handler[0], $event); // 如果在某一事件处理程序handler中将$event-&gt;handled设为true，将会不再执行后面的handler if ($event-&gt;handled) &#123; return; &#125; &#125; &#125; // 触发类一级的事件，触发绑定到这个class以及父类和父接口的这个事件 Event::trigger($this, $name, $event);&#125; 查看事件是否绑定绑定1234567891011/** * Returns a value indicating whether there is any handler attached to the named event. * @param string $name the event name * @return bool whether there is any handler attached to the event. */public function hasEventHandlers($name)&#123; //确定行为绑定 $this-&gt;ensureBehaviors(); return !empty($this-&gt;_events[$name]) || Event::hasHandlers($this, $name);&#125; 行为功能所为的行为就是将注册到当前component中的行为类的属性和方法当做自己的使用行为需要行为类 Behavior 和 Component 类结合使用 相关属性12private $_behaviors; 注册行为的原理要使用行为肯定是先要进行注册的，component中大多数方法会调用 ensureBehaviors() 方法来先确认绑定，我们来看一下逻辑1234567891011121314151617181920212223242526272829303132333435363738394041/*** 确保 [[behaviors()]] 绑定到这个component上*/public function ensureBehaviors()&#123; if ($this-&gt;_behaviors === null) &#123; $this-&gt;_behaviors = []; foreach ($this-&gt;behaviors() as $name =&gt; $behavior) &#123; $this-&gt;attachBehaviorInternal($name, $behavior); &#125; &#125;&#125;/** * 将行为绑定到component对象 * @param string|int $name 行为名字 * @param string|array|Behavior $behavior the behavior to be attached * @return Behavior the attached behavior. */private function attachBehaviorInternal($name, $behavior)&#123; // 不是 Behavior 实例，说是只是类名、配置数组，那么就创建出来 if (!($behavior instanceof Behavior)) &#123; $behavior = Yii::createObject($behavior); &#125; // 匿名行为 if (is_int($name)) &#123; // 行为对象中定义的事件注册到当前对象 $behavior-&gt;attach($this); $this-&gt;_behaviors[] = $behavior; &#125; else &#123; // 已经有一个同名的行为，要先解除，再将新的行为绑定上去。 if (isset($this-&gt;_behaviors[$name])) &#123; $this-&gt;_behaviors[$name]-&gt;detach(); &#125; // 行为对象中定义的事件注册到当前对象 $behavior-&gt;attach($this); $this-&gt;_behaviors[$name] = $behavior; &#125; return $behavior;&#125; 会发现在注册行为对象的时候，行为对象会把它里面定义的事件注册到当前对象 使用行为的原理前面说了， component 为了实现行为，重写了 Object 中的属性以及其他方法，我们这里简单的看一下重写后的属性方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 重写了Object的 __get方法 为了兼用行为 * Returns the value of a component property. * This method will check in the following order and act accordingly: * * - a property defined by a getter: return the getter result * - a property of a behavior: return the behavior property value * * Do not call this method directly as it is a PHP magic method that * will be implicitly called when executing `$value = $component-&gt;property;`. * @param string $name the property name * @return mixed the property value or the value of a behavior's property * @throws UnknownPropertyException if the property is not defined * @throws InvalidCallException if the property is write-only. * @see __set() */public function __get($name)&#123; $getter = 'get' . $name; if (method_exists($this, $getter)) &#123; // read property, e.g. getName() return $this-&gt;$getter(); &#125; /* 检查绑定的behavior是否含有此属性 */ // 将behavior()中配置的behavior添加到_behaviors数组 // behavior property $this-&gt;ensureBehaviors(); foreach ($this-&gt;_behaviors as $behavior) &#123; // 是否存在属性 if ($behavior-&gt;canGetProperty($name)) &#123; return $behavior-&gt;$name; &#125; &#125; if (method_exists($this, 'set' . $name)) &#123; throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name); &#125; throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);&#125;/** * 设置属性 * Sets the value of a component property. * This method will check in the following order and act accordingly: * * - a property defined by a setter: set the property value * - an event in the format of "on xyz": attach the handler to the event "xyz" * - a behavior in the format of "as xyz": attach the behavior named as "xyz" * - a property of a behavior: set the behavior property value * * Do not call this method directly as it is a PHP magic method that * will be implicitly called when executing `$component-&gt;property = $value;`. * @param string $name the property name or the event name * @param mixed $value the property value * @throws UnknownPropertyException if the property is not defined * @throws InvalidCallException if the property is read-only. * @see __get() */public function __set($name, $value)&#123; $setter = 'set' . $name; if (method_exists($this, $setter)) &#123; // set property $this-&gt;$setter($value); return; /** 下面这两个是在配置数组中有用到 */ // 如果以 on 开头，进行事件绑定 &#125; elseif (strncmp($name, 'on ', 3) === 0) &#123; // on event: attach event handler $this-&gt;on(trim(substr($name, 3)), $value); return; // 如果以 as 开头 绑定行为 &#125; elseif (strncmp($name, 'as ', 3) === 0) &#123; // as behavior: attach behavior $name = trim(substr($name, 3)); $this-&gt;attachBehavior($name, $value instanceof Behavior ? $value : Yii::createObject($value)); return; &#125; // 看绑定的行为中是否存在此属性 // behavior property $this-&gt;ensureBehaviors(); foreach ($this-&gt;_behaviors as $behavior) &#123; if ($behavior-&gt;canSetProperty($name)) &#123; $behavior-&gt;$name = $value; return; &#125; &#125; if (method_exists($this, 'get' . $name)) &#123; throw new InvalidCallException('Setting read-only property: ' . get_class($this) . '::' . $name); &#125; throw new UnknownPropertyException('Setting unknown property: ' . get_class($this) . '::' . $name);&#125; 行为的绑定方式静态的绑定覆盖behaviors()例如：123456789101112131415161718192021222324252627class User extends ActiveRecord&#123; public function behaviors() &#123; return [ // 匿名的行为，仅直接给出行为的类名称 MyBehavior::className(), // 名为myBehavior2的行为，也是仅给出行为的类名称 'myBehavior2' =&gt; MyBehavior::className(), // 匿名行为，给出了MyBehavior类的配置数组 [ 'class' =&gt; MyBehavior::className(), 'prop1' =&gt; 'value1', 'prop3' =&gt; 'value3', ], // 名为myBehavior4的行为，也是给出了MyBehavior类的配置数组 'myBehavior4' =&gt; [ 'class' =&gt; MyBehavior::className(), 'prop1' =&gt; 'value1', 'prop3' =&gt; 'value3', ] ]; &#125;&#125; 配置方式这个通过配置方式创建对象( Yii::createObject() )时，由于不存在的成员变量时会调用 Component 的 __set() 方法，方法中会进行注册例如：123456789[ 'as myBehavior2' =&gt; MyBehavior::className(), 'as myBehavior3' =&gt; [ 'class' =&gt; MyBehavior::className(), 'prop1' =&gt; 'value1', 'prop3' =&gt; 'value3', ],] 动态的绑定调用组件(Compoent)的 attachBehavior() 方法yii\base\Compoent::attachBehaviors()12345678910111213141516171819// 和静态绑定原理一样 /** * 绑定单个 **/public function attachBehavior($name, $behavior)&#123; $this-&gt;ensureBehaviors(); return $this-&gt;attachBehaviorInternal($name, $behavior);&#125;/** * 绑定多个 **/public function attachBehaviors($behaviors)&#123; $this-&gt;ensureBehaviors(); foreach ($behaviors as $name =&gt; $behavior) &#123; $this-&gt;attachBehaviorInternal($name, $behavior); &#125;&#125; 获取绑定的行为1234//获取绑定的单个行为对象$behavior = $Component-&gt;getBehavior('myBehavior2');//获取所有绑定的行为对象$behaviors = $Component-&gt;getBehaviors(); 解除行为解除单个例如：$Component-&gt;detachBehavior(&#39;myBehavior2&#39;);12345678910111213public function detachBehavior($name)&#123; $this-&gt;ensureBehaviors(); if (isset($this-&gt;_behaviors[$name])) &#123; $behavior = $this-&gt;_behaviors[$name]; unset($this-&gt;_behaviors[$name]); // 解绑事件 $behavior-&gt;detach(); return $behavior; &#125; return null;&#125; 解除所有例如：$Component-&gt;detachBehaviors();1234567891011/** * 解绑所有 */public function detachBehaviors()&#123; $this-&gt;ensureBehaviors(); foreach ($this-&gt;_behaviors as $name =&gt; $behavior) &#123; $this-&gt;detachBehavior($name); &#125;&#125; 行为类Behavior行为类就比较简单了，实现的两个方法就是对事件的注册和解绑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Behavior extends Object&#123; // 指向行为本身所绑定的Component对象 public $owner; /** * 子类可以覆盖这个方法，返回一个要绑定到 component 对象上的事件 * * The callbacks can be any of the following: * * - method in this behavior: `'handleClick'`, equivalent to `[$this, 'handleClick']` * - object method: `[$object, 'handleClick']` * - static method: `['Page', 'handleClick']` * - anonymous function: `function ($event) &#123; ... &#125;` * * The following is an example: * * php * [ * Model::EVENT_BEFORE_VALIDATE =&gt; 'myBeforeValidate', * Model::EVENT_AFTER_VALIDATE =&gt; 'myAfterValidate', * ] * * * @return array events (array keys) and the corresponding event handler methods (array values). */ public function events() &#123; return []; &#125; /** * 将行为和component对象绑定起来，并且将事件event注册到component对象 */ public function attach($owner) &#123; $this-&gt;owner = $owner; foreach ($this-&gt;events() as $event =&gt; $handler) &#123; $owner-&gt;on($event, is_string($handler) ? [$this, $handler] : $handler); &#125; &#125; /** * 解绑 */ public function detach() &#123; if ($this-&gt;owner) &#123; foreach ($this-&gt;events() as $event =&gt; $handler) &#123; $this-&gt;owner-&gt;off($event, is_string($handler) ? [$this, $handler] : $handler); &#125; $this-&gt;owner = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>行为Behavior</tag>
        <tag>事件Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-Excel]]></title>
    <url>%2F2018%2F11%2F09%2Fyii%2FExcel%2F</url>
    <content type="text"><![CDATA[说明对excel的操作常用的操作一般还是比较简单的，如果直接去看 phpexcel 可能会感觉方法太多而无从下手，我们这里直接用经过封装过的 yii-excel 来进行学习就相对简单的多，最后也提供了一个更简单的写excel的和读写csv的两个类供参考学习用到的两张表放在最后附件了，自行下载，用到的两个模型类是通过 gii 直接创建的 开始安装 yii-excel直接进项目执行1composer require --prefer-dist moonlandsoft/yii2-phpexcel "*" 安装后 vendor 目录下将会多两个文件夹 moonlandsoft/yii-phpexcel 和 phpoffice/phpexcel 下载excel一表单sheet看代码吧，注释已经很清楚了12345678910111213141516/** * 一表单sheet下载 * @return [type] [description] */public function actionIndex()&#123; $models = LevelModel::find()-&gt;all(); Excel::widget([ 'models' =&gt; $models, 'fileName' =&gt; '下载', // 设置下载文件名 // 'savePath' =&gt; 'D:\ding\wamp64\www\yii\advance\yii-learn\backend\runtime', // 生成在服务器 'mode' =&gt; 'export', // 导出 'columns' =&gt; ['level_id','level_name','p_order'], // 列，通过 $model['level_id'] 来取对应的值 'headers' =&gt; ['level_id' =&gt; 'Header Column 1','level_name' =&gt; 'Header Column 2', 'p_order' =&gt; 'Header Column 3'], // 列对应的header ，title行的数据 ]);&#125; level 表结构 下载的 excel 结果 一表多sheet1234567891011121314151617181920212223242526/** * 一表多sheet 下载 * @param string $value [description] * @return [type] [description] */public function actionMultiple()&#123; $model1 = LevelModel::find()-&gt;all(); $model2 = ColorModel::find()-&gt;all(); Excel::widget([ 'isMultipleSheet' =&gt; true, 'models' =&gt; [ 'sheet1' =&gt; $model1, 'sheet2' =&gt; $model2, ], 'mode' =&gt; 'export', //default value as 'export' 'columns' =&gt; [ 'sheet1' =&gt; ['level_id','level_name','p_order'], 'sheet2' =&gt; ['color_no','color_name','scheme_id'], ], 'headers' =&gt; [ 'sheet1' =&gt; ['level_id' =&gt; 'Header Column 1','level_name' =&gt; 'Header Column 2', 'p_order' =&gt; 'Header Column 3'], 'sheet2' =&gt; ['color_no' =&gt; 'Header Column 1','color_name' =&gt; 'Header Column 2', 'scheme_id' =&gt; 'Header Column 3'], ], ]);&#125; color 表结构 下载的 excel 结果 下载数组格式的使用已经准备好的数据，下载成excel而不依赖model 1234567891011121314151617181920212223/** * 一表单sheet下载 * @return [type] [description] */public function actionData()&#123; $models = [ ['level_id' =&gt; 1, 'level_name' =&gt; 'ding', 'p_order' =&gt; 21], ['level_id' =&gt; 2, 'level_name' =&gt; 'ding', 'p_order' =&gt; 21], // 生成空行 ['level_id' =&gt; '', 'level_name' =&gt; '', 'p_order' =&gt; ''], // 巧妙设置统计信息 ['level_id' =&gt; '总额：', 'level_name' =&gt; '128'], ]; Excel::widget([ 'models' =&gt; $models, 'fileName' =&gt; '下载', // 设置下载文件名 // 'savePath' =&gt; 'D:\ding\wamp64\www\yii\advance\yii-learn\backend\runtime', // 生成在服务器 'mode' =&gt; 'export', // 导出 'columns' =&gt; ['level_id','level_name','p_order'], // 列，通过 $model['level_id'] 来取对应的值 'headers' =&gt; ['level_id' =&gt; 'Header Column 1','level_name' =&gt; 'Header Column 2', 'p_order' =&gt; 'Header Column 3'], // 列对应的header ，title行的数据 ]);&#125; 下载的 excel 结果 读取excel文件数据为了方便测试，直接把excel放在了 web 目录下 读取单文件可以开启 getOnlySheet 注释进行自行测试12345678910111213141516/** * 读取单文件 * @return [type] [description] */public function actionImport()&#123; $fileName = 'exports2.xls'; $data = Excel::widget([ 'mode' =&gt; 'import', // 导入模式 'fileName' =&gt; $fileName, // 文件名 'setFirstRecordAsKeys' =&gt; true, // 是否使用第一行的title字段作为行数据的key 'setIndexSheetByName' =&gt; true, // 是否使用sheet名作为sheet数组的key // 'getOnlySheet' =&gt; '单元1', // 读取那个sheet的name ，如果不设置则读取所有的sheet ]); echo json_encode($data);&#125; excel 文件结构 读取的数据结构 读取多文件一次读取多个文件的数据1234567891011121314151617181920/** * 读取多文件 * @return [type] [description] */public function actionImporttwo()&#123; $fileName1 = 'exports2.xls'; $fileName2 = 'exports1.xls'; $data = Excel::widget([ 'mode' =&gt; 'import', // 导入模式 'fileName' =&gt; [ 'file1' =&gt; $fileName1, 'file2' =&gt; $fileName2, ], 'setFirstRecordAsKeys' =&gt; true, 'setIndexSheetByName' =&gt; true, // 'getOnlySheet' =&gt; '单元1', // 读取那个sheet的name ，如果不设置则读取所有的sheet ]); echo json_encode($data);&#125; 读取的数据结构 其他简单的下载Excel的类看dome比较简单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?php/** * * // dome * // 下载的文件名 * $filename = 'test'; * // title行 * $titles = ['title1']; * SimpleExcel::echoBegin($filename, $titles); * $data = [ * ['1a'], // 第一行 * ['2a', '2b'], // 第二行 * ]; * SimpleExcel::echoRows($data); * // 追加行 * SimpleExcel::echoRows($data); * // 输出 * SimpleExcel::echoFinish(); * * 注意不要下载数据量太大的，会非常慢，而且excel有行数限制 */class SimpleExcel&#123; /** * 设置请求头 * @param string $filename [description] */ private static function setHeaders($filename = 'data') &#123; // 检验header头是否已经发送 if (headers_sent($file, $line)) &#123; echo 'Header already sent @ ' . $file . ':' . $line; return; &#125; //header('Cache-Control: no-cache;must-revalidate'); //fix ie download bug header('Pragma: no-cache, no-store'); header("Expires: Wed, 26 Feb 1997 08:21:57 GMT"); header('Content-type: application/force-download;charset=utf-8'); header("Content-Disposition: attachment; filename=\"" . $filename . '"'); &#125; /** * * @param [type] $filename [description] * @param array $titles [description] * @return [type] [description] */ public static function echoBegin($filename = '', $titles = []) &#123; if (empty($filename)) &#123; $filename = date("Y-m-d"); &#125; self::setHeaders($filename . '.xls'); echo ' &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;style&gt; td&#123;vnd.ms-excel.numberformat:@&#125; &lt;/style&gt; &lt;/head&gt;'; echo '&lt;table width="100%" border="1"&gt;'; echo '&lt;tr&gt;&lt;th filter=all&gt;' . implode('&lt;/th&gt;&lt;th filter=all&gt;', $titles) . "&lt;/th&gt;&lt;/tr&gt;\r\n"; flush(); &#125; public static function echoRows($rows) &#123; foreach ($rows as $row) &#123; echo '&lt;tr&gt;&lt;td&gt;' . implode('&lt;/td&gt;&lt;td&gt;', $row) . "&lt;/td&gt;&lt;/tr&gt;\r\n"; &#125; flush(); &#125; public static function echoFinish() &#123; echo '&lt;/table&gt;'; flush(); &#125;&#125; csv文件的读取和下载读取csv格式文件和将数据生成csv格式文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?php/** * * // dome * // 下载的文件名 * $filename = 'test.csv'; * // title行 * $titles = ['title1', 'title2']; * $data = [ * ['1a', '1b'], // 第一行 * ['2a', '2b'], // 第二行 * # 加前引号，表示字符串格式的数据 * ["'".'123456789999.00', '1234567899990000000.00'], * ]; * * SimpleCsv::exportCsv($titles, $data, $filename); * // 上传数据 * // 上传文件的文件名 * $filename = './test.csv'; * var_dump(SimpleCsv::importCsv($filename)); * * csv 格式可以突破excel行数的限制，而且速度也相对较快 * 缺点就是如果需要excel的其他操作需要另存为excel */class SimpleCsv&#123; /** * 导出csv文件 * @param Array $csv_header title行 * @param Array $data 数据 * @param string $filename 文件名 以 .csv 结尾 * @return [type] [description] */ public static function exportCsv(Array $csv_header, Array $data, $filename='') &#123; $filename =$filename?$filename:date('Ymd').'.csv'; //设置文件名 header("Content-type:text/csv"); header("Content-Disposition:attachment;filename=".$filename); header('Cache-Control:must-revalidate,post-check=0,pre-check=0'); header('Expires:0'); header('Pragma:public'); foreach ($csv_header as $k =&gt; $v) &#123; $csv_header[$k] = iconv('utf-8','gb2312',$v); &#125; echo implode(',', $csv_header) . "\n"; $str = ''; foreach($data as $v)&#123; foreach ($v as $key =&gt; $col)&#123; $v[$key] = iconv('utf-8','gb2312//IGNORE',$col); &#125; $abc = implode(',',$v); $str .= $abc. "\n"; &#125; echo $str; flush(); &#125; /** * 导入csv * @param $file * @internal param $filename * @return array|bool */ public static function importCsv($file) &#123; $handle = fopen($file, 'r'); $result = self::inputCsv($handle); //解析csv fclose($handle); //关闭指针 return $result; &#125; /** * 处理导入数据 * @param $handle fopen($file, 'r') * @return array */ private static function inputCsv($handle) &#123; $out = array (); $n = 0; while ($data = fgetcsv($handle)) &#123; $num = count($data); for ($i = 0; $i &lt; $num; $i++) &#123; $out[$n][$i] = mb_convert_encoding($data[$i],'UTF-8','GBK'); &#125; $n++; &#125; return $out; &#125;&#125; 附件level表color表]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook等其他资源]]></title>
    <url>%2F2018%2F10%2F24%2Fothers%2F%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[gitbook资源爬虫笔记]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫-scrapy]]></title>
    <url>%2F2018%2F10%2F23%2Fspider%2Fscrapy%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[实现项目创建项目1234567891011121314151617181920scrapy startproject cancao # 将会创建cankao项目目录及文件 └── cankao ├── cankao │ ├── __init__.py │ ├── items.py │ ├── middlewares.py │ ├── pipelines.py │ ├── settings.py │ └── spiders │ └── __init__.py └── scrapy.cfgscrapy.cfg # 项目的部署文件cankao/ # 项目的Python模块，将会从这里引用代码cankao/items.py # 项目的Item文件cankao/pipelines.py # 项目的管道文件用于文件持久化cankao/settings.py # 项目的配置文件cankao/middlewares.py # 中间件cankao/spiders/ # 存储爬虫代码目录 创建爬虫12345678910111213141516171819202122232425# 进入到项目目录cd cankao# 创建爬虫的命令 爬虫名称 限制的域名scrapy genspider cankao1 douban.com# spiders文件夹下生成cankao1.py文件# -*- coding: utf-8 -*-import scrapyclass Cankao1Spider(scrapy.Spider): # 爬虫名，必填 name = 'cankao1' # 允许访问的域名 allowed_domains = ['douban.com'] # 开始的url start_urls = ['http://douban.com/'] def parse(self, response): ''' 解析 :param response: :return: ''' pass 我们对网页进行分析获取需要的内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding: utf-8 -*-import scrapyfrom scrapy.http.request import Requestclass Cankao1Spider(scrapy.Spider): ''' 爬取豆瓣图书图片，单层爬虫 ''' # 爬虫名，必填 name = 'cankao1' # 允许访问的域名，只允许访问这个域名下的url allowed_domains = ['douban.com'] # 开始的url start_urls = ['https://book.douban.com/'] # 自定义配置，会覆盖项目配置 custom_settings = &#123;&#125; # def start_requests(self): # ''' # 重写父类的方法，父类的方法默认从start_urls中读取开始爬取 # 一般不需要重写，但是如果第一步就是登陆的话就需要重写了 # :return: # ''' def parse(self, response): ''' 解析 :param response: :return: ''' # 打印响应体 # print(response.body) papers = response.xpath('//*[@id="content"]/div/div[1]/div[1]/div[2]/div/div/ul[2]/li') # print(papers) for paper in papers: url = paper.xpath('.//div/a/@href').extract_first() img = paper.xpath('.//div/a/img/@src').extract_first() content = paper.xpath('.//div/div/a/text()').extract_first() print(url, img, content) # time.sleep(5000) # 分析下一个请求,进行请求（测试一下allowed_domains，不属于不能请求） # yield Request(url='http://www.bunao.win')``` #### 执行爬虫 执行爬虫命令 `scrapy crawl cankao1` ，执行后可以看到输出的执行信息，方便进行分析 此时可能并没有输出所期望的数据，我们需要修改配置参数 ```pythonsettings.py 文件 # 客户端 user-agent请求头USER_AGENT = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'# 是否遵守robot协议ROBOTSTXT_OBEY = False 此时，我们执行 scrapy crawl cankao1 --nolog 来查看不带执行信息的输入内容 创建item创建 item 就比较简单了，主要是用来存放保存信息的12345678910import scrapyclass CankaoItem(scrapy.Item): ''' 定义要保存的字段 ''' # define the fields for your item here like: url = scrapy.Field() img = scrapy.Field() content = scrapy.Field() 创建 pipeline , 存储数据数据保存到文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import jsonfrom scrapy.exceptions import DropItemclass CankaoPipeline(object): ''' 保存到文件中 ''' def __init__(self): self.file = open('./download/papers.json', 'wb') # def open_spider(self, spider): # ''' # spider是一个Spider对象，代表开启的Spider，当spider被开启时，调用这个方法 # 数据库/文件的开启可以放在这里 # :param spider: # :return: # ''' # pass def process_item(self, item, spider): ''' 处理item，进行保存 :param item: :param spider: :return: ''' print(item['img']) if item['img']: line = json.dumps(dict(item)) + '\n' # 要转成字节类型，写入文件 self.file.write(line.encode()) # 给下一个pipline处理 return item else: # 丢弃，后面的pipline也无法处理了 raise DropItem('miss img in %s' % item) def close_spider(self, spider): ''' spider被关闭的时候调用 可以放置数据库/文件关闭的代码 :param spider: :return: ''' # pass self.file.close() print('pipine open file times %s' % 5) # @classmethod # def from_crawler(cls, crawler): # ''' # 类方法，用来创建pipeline实例，可以通过crawler来获取scarpy所有的核心组件，如配置 # :param crawler: # :return: # ''' # pass 配置写好的 pipelines 需要配置激活123456settings.py# 激活pipline，从低到高开始执行ITEM_PIPELINES = &#123; 'cankao.pipelines.CankaoPipeline': 300,&#125; 数据保存到mongo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymongo import MongoClientclass CankaoMongoPipeline(object): ''' 以mongo存储为例 ''' # 集合名 collection_name = 'scrapy_items' def __init__(self, mongo_uri, mongo_port, mongo_db): self.mongo_uri = mongo_uri self.mongo_port = mongo_port self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): ''' 类方法，用来创建pipeline实例，可以通过crawler来获取scarpy所有的核心组件，如配置 :param crawler: :return: ''' return cls( # 获取mongo连接 mongo_uri = crawler.settings.get('MONGO_URI'), # 获取mongo连接 mongo_port = crawler.settings.get('MONGO_PORT'), # 获取数据库，如果没有则用默认的item mongo_db = crawler.settings.get('MONGO_DATABASE', 'fecshop_test') ) def open_spider(self, spider): ''' spider是一个Spider对象，代表开启的Spider，当spider被开启时，调用这个方法 数据库/文件的开启可以放在这里 :param spider: :return: ''' # 连接mongo self.client = MongoClient(self.mongo_uri, self.mongo_port) # 选择使用的数据库 db_auth = self.client[self.mongo_db] # 验证登陆 db_auth.authenticate("simpleUser", "simplePass") self.db = self.client[self.mongo_db] def process_item(self, item, spider): ''' 处理item，进行保存 :param item: :param spider: :return: ''' # 向集合中添加数据 self.db[self.collection_name].insert(dict(item)) return item def close_spider(self, spider): ''' spider被关闭的时候调用 可以放置数据库/文件关闭的代码 :param spider: :return: ''' self.client.close() 配置写好的 pipelines 需要配置激活123456789101112settings.py# 激活pipline，从低到高开始执行ITEM_PIPELINES = &#123; 'cankao.pipelines.CankaoPipeline': 300, 'cankao.pipelines.CankaoMongoPipeline': 500,&#125;# mongo的配置信息MONGO_URI = '118.25.38.240'MONGO_PORT = 27017MONGO_DATABASE = 'fecshop_test' 下载文件(自定义文件名)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import scrapyfrom scrapy.pipelines.files import FilesPipelinefrom scrapy.http import Requestimport osclass CankaoFilesPipeline(FilesPipeline): ''' 下载文件 继承框架自带的FilesPipeline文件下载类 ''' def get_media_requests(self, item, info): ''' 重写此方法， 用来获取图片url进行下载 :param item: :param info: :return: ''' self.item = item yield scrapy.Request(item['img']) # def item_completed(self, results, item, info): # ''' # 下载完成后将会把结果送到这个方法 # :param results: # :param item: # :param info: # :return: # ''' # # print(results) # # ''' # results 为下载返回的数据, 如下 # [(True, &#123;'url': 'https://img3.doubanio.com/view/subject/m/public/s29816983.jpg', 'path': 'full/fced9acc2ecf23e0f96b9a2d9a442b02234f4388.jpg', 'checksum': 'ce0e7d543b37dbe3d21dd46ef8fcbd1b'&#125;)] # 图片下载成功时为True # url 源图片地址 # path 下载的文件路径 # checksum md5 hash # ''' # print(item) # print(info) def file_path(self, request, response=None, info=None): ''' 重写要保存的文件路径，不使用框架自带的hash文件名 :param request: :param response: :param info: :return: ''' def _warn(): from scrapy.exceptions import ScrapyDeprecationWarning import warnings warnings.warn('FilesPipeline.file_key(url) method is deprecated, please use ' 'file_path(request, response=None, info=None) instead', category=ScrapyDeprecationWarning, stacklevel=1) # check if called from file_key with url as first argument if not isinstance(request, Request): _warn() url = request else: url = request.url # 后缀 media_ext = os.path.splitext(url)[1] # 原名带后缀 media_content = url.split("/")[-1] # 使用item中的内容 # return 'full/%s%s' % (self.item['content'], media_ext) return 'full/%s' % (media_content) 配置写好的 pipelines 需要配置激活123456789101112131415settings.py# 激活pipline，从低到高开始执行ITEM_PIPELINES = &#123; 'cankao.pipelines.CankaoPipeline': 300, 'cankao.pipelines.CankaoMongoPipeline': 500, 'cankao.pipelines.CankaoFilesPipeline': 600,&#125;'''FilesPipeline 配置'''# 设置文件存放位置FILES_STORE = './download/files'# 设置文件过期时间30天FILES_EXPIRES = 30 12345678910111213141516171819202122232425262728293031323334353637import scrapyfrom scrapy.pipelines.images import ImagesPipelineclass CankaoImagesPipeline(ImagesPipeline): &apos;&apos;&apos; 继承框架自带的ImagesPipeline图片下载类，可以下载的同时生成不同尺寸的图片放在配置的目录下 &apos;&apos;&apos; def get_media_requests(self, item, info): &apos;&apos;&apos; 重写此方法， 用来获取图片url进行下载 :param item: :param info: :return: &apos;&apos;&apos; yield scrapy.Request(item[&apos;img&apos;]) # def item_completed(self, results, item, info): # &apos;&apos;&apos; # 下载完成后将会把结果送到这个方法 # :param results: # :param item: # :param info: # :return: # &apos;&apos;&apos; # print(results) # # &apos;&apos;&apos; # results 为下载返回的数据, 如下 # [(True, &#123;&apos;url&apos;: &apos;https://img3.doubanio.com/view/subject/m/public/s29827942.jpg&apos;, &apos;path&apos;: &apos;full/ad6acfdbef4d9df208c0e010ed1efcc287cb6225.jpg&apos;, &apos;checksum&apos;: &apos;c5d853689829ba8731cbb27146d89573&apos;&#125;)] # 图片下载成功时为True # url 源图片地址 # path 下载的文件路径 # checksum md5 hash # &apos;&apos;&apos; # print(item) # print(info) 配置写好的 pipelines 需要配置激活12345678910111213141516171819202122232425settings.py# 激活pipline，从低到高开始执行ITEM_PIPELINES = &#123; 'cankao.pipelines.CankaoPipeline': 300, 'cankao.pipelines.CankaoMongoPipeline': 500, 'cankao.pipelines.CankaoFilesPipeline': 600, 'cankao.pipelines.CankaoImagesPipeline': 700,&#125;'''ImagesPipeline 配置'''# 设置图片路径IMAGES_STORE = './download/images'# 制作缩略图IMAGES_THUMBS = &#123; 'small': (50, 50), 'big': (270, 270)&#125;# 设置图片过期时间30天IMAGES_EXPIRES = 30# 过滤下载图片的大小# 过滤条件：最小图片尺寸# IMAGES_MIN_HEIGH = 10# IMAGES_MIN_WIDTH = 10 创建中间件下载中间件实现 随机 USER_AGENT123456789101112131415161718192021222324252627282930313233343536373839import randomclass RandomUserAgent(object): ''' 使用随机 User-Agent的中间件 ''' def __init__(self, agents): self.agents = agents @classmethod def from_crawler(cls, crawler): ''' 通过这个类方法创建对象 :param crawler: :return: ''' ''' settings.py USER_AGENTS的值示例 USER_AGENTS = [ 'Mozilla/5.1 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'Mozilla/5.2 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'Mozilla/5.3 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', ] ''' # 获取配置文件settings中USER_AGENTS的值 return cls(crawler.settings.getlist('USER_AGENTS')) def process_request(self, request, spider): print('here') ''' 中间件请求过程中设置request :param request: :param spider: :return: ''' # 设置request的的User-Agent头 # setdefault 如果已经存在了就不会重新赋值了，所以中间件要靠前才生效 request.headers.setdefault("User-Agent", random.choice(self.agents)) 配置123456789101112settings.py # 下载中间件DOWNLOADER_MIDDLEWARES = &#123; 'cankao.middlewares.RandomUserAgent': 100, # 数值要小&#125;# 客户端 user-agent请求头 随机使用一个USER_AGENTS = [ 'Mozilla/5.1 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'Mozilla/5.2 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'Mozilla/5.3 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36',] 下载中间件实现 随机代理1234567891011121314151617181920class RandomProxy(object): ''' 使用随机代理的中间件 ''' def __init__(self, iplist): self.iplist = iplist @classmethod def from_crawler(cls, crawler): return cls(crawler.settings.getlist('IPLIST')) def process_request(self, request, spider): ''' 给代理随机添加上一个代理 :param request: :param spider: :return: ''' proxy = random.choice(self.iplist) request.meta['proxy'] = proxy 配置同上 创建 cankao2 爬虫，并验证中间件，实现cookie管理1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-import scrapyfrom scrapy.http.request import Requestimport randomclass Cankao2Spider(scrapy.Spider): ''' 测试随机User-agent头中间件和cookie管理 ''' name = 'cankao2' allowed_domains = ['wuxingxiangsheng.com'] # start_urls = ['http://temp.wuxingxiangsheng.com/test/request'] def start_requests(self): # cookiejar 参数用来自动管理cookie， 可以自动管理多个，根据cookiejar对应的值不同 return [Request('http://temp.wuxingxiangsheng.com/test/request', meta = &#123;'cookiejar':1&#125;)] def parse(self, response): ''' 解析 :param response: :return: ''' # 打印响应体 print(response.body) # print(papers) salt = random.random() # 获取响应的cookie print(response.headers.getlist('Set-Cookie')) # 获取cookiejar对应的值 1 print(response.meta['cookiejar']) # cookies 为自定义cookie值 meta = &#123;'cookiejar' 为自动管理的cookie yield Request(url='http://temp.wuxingxiangsheng.com/test/request?salt=%s' % salt, cookies=&#123;'test':'test'&#125;, meta = &#123;'cookiejar':response.meta['cookiejar']&#125;, callback=self.next) def next(self, response): # 获取请求携带的cookie， 自定义的加自动管理的 cookie = response.request.headers.getlist('Cookie') print('请求时携带请求的Cookies：', cookie) print(response.body) 如果cookie不能使用，请查看配置1COOKIES_ENABLED = True 其他debug 模式启动 || 多爬虫启动创建文件 cankao3.py, 内容如下1234567891011121314151617181920212223242526272829from cankao.spiders.cankao1 import Cankao1Spiderfrom scrapy.utils.project import get_project_settingsfrom scrapy.crawler import CrawlerProcess'''启动爬虫, 可以通过debug模式启动，进行源码分析'''def my_run1(): ''' 启动单个爬虫，这里可以定制爬虫的配置 :return: ''' process = CrawlerProcess(get_project_settings()) process.crawl(Cankao1Spider) process.start()def my_run2(): ''' 启动多个爬虫，这里可以给每个爬虫定制配置 :return: ''' process = CrawlerProcess(get_project_settings()) process.crawl(Cankao1Spider) process.crawl(Cankao1Spider) process.start()if __name__ == '__main__': my_run1() 分析xpath是否正确 win系统无法使用,mac正常 12345671. 执行scrapy shell 'www.bunao.win' # 执行要分析页面地址 2. 获得返回数据后，执行 response.xpath('//a') # response对象就是上一步返回的对象，执行自己的xpath表达式，查看结果是否正确 也可以通过 view(response) # 将请求返回的网页再浏览器打开，再浏览器里测试xpath表达式 获取配置获取项目配置信息，如果没设置返回的是默认的配置信息 1234获取USER_AGENT配置信息，具体的配置字段查看setting文件F:\python\cankao&gt;scrapy settings --get USER_AGENTMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36 项目地址 github]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫-xpath]]></title>
    <url>%2F2018%2F10%2F23%2Fspider%2Fxpath%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[语法百度吧看过之后可以通过后面的 应用 部分理解一下 获得 xpath 路径通过chrome浏览器可以右键来查看 应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/usr/bin/env python# -*- coding:utf-8 -*-from scrapy.selector import Selectorfrom scrapy.http import HtmlResponsehtml = """&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class="item-"&gt;&lt;a id='i1' href="link.html" class='ding'&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a id='i2' href="llink.html" class='ding'&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="llink2.html"&gt;second item&lt;span&gt;vv&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;a href="llink2.html"&gt;second item&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href="llink2.html"&gt;10&lt;/a&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;"""# 构造response对象response = HtmlResponse(url='', body=html, encoding='utf-8')selector = Selector(response=response)# 获取所有a标签temp = selector.xpath('//a')# 获取第一个body标签并从body标签开始找ul标签 ./ul 相对标签的子标签temp = selector.xpath('body')[0].xpath('.//ul')print(temp)exit()# 获取body的子标签ultemp = selector.xpath('body/ul')# 获取body的后代标签litemp = selector.xpath('body//li')# []空，li不是body的子标签temp = selector.xpath('body/li')# 获取body的父标签temp = selector.xpath('body')[0].xpath('..')# 获取包含class属性的标签temp = selector.xpath('//@class')# 获取属性class=item-0的标签temp = selector.xpath('//@class=item-0')# 获取body的后代第一个li标签temp = selector.xpath('body//li[1]')# 获取body的后代最后一个li标签temp = selector.xpath('body//li[last()]')# 获取body的后代倒数第二个li标签temp = selector.xpath('body//li[last()-1]')# 获取body的后代前两个li标签temp = selector.xpath('body//li[position() &lt; 3]')# 拥有id属性的a标签temp = selector.xpath('body//a[@id]')# 标签a id属性为i1temp = selector.xpath('body//a[@id=i1]')# 标签div下a标签值为 second item 的div标签temp = selector.xpath('body//div[a="second item"]')# 标签div下a标签值小于30的div标签temp = selector.xpath('body//div[a &lt; 30]')# 匹配任何节点temp = selector.xpath('//*')# 匹配当前节点任何子节点temp = selector.xpath('*')# 匹配当前节点任何子节点包含属性的节点temp = selector.xpath('@*')# 匹配任何包含了属性的节点temp = selector.xpath('//@*')# 获取body子元素中的ul标签temp = selector.xpath('body/child::ul')# 获取body标签的父标签temp = selector.xpath('body/parent::*')# 获取body标签的祖先标签temp = selector.xpath('body/ancestor::*')# 获取body标签的祖先标签包含自己temp = selector.xpath('body/ancestor-or-self::*')# 获取body标签的后代标签temp = selector.xpath('body/descendant::*')# 获取body标签的后代标签为a的a标签temp = selector.xpath('body/descendant::a')# 获取body标签的后代标签包含自己temp = selector.xpath('body/descendant-or-self::*')# 获取body标签的同级标签temp = selector.xpath('body/preceding-sibling::*')# 获取class为item-0的li标签的下一个同级标签temp = selector.xpath('//li[@class="item-0"]/following-sibling::*')# 获取class为item-0的li标签后面的所有标签temp = selector.xpath('//li[@class="item-0"]/following::*')# 获取class为item-0的li标签前面的所有标签temp = selector.xpath('//li[@class="item-0"]/preceding::*')# 获取所有li节点的所有属性temp = selector.xpath('//li/attribute::*')# 获取属性class为ding并且属性href为llink.html的a标签temp = selector.xpath('//a[@class="ding"][@href="llink.html"]')# 获取属性href包含link的a标签temp = selector.xpath('//a[contains(@href, "link")]')# 获取属性href以llin开头的a标签temp = selector.xpath('//a[starts-with(@href, "llin")]')# 正则匹配 id属性符合正则的a标签temp = selector.xpath('//a[re:test(@id, "i\d+")]')# 正则匹配 id属性符合正则的a标签 获取标签内容，并转换成正常的列表temp = selector.xpath('//a[re:test(@id, "i\d+")]/text()').extract()# 正则匹配 id属性符合正则的a标签 获取标签href属性值，并转换成正常的列表temp = selector.xpath('//a[re:test(@id, "i\d+")]/@href').extract()# 正则匹配 id属性符合正则的a标签 获取标签href属性值，获取第一个值temp = selector.xpath('//a[re:test(@id, "i\d+")]/@href').extract_first()print(temp)]]></content>
      <categories>
        <category>python</category>
        <category>xpath</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
        <tag>爬虫</tag>
        <tag>xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-轻松实现RESTful风格的接口]]></title>
    <url>%2F2018%2F10%2F16%2Fyii%2FRESTful%2F</url>
    <content type="text"><![CDATA[Yii轻松实现RESTful风格的接口创建api模块我们可以直接复制一份其他的模块，如 frontend 模块，假设起名为 restful 修改配置首先我们修改一下配置，为了能够实现模块的自动加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849common\config\bootstrap.php// 添加的模块要在这里设置一下别名,为了自动加载Yii::setAlias('@restful', dirname(dirname(__DIR__)) . '/restful');``` 然后修改 restful 模块的配置 ```phprestful/config/main.php......return [ # 更改项目id 'id' =&gt; 'app-restful', # 设置控制器命名空间 'controllerNamespace' =&gt; 'restful\controllers', 'components' =&gt; [ 'request' =&gt; [ 'csrfParam' =&gt; '_csrf-restful', # 配置获取请求参数的格式，可以接收并解析json格式的数据 'parsers' =&gt; [ 'application/json' =&gt; 'yii\web\JsonParser', ] ], 'user' =&gt; [ 'identityClass' =&gt; 'common\models\User', // 不允许使用session 'enableSession' =&gt; false, ], ... ... 'urlManager' =&gt; [ 'enablePrettyUrl' =&gt; true, // 最好开启，如果如开启，在不满足配置的路由规则后或使用默认的路由规则进行解析 // 'enableStrictParsing' =&gt; true, 'showScriptName' =&gt; false, 'rules' =&gt; [ /** * 配置url解析规则类 * controller 配置的控制器id 配置的控制器访问的时候要用复数的形式 */ ['class' =&gt; 'yii\rest\UrlRule', 'controller' =&gt; ['user']], ], ], ],]; 创建控制器创建控制器就更简单了12345678910111213141516171819202122namespace restful\controllers;use Yii;use yii\rest\ActiveController;class UserController extends ActiveController&#123; // 对应的模型类 public $modelClass = 'common\models\User';&#125;``` 此时，一个简单的RESTful风格的接口已经创建好了，我们肯定不能止步于此，下面我们具体分析一下 ## 解析&amp;&amp;实战操作 ### 配置 先看配置的 `Request` 组件，为了能够解析请求体数据为json格式 ```php'request' =&gt; [ 'parsers' =&gt; [ 'application/json' =&gt; 'yii\web\JsonParser', ]] info： 上述配置是可选的。若未按上述配置，API 将仅可以分辨 application/x-www-form-urlencoded 和 multipart/form-data 输入格式。 我们可以看一下 Request 类的 getBodyParams 方法，方法中会根据请求的 Content-Type 来用不同的解析器解析请求参数，这里配置的 &#39;application/json&#39; =&gt; &#39;yii\web\JsonParser&#39; 就是为了能够在请求头参数为 Content-Type:application/json 时请求体的json数据能够很好的被解析 路由配置常用的参数如下12345678910111213141516171819202122232425262728293031323334353637383940'urlManager' =&gt; [ 'enablePrettyUrl' =&gt; true, // 最好开启，如果不走rest的路由规则不满足就不用使用默认的了 // 'enableStrictParsing' =&gt; true, 'showScriptName' =&gt; false, // 配置url解析规则类 'rules' =&gt; [ /** * controller 配置的控制器id 配置的控制器访问的时候要用复数的形式 * 如：GET users */ ['class' =&gt; 'yii\rest\UrlRule', 'controller' =&gt; ['user']], /** * 配置控制器ID 的映射。 * 访问格式如：GET u */ // ['class' =&gt; 'yii\rest\UrlRule', 'controller' =&gt; ['u' =&gt; 'user']], /** * 其他常用的配置。 * */ [ 'class' =&gt; 'yii\rest\UrlRule', 'controller' =&gt; 'product', // 用来禁止复数形式 // 'pluralize' =&gt; false, // 只有delete允许请求，如果请求，将会返回404 // 'only' =&gt; ['delete'], // 排除对index的请求，其他的都可以，如果请求，将会返回请求options的结果 // 'except' =&gt; ['index'], // 排除对delete的请求，其他的都可以，如果请求，将会返回请求options的结果 'except' =&gt; ['delete'], // 配置额外自定义的访问 // 访问格式如 POST /products/search 可以支持新行为 search 'extraPatterns' =&gt; [ 'POST search' =&gt; 'search', ], ], ],] 其他的配置等详解Yii路由的文章的时候看一下就可以了 资源设置可以根据url上设置参数来获取指定的字段值, 看一下官方案例1234567891011// 返回fields()方法中申明的所有字段，默认是所有字段http://localhost/users// 只返回fields()方法中申明的id和email字段http://localhost/users?fields=id,email// 返回fields()方法申明的所有字段，以及extraFields()方法中的profile字段http://localhost/users?expand=profile// 返回回fields()和extraFields()方法中提供的id, email 和 profile字段http://localhost/users?fields=id,email&amp;expand=profile fields() 方法默认返回的是表解析出来的所有字段extraFields() 方法需要自己写，返回的是关联的属性 覆盖 fields() 方法官方案例123456789101112131415161718192021222324252627// 明确列出每个字段，适用于你希望数据表或// 模型属性修改时不导致你的字段修改（保持后端API兼容性）public function fields()&#123; return [ // 字段名和属性名相同 'id', // 字段名为"email", 对应的属性名为"email_address" 'email' =&gt; 'email_address', // 字段名为"name", 值由一个PHP回调函数定义 'name' =&gt; function ($model) &#123; return $model-&gt;first_name . ' ' . $model-&gt;last_name; &#125;, ];&#125;// 过滤掉一些字段，适用于你希望继承// 父类实现同时你想屏蔽掉一些敏感字段public function fields()&#123; $fields = parent::fields(); // 删除一些包含敏感信息的字段 unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']); return $fields;&#125; 覆盖 extraFields() 方法要想返回关联属性，需要让 extraFields() 方法返回关联属性，如下123456789101112131415161718restful\models\ProductModel/** * 返回需要关联的属性 也就是getUser的缩写 * @return [type] [description] */public function extraFields()&#123; return ['user'];&#125;/** * 关联 * @return [type] [description] */public function getUser()&#123; return $this-&gt;hasOne(User::className(), [ 'id' =&gt; 'order']);&#125; 请求 ：GET rest.yiilearn.com/products?fields=product_id,purchase_id&amp;expand=user123456789101112131415161718192021222324[ &#123; "product_id": "2605", "purchase_id": "1", "user": &#123; "id": 1, "username": "ibunao", "auth_key": "Ah5hD1y-TD0B3VUjoYufZhYoP1ayPTvP", "password_hash": "$2y$13$hgTMEkDth8QSY4DJoK30hu8Z282YhOR8pdGlXjIeVYORP3OkeODpi", "password_reset_token": "mfpKVvJ_QbX2fL0PI7Pyqtb-yqP0D0GZ_1539051580", "email": "******@qq.com", "status": 10, "created_at": 1539050271, "updated_at": 1539585374, "allowance": "0", "allowance_updated_at": "1539585374" &#125; &#125;, &#123; "product_id": "2606", "purchase_id": "1", "user": null &#125;] 可以看到，expand的参数生效了，但是返回的数据有太多，我们缩减一下1234567common\models\User# 添加fields方法 public function fields()&#123; return ['id', 'username'];&#125; 返回结果123456789101112131415[ &#123; "product_id": "2605", "purchase_id": "1", "user": &#123; "id": 1, "username": "ibunao" &#125; &#125;, &#123; "product_id": "2606", "purchase_id": "1", "user": null &#125;] AR这种联表方式还是有点复杂的，不推荐。可以直接查返回数据 控制器设置控制器需要改变的比较少，无非就是添加一些路由配置的额外的要实现的 action，覆盖一些 behavior ，重写一下检查权限的方法 checkAccess()先看案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace restful\controllers;use Yii;use yii\rest\ActiveController;use yii\data\ActiveDataProvider;use restful\models\ProductModel;# 可以同时实现下面三种验证方法use yii\filters\auth\CompositeAuth;# 浏览器弹窗口输入获取tokenuse yii\filters\auth\HttpBasicAuth;# 从head头获取验证的tokenuse yii\filters\auth\HttpBearerAuth;# 从请求链接中获取验证的tokenuse yii\filters\auth\QueryParamAuth;class ProductController extends ActiveController&#123; public $modelClass = 'restful\models\ProductModel'; /** * 覆盖behaviors方法 * @return [type] [description] */ public function behaviors() &#123; $behaviors = parent::behaviors(); // 重写验证过滤器的配置 $behaviors['authenticator'] = [ 'class' =&gt; HttpBearerAuth::className(), // 可以不验证的action 'optional' =&gt; ['index'] ]; return $behaviors; &#125; /** * 添加额外配置的action * @return [type] [description] */ public function actionSearch() &#123; return Yii::$app-&gt;request-&gt;post(); &#125; /** * 检查用户访问权限，可以参考rbac * @param [type] $action actionId * @param [type] $model 模型对象 * @param array $params * @return [type] [description] */ public function checkAccess($action, $model = null, $params = []) &#123; if ($action === 'update' || $action === 'delete') &#123; if ($model-&gt;order !== Yii::$app-&gt;user-&gt;id) // 不满足抛出异常 throw new \yii\web\ForbiddenHttpException(sprintf('You can only %s articles that you\'ve created.', $action)); &#125; &#125;&#125; 下面我们主要看一下 behaviors 部分1234567891011121314151617181920212223242526272829yii\rest\Controller 已经给我们配置好了四个public function behaviors()&#123; return [ // 根据请求设置响应格式和语言 'contentNegotiator' =&gt; [ 'class' =&gt; ContentNegotiator::className(), 'formats' =&gt; [ // 这个顺序很重要，如果请求没有设置 Accept:application/json||xml 谁第一个用谁 'application/json' =&gt; Response::FORMAT_JSON, 'application/xml' =&gt; Response::FORMAT_XML, ], ], // 过滤action允许的请求方法 'verbFilter' =&gt; [ 'class' =&gt; VerbFilter::className(), 'actions' =&gt; $this-&gt;verbs(), ], // 验证的 'authenticator' =&gt; [ 'class' =&gt; CompositeAuth::className(), ], // 限制速率的 'rateLimiter' =&gt; [ 'class' =&gt; RateLimiter::className(), ], ];&#125; 格式化响应这部分已经是写好的了，我们只需要在请求头中加入指定响应格式的参数即可1234# 接收json格式的数据Accept: application/json;# 接收xml格式的数据Accept: application/json; 验证yii提供了多种验证方法，这里以 HttpBearerAuth 验证(head头获取token)为例123456789101112实现验证token的方法(通过token获取到对应的用户)common\models\User/** * api通过token登陆 * &#123;@inheritdoc&#125; */public static function findIdentityByAccessToken($token, $type = null)&#123; # 为了方便测试直接用的是已经有的 auth_key return static::findOne(['auth_key' =&gt; $token, 'status' =&gt; self::STATUS_ACTIVE]);&#125; 此时，我们就可以通过获取到的 token 进行请求了123GET rest.yiilearn.com/products 请求头 "Authorization":"Bearer Ah5hD1y-TD0B3VUjoYufZhYoP1ayPTvP" 固定格式 &quot;Authorization&quot;:&quot;Bearer &quot; + $token 速率验证在实现了用户验证后速率验证才会有用，我们需要 User 实现几个方法，如下首先我们需要在 user 表添加两个字段用来存储剩余次数和访问时间 allowance, allowance_updated_at12345678910111213141516171819202122232425262728293031323334353637383940common\models\User实现接口class User extends ActiveRecord implements IdentityInterface,RateLimitInterface实现下面几个方法 /** * 返回一段时间内允许请求的最大次数 * @param [type] $request [description] * @param [type] $action [description] * @return [type] [description] */public function getRateLimit($request, $action)&#123; // 每五秒可以访问2次 return [2, 5];&#125;/** * 获取允许请求的数量和最后的访问的时间戳 * @param [type] $request [description] * @param [type] $action [description] * @return [type] [description] */public function loadAllowance($request, $action)&#123; return [$this-&gt;allowance, $this-&gt;allowance_updated_at];&#125;/** * 保存剩余的请求数量和最后的访问时间 * @param [type] $request [description] * @param [type] $action [description] * @param [type] $allowance [description] * @param [type] $timestamp [description] * @return [type] [description] */public function saveAllowance($request, $action, $allowance, $timestamp)&#123; $this-&gt;allowance = $allowance; $this-&gt;allowance_updated_at = $timestamp; $this-&gt;save();&#125; 实现起来就是这么简单 版本化 &amp;&amp; 错误处理比较简单，直接看官方文档 版本化 错误处理]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现迭代器]]></title>
    <url>%2F2018%2F10%2F11%2Fphp%2F%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator%2F</url>
    <content type="text"><![CDATA[前言迭代器接口可以让对象像数组一样被遍历，如 foreach ，和数组的区别是数组一开始数据就是填充好的，也就是已经加载到内存的，如果数据量比较大甚至超过服务器内存，那将无法工作，而迭代器就可以通过一条一条数据的读取(从文件或数据库)进行操作 Iterator接口php提供的接口，我们看一下要实现的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Iterator extends Traversable &#123; //重置索引游标 abstract public void rewind ( void ) //移动当前索引游标到下一元素 abstract public void next ( void ) //判断当前索引游标指向的元素是否有效 abstract public boolean valid ( void ) //返回当前索引游标指向的元素 abstract public mixed current ( void ) //返回当前索引游标指向的键 abstract public scalar key ( void ) &#125; ``` ## 实现一个简单的迭代器 ```phpclass myIterator implements Iterator &#123; // 记录数组的位置 private $position = 0; // 要遍历的数组 private $array = array( "firstelement", "secondelement", "lastelement", ); // foreach开始时执行一次，重置索引 function rewind() &#123; var_dump(__METHOD__); $this-&gt;position = 0; &#125; // 返回下一个索引 function next() &#123; var_dump(__METHOD__); ++$this-&gt;position; &#125; // 判断当前索引对应的值是否有效，返回false将会终止遍历 function valid() &#123; var_dump(__METHOD__); return isset($this-&gt;array[$this-&gt;position]); &#125; // 每次循环获取当前索引对应的值 function current() &#123; var_dump(__METHOD__); return $this-&gt;array[$this-&gt;position]; &#125; // 返回当前的索引 function key() &#123; var_dump(__METHOD__); return $this-&gt;position; &#125;&#125;$it = new myIterator;foreach($it as $key =&gt; $value) &#123; var_dump($key, $value); echo "\n";&#125; PHP文档]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-AFC验证]]></title>
    <url>%2F2018%2F10%2F11%2Fyii%2FAFC%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[实例1234567891011121314151617181920212223242526272829use yii\web\Controller;use yii\filters\AccessControl;class SiteController extends Controller&#123; public function behaviors() &#123; return [ 'access' =&gt; [ 'class' =&gt; AccessControl::className(), 'only' =&gt; ['login', 'logout', 'signup'], 'except' =&gt; ['login'], 'rules' =&gt; [ [ 'allow' =&gt; true, 'actions' =&gt; ['login', 'signup'], 'roles' =&gt; ['?'], ], [ 'allow' =&gt; true, 'actions' =&gt; ['logout'], 'roles' =&gt; ['@'], ], ], ], ]; &#125; // ...&#125; 验证流程AccessControl过滤器 注意，如果AccessControll配置的需要验证的action，在配置的rules中如果验证没有通过或者没有rule来验证当前请求的action(也就是不符合所有rule需要验证的action)都会拒绝访问 only 和 except 配置only 表示需要验证的 actionId ,如果为空，这个控制器的所有action都将会向下进行验证逻辑 except 表示过滤掉的 actionId 这些action将不会走校验， except 的优先级更高，如果同时属于 only 和 except 那么这个action将不会走验证 denyCallback 配置这个是配置一个匿名函数，一般也不用配置，在 rule 被拒绝的时候如果 rule 没有配置 denyCallback 将会执行这个，通常用来抛出异常的，可以参考 yii的兜底方法 denyAccess AccessRule 验证规则配置1234567891011121314# 必填，如果为false表示不管通过不通过验证，都为false拒绝 'allow' =&gt; true,# 选填，判断当前action是否属于验证的范围，如果为空，表示所有action都要验证 'actions' =&gt; ['login', 'signup'],# 选填，判断当前controller是否属于验证的范围，如果为空，表示所有controller都要验证 'controllers' =&gt; ['site'],# 选填，判断当前 ip 是否属于验证的范围，如果为空，表示所有 ip 都要验证 'ips' =&gt; ['192.168.*'],# 选填，判断当前 请求方式 是否属于验证的范围，如果为空，表示所有 请求方式 都要验证'verbs' =&gt; ['post'], # 选填，添加额外的自定义验证方法，如果不设置role参数，也就意味着只验证此方法 'matchCallback' =&gt; function ($rule, $action)&#123;&#125;, # 选填，一般也不用配置，当验证失败时执行 'denyCallback' =&gt; function ($rule, $action)&#123;&#125;, 最后两个参数也是验证的关键1234567role =&gt; ['@', '?', 'otherRole']? : 表示允许未登录的访问 @ : 表示未登录才能访问otherRole : 其他的都是对应的权限/角色 详见RBAC roleParams =&gt; function($rule)&#123;&#125; || String || Array # （算出来的）值将会作为权限的参数]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>AFC验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-RBAC]]></title>
    <url>%2F2018%2F10%2F11%2Fyii%2FRBAC%2F</url>
    <content type="text"><![CDATA[说明可以先参看 中文官方文档yii 为我们提供的两种存储方式一种是文件方式一种是数据库方式，这里我们直接使用数据库的方式，yii 文档给的是直接写代码执行的方式，这种虽然更灵活，但是不够直观，而且最常用到的地方就是后台，所以我们使用可视化的模块 yii-admin yii-admin 扩展过的rbac 和 yii 自带的有一点区别的是权限，yii以权限为基础，而 yii-admin 是以路由为基础的，这一点会在验证的时候进行体现, yii的是Yii::$app-&gt;user-&gt;can(role||permission, params) ，而 yii-admin 的是 Yii::$app-&gt;user-&gt;can(route, params) 准备首先安装 yii-admin 扩展，github地址 创建表两条命令，首先创建yii自带的rbac相关表1yii migrate --migrationPath=@yii/rbac/migrations 将会创建四张表itemTable： 该表存放授权条目（译者注：即角色和权限）。默认表名为 “auth_item” 。itemChildTable： 该表存放授权条目的层次关系。默认表名为 “auth_item_child”。assignmentTable： 该表存放授权条目对用户的指派情况。默认表名为 “auth_assignment”。ruleTable： 该表存放规则。默认表名为 “auth_rule”。 执行yii-admin带的menu表1yii migrate --migrationPath=@mdm/admin/migrations 将会得到一个menu表 配置123456789101112131415161718192021222324252627// 配置成中文，配置这个后将会根据国际化功能把英文映射成对应的中文 'language' =&gt; 'zh-CN', // 配置模块'modules' =&gt; [ 'admin' =&gt; [ 'class' =&gt; 'mdm\admin\Module', 'layout' =&gt; 'left-menu', // yii2-admin的导航菜单 ] ...],// 配置权限'components' =&gt; [ ... 'authManager' =&gt; [ 'class' =&gt; 'yii\rbac\DbManager', // or use 'yii\rbac\PhpManager' ]],// 为app注册行为 这个是检验用户是否有权限进行访问的'as access' =&gt; [ 'class' =&gt; 'mdm\admin\components\AccessControl', # 配置不检查权限的路由 'allowActions' =&gt; [ 'site/*', 'admin/*', //允许所有人访问admin节点及其子节点 ]], 应用先感受一下配置好后进入admin模块的样子 路由 Route路由相当于一个资源,最小单位使用很简单， 1、2 通过 3 添加到 5 ，其中 1 是自己输入路由（以 / 开头），2 为自动检测出来的路由， 5 为添加到数据库的路由资源， 4 为移除 5 的操作添加的路由会添加到 auth_item 表 ，如下 权限 permission一个权限可以包含多个路由，和一个规则rule 添加权限先创建一个权限 对应表的变化 然后增加路由 对应表的变化 角色 role一个角色可以包含多个权限，多个路由和一个规则rule 添加角色先创建一个角色 对应表的变化 然后增加权限或者路由 对应表的变化 分配角色权限一个用户可以包含多个角色和权限，不能增加路由和规则rule了首先我们会看到用户列表 进行权限分配 对应表的变化 测试结果 规则 rule规则是对权限的补充，算是细分的权限，一般权限是对应这路由的，而规则可以更细一点，比方说一个角色没有更新文章的权限，但是他需要更新自己文章的权限，这时就需要给他赋值更新文章的权限，但是这样他权限就太大了，因为还可以更新别人的文章，这时就需要给他增加一个rule，来验证这篇文章是否属于自己，如果不属于自己则依旧没权限 我们以官网使用rule为例子 这里 来用 yii-admin 的方式实现 首先创建 rule 类, 如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace backend\rbac;use yii\rbac\Rule;/** * 创建规则，相对于路由(权限)的权限更加细分 * 如果该用户满足某个路由(权限)，但是不满足规则依旧不可以访问 */class AuthorRule extends Rule&#123; // 规则名 public $name = 'isAuthor'; /** * @param string|integer $user 用户 ID. * @param Item $item 该规则相关的角色或者权限 * @param array $params get参数 * @return boolean 代表该规则相关的角色或者权限是否被允许 */ public function execute($user, $item, $params) &#123; /** * 请求 和参数值 route:http://admin.yiilearn.com/test/index3?id=10&#123; "user": 2, "item": &#123; "type": "2", "name": "updateOwnPost", "description": "更新自己的", "ruleName": "isAuthor", "data": &#123; "abc": "cba" &#125;, "createdAt": "1539229574", "updatedAt": "1539229574" &#125;, "params": &#123; "id": "10" &#125;&#125; */ // echo json_encode(['user' =&gt; $user, 'item' =&gt; $item, 'params' =&gt; $params]);exit; // 直接返回false表示拒绝，具体的实现可以通过参数进行逻辑判断 return false; &#125;&#125; 我们现在已经有 ibunao 用户了，角色(role1)、权限、路由如下 现在我们添加用户 jidan 用户，为了让其访问 /test/index3 添加rule 对应表的变化 增加权限绑定rule 对应表的变化 然后就是创建角色 role2, 并绑定用户 jidan Rule类进行检验我们可以直接在 execute() 方法中返回 true 或 false , 请求 http://admin.yiilearn.com/test/index3?id=10 会发现分别是可以访问和拒绝访问，表示我们设置的rule已经生效了我们可以根据传过来的参数来进行自己的逻辑判断，来进行拒绝和通过12345678910111213141516171819请求:http://admin.yiilearn.com/test/index3?id=10 execute 方法接收到的参数&#123; "user": 2, # 用户id "item": &#123; # 权限信息 "type": "2", "name": "updateOwnPost", "description": "更新自己的", "ruleName": "isAuthor", "data": &#123; "abc": "cba" &#125;, "createdAt": "1539229574", "updatedAt": "1539229574" &#125;, "params": &#123; # 请求参数 "id": "10" &#125;&#125; 使用yii的验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481. 配置文件 config/main.php 注释掉 使用 yii-admin 验证的部分或者允许test/index3进行访问 // 'as access' =&gt; [// 'class' =&gt; 'mdm\admin\components\AccessControl',// 'allowActions' =&gt; [// 'site/*',//允许访问的节点，可自行添加// 'admin/*',//允许所有人访问admin节点及其子节点// //'test/index3'// ]// ],2. 在使用的类加过滤器 在 TestController 控制器添加验证，这个忘记的可以参看 AFC验证 部分 public function behaviors()&#123; return [ 'access' =&gt; [ 'class' =&gt; AccessControl::className(), 'rules' =&gt; [ [ 'actions' =&gt; ['index3'], 'allow' =&gt; true, 'roles' =&gt; ['/test/index3'], 'roleParams' =&gt; ['a', 'b', 'c'], ], ], ], ];&#125;这是 execute 方法接收的参数为 &#123; "user": 2, # 用户id "item": &#123; # 权限详情 "type": "2", "name": "updateOwnPost", "description": "更新自己的", "ruleName": "isAuthor", "data": &#123; "abc": "cba" &#125;, "createdAt": "1539229574", "updatedAt": "1539229574" &#125;, "params": [ # roleParams 配置的参数 "a", "b", "c" ]&#125; 用户列表yii-admin 为后台也提供了一系列的用户操作功能（注册、改密码等），但是默认是没有显示的，需要自己根据自己的需要添加按钮 如果你的没有显示上面红框的内容可以参考我的代码123456789101112131415161718192021222324找到action对应的视图 ... ... # 增加的创建用户按钮 &lt;p&gt; &lt;?= Html::a(Yii::t('rbac-admin', 'Create User'), ['signup'], ['class' =&gt; 'btn btn-success']) ?&gt; &lt;/p&gt; ... ... &lt;?= GridView::widget([ ... ... [ 'class' =&gt; 'yii\grid\ActionColumn', // 这个原始的有问题，直接上下面那行 // 'template' =&gt; Helper::filterActionColumn(['view', 'activate', 'delete']), 'template' =&gt; '&#123;view&#125; &#123;activate&#125; &#123;delete&#125;', 'buttons' =&gt; [ ... ...&lt;/div&gt; 目录 menuyii-admin 增加了目录功能，可以设置目录，然后根据用户的权限来显示目录 增加目录，数据的作用会在后面说 增加子目录，注意排序 增加子目录，注意排序 对应表的变化 目录显示 目录显示的代码123456789101112131415161718192021222324252627282930313233views\layout\main.php......&lt;!-- 增加yii-admin设置的目录 --&gt;&lt;?phpuse mdm\admin\components\MenuHelper;// 这个匿名函数可以根据设置menu时的数据，将英文转成中文$callback = function($menu)&#123; $data = $menu['data']; return [ // 显示改成设置的数据 'label' =&gt; $data ? $data : $menu['name'], 'url' =&gt; [$menu['route']], 'items' =&gt; $menu['children'] ];&#125;;// 获取用户权限能看到的菜单，这个是关键$items = MenuHelper::getAssignedMenu(Yii::$app-&gt;user-&gt;id, null, $callback); ?&gt;...... // 合并权限目录 $menuItems = array_merge($items, $menuItems); echo Nav::widget([ 'options' =&gt; ['class' =&gt; 'navbar-nav navbar-right'], 'items' =&gt; $menuItems, ]); NavBar::end(); ?&gt;...... 也可以参考以下不错的文章北哥这篇文讲解yii2权限扩展（yii2-admin） - 上部 北哥这篇文讲解yii2权限扩展（yii2-admin） - 中部北哥这篇文讲解yii2权限扩展（yii2-admin） - 下部Yii2项目后台整合yii2-admin模块Yii2基于角色的权限控制（RBAC）]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>RBAC</tag>
        <tag>yii-admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php设计模式简单解析]]></title>
    <url>%2F2018%2F10%2F11%2Fphp%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰器模式 扩展类的原有方法，不需要继承重写，在方法的开始和结尾增加预处理方法 前言装饰器的思想就是方便对一个方法进行扩展，就和web框架中提供的 beforeAction 和 afterAction 一样 装饰模式,可以动态的添加修改类的功能 一个类提供了一项功能,如果要在修改并添加额外的功能,传统的编程模式,需要写一个之类继承它,并重新实现类的方法 使用装饰模式,仅需在运行时添加一个装饰对象即可实现,可以实现最大的灵活性 实现(例子) 定义一个装饰器接口，定义要实现的方法 创建一个对象实现装饰器的接口 在指定类中使用装饰器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//定义装饰器接口 interface DrawDecorator&#123; function beforeDraw(); function afterDraw();&#125;//创建装饰器，实现装饰器接口 class ColorDrawDecorator implements DrawDecorator&#123; protected $color; function __construct($color = 'red') &#123; $this-&gt;color = $color; &#125; function beforeDraw() &#123; echo "&lt;div style='color: &#123;$this-&gt;color&#125;;'&gt;"; &#125; function afterDraw() &#123; echo "&lt;/div&gt;"; &#125;&#125;//使用装饰器class Canvas&#123; protected $decorators = array(); //添加装饰器 function addDecorator(DrawDecorator $decorator) &#123; $this-&gt;decorators[] = $decorator; &#125; //调用方法之前先调用装饰器的方法 function beforeDraw() &#123; foreach($this-&gt;decorators as $decorator) &#123; $decorator-&gt;beforeDraw(); &#125; &#125; // 调用方法之后调用装饰器的方法 function afterDraw() &#123; // 倒序一下数组，保持好顺序 $decorators = array_reverse($this-&gt;decorators); foreach($decorators as $decorator) &#123; $decorator-&gt;afterDraw(); &#125; &#125; //此方法使用装饰器的方法 function draw() &#123; // 执行自己代码之前调用 $this-&gt;beforeDraw(); foreach($this-&gt;data as $line) &#123; foreach($line as $char) &#123; echo $char; &#125; echo "&lt;br /&gt;\n"; &#125; // 执行自己代码之后调用 $this-&gt;afterDraw(); &#125;&#125; 观察者模式解耦利器。就是一个事件机制，我(们)先告诉你我(们)关注这件事(注册)，如果这件事发生了改变(触发)，通知我，我再执行我的逻辑 前言 观察者模式(Observer)，当一个对象状态发生改变时，依赖他的对象全部会受到通知，并自动更新 场景：一个事件发生后，要执行一连串更新操作，传统的编程方式，就是在事件的代码之后直接加入处理逻辑当更新的逻辑增多之后，代码会变的难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码 观察者模式实现了低耦合，非侵入式的通知与更新机制 实现(例子)123456789101112131415161718192021222324252627282930313233343536373839404142434445//事件产生者 抽象类EventGenerator.phpabstract class EventGenerator&#123; private $obserers = array(); //为事件添加观察者 function addObsever(Observer $observer)&#123; $this-&gt;obserers[] = $observer; &#125; //通知观察者 调用观察者响应的方法 function ontify()&#123; foreach ($this-&gt;obserers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125;//事件event.phpclass Event extends EventGenerator&#123; function trigger()&#123; echo "Event &lt;br&gt;"; $this-&gt;ontify(); &#125;&#125;//观察者接口，定义要实现的被触发的方法 Observer.phpinterface Observer&#123; function update($event_info = null);&#125;//观察者1Observer1.phpclass Observer1 implements Observer&#123; function update($event_info = null)&#123; echo "逻辑1"; &#125;&#125;…………//使用index.php$event = new Event();$event-&gt;addObsever(new Observer1());$event-&gt;addObsever(new Observer2());$event-&gt;addObsever(new Observer3());$event-&gt;trigger(); 总结和yii框架提供的事件机制原理一样 适配器模式 多个相同功能目的的类，通过相同的方法来实现相同的功能目的 前言适配器就是为了解决兼容，或者说是为了统一接口。比较常见的是数据库的适配，因为不同的数据库提供的接口(如:增删改)是不太一样的(或者是对同样的数据库有不同的操作接口，如mysql、mysqli，pdo3)，这时候为了操作的方便，我们是需要用统一的方法对不同的数据库接口进行封装。还有比较常见的是对支付方式(微信、支付宝等)的封装。类似的场景还有cache缓存适配器，将memcache、redis、file等不同的缓存方式封装成相同的操作方法 实现(例子) 定义一个定义了约定要实现的方法的接口 不同的类实现这个接口，来各自完成自己的实现相应方法的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//定义接口interface IDatabase&#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125;//不同的数据库实现此接口 #mysqliclass MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125;#pdoclass PDO implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function close() &#123; unset($this-&gt;conn); &#125;&#125; 总结使对不同类型的操作变的相当方便，不用花费太多的时间来记录不同类型的不同方法。不需要关注太多细节，操作mysql和操作mongo的方法变的基本一致，方便。 策略模式前言策略模式定义了一族相同类型的算法，算法之间独立封装，并且可以互换代替。这些算法是同一类型问题的多种处理方式，他们具体行为有差别。每一个算法、或说每一种处理方式称为一个策略。在应用中，就可以根据环境的不同，选择不同的策略来处理问题。 实现(例子)实现和适配器模式相似： 定义一个定义了约定要实现的方法的接口 不同的策略类实现这个接口，来各自完成自己的实现相应方法的逻辑 以数组输出为例。数组的输出有序列化输出、JSON字符串输出和数组格式输出等方式。每种输出方式都可以独立封装起来，作为一个策略。应用时，如要把数组保存到数据库中，可以用序列化方式输出。要提供给APP作接口，可以用JSON字符串输出。其他程序调用，则直接输出数组格式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 策略接口 */interface OutputStrategy&#123; public function render($array);&#125;/** * 策略类1：返回序列化字符串 */class SerializeStrategy implements OutputStrategy&#123; public function render($array) &#123; return serialize($array); &#125;&#125;/** * 策略类2：返回JSON编码后的字符串 */class JsonStrategy implements OutputStrategy&#123; public function render($array) &#123; return json_encode($array); &#125;&#125;/** * 策略类3：直接返回数组 */class ArrayStrategy implements OutputStrategy&#123; public function render($array) &#123; return $array; &#125;&#125;/** * 环境角色类 */class Output&#123; private $outputStrategy; // 传入的参数必须是策略接口的子类或子类的实例 public function __construct(OutputStrategy $outputStrategy) &#123; $this-&gt;outputStrategy = $outputStrategy; &#125; public function renderOutput($array) &#123; return $this-&gt;outputStrategy-&gt;render($array); &#125;&#125;/** * 客户端代码 */$test = ['a', 'b', 'c'];// 需要返回数组$output = new Output(new ArrayStrategy());$data = $output-&gt;renderOutput($test);// 需要返回JSON$output = new Output(new JsonStrategy());$data = $output-&gt;renderOutput($test); 总结策略模式和适配器模式有什么不一样 注册树模式把创建的对象存放在一个对象中，将来访问的时候直接从这个对象中获取 前言创建一个注册器类，将创建的对象绑定到注册树上，之后可以在全局通过注册树类进行访问绑定过的对象其实可以实现单利模式的目的，即创建一次，全局使用； 实现(例子)1234567891011121314151617181920212223/*** 注册树类*/class Register&#123; protected static $objects; //通过别名的方式，将对象绑定到注册树上 static function set($alias, $object) &#123; self::$objects[$alias] = $object; &#125; //通过别名获取对象 static function get($alias) &#123; return self::$objects[$alias]; &#125; //销毁 static function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125; 参考歪麦博客(UML类图的使用，php设计模式)慕课网-php设计模式设计模式]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像访问数组一样访问对象]]></title>
    <url>%2F2018%2F10%2F11%2Fphp%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84-ArrayAccess%2F</url>
    <content type="text"><![CDATA[前言通过实现php提供的 ArrayAccess 接口，可以方便的实现像操作数组一样访问对象 ArrayAccess接口php提供的接口，我们看一下要实现的内容 1234567891011&lt;?phpArrayAccess &#123; // isset判断的时候自动调用 abstract public boolean offsetExists ( mixed $offset ) // 获取数组数据的时候自动调用 abstract public mixed offsetGet ( mixed $offset ) // 添加数据的时候自动调用 abstract public void offsetSet ( mixed $offset , mixed $value ) // unset的时候自动调用 abstract public void offsetUnset ( mixed $offset )&#125; 实现接口(例子)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * Created by PhpStorm. * User: wangHan * Date: 2016/10/21 * Time: 14:07 */class Human implements ArrayAccess&#123; private $elements; public function __construct() &#123; $this-&gt;elements = [ "boy" =&gt; "male", "girl" =&gt; "female" ]; &#125; /** * isset判断的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetExists($offset) &#123; // TODO: Implement offsetExists() method. return isset($this-&gt;elements[$offset]); &#125; /** * 获取值的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetGet($offset) &#123; // TODO: Implement offsetGet() method. return $this-&gt;elements[$offset]; &#125; /** * 存放值的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetSet($offset, $value) &#123; // TODO: Implement offsetSet() method. $this-&gt;elements[$offset] = $value; &#125; /** * unset的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetUnset($offset) &#123; // TODO: Implement offsetUnset() method. unset($this-&gt;elements[$offset]); &#125;&#125;$human = new Human();$human['people'] = "boyAndGirl"; // 自动调用offsetSetif(isset($human['people'])) &#123; // 自动调用offsetExists echo $human['boy'];// 自动调用offsetGet echo '&lt;br /&gt;'; unset($human['boy']);// 自动调用offsetUnset var_dump($human['boy']);&#125;// // 输出结果 male null 参考]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-安全组件]]></title>
    <url>%2F2018%2F10%2F09%2Fyii%2Fsecurity%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[加密&amp;解密 相关方法数据加密和解密encryptByPassword &amp; decryptByPassword通过key 对原数据进行加密，每次加密后的生成的数据是不一样的，但是都可以通过它来解密出原来的数据12345678910111213/** * 获取加密(编码)后的数据。 * 和 decryptByPassword 配对使用 * @param string $data the data to encrypt 要加密的数据 * @param string $password the password to use for encryption 加密使用的key * @return string the encrypted data * @see decryptByPassword() * @see encryptByKey() */public function encryptByPassword($data, $password)&#123; ...&#125; 通过上面加密的数据和key获得原数据123456789101112/** * 获取解密(解码)后的数据。 * 和 encryptByPassword 配对使用 * @param string $data the encrypted data to decrypt 加密后的数据 * @param string $password the password to use for decryption 加密时使用的key * @return bool|string the decrypted data or false on authentication failure * @see encryptByPassword() */public function decryptByPassword($data, $password)&#123; ...&#125; 注意，encryptByPassword进行加密后的数据不是ASCII，也就是在显示的时候会乱码，可以通过base64_encode和base64_decode在外层包装下 实例：12345678910111213public function actionIndex()&#123; echo $temp = Yii::$app-&gt;security-&gt;encryptByPassword("security","bunao"); echo "&lt;br/&gt;"; echo Yii::$app-&gt;security-&gt;decryptByPassword($temp,"bunao"); # security echo "&lt;br/&gt;"; // 进行base64编码，防止乱码 echo $temp = base64_encode(Yii::$app-&gt;security-&gt;encryptByPassword("security","bunao")); echo "&lt;br/&gt;"; echo Yii::$app-&gt;security-&gt;decryptByPassword(base64_decode($temp),"bunao"); security&#125; encryptByKey &amp; decryptByKey这一对和上面的 encryptByPassword &amp; decryptByPassword 基本一样，只是添加了一个参数对其进行了扩展，这样就可以通过一个常量和一个变量组成一个加密的key1234567891011121314151617181920212223242526/** * 获取加密(编码)后的数据。 * 和 decryptByKey 配对使用 * @param string $data the data to encrypt 要编码的数据 * @param string $inputKey the input to use for encryption and authentication 加密使用的key * @param string $info optional context and application specific information, see [[hkdf()]] 和第二个参数共同生成加密的key * @return string the encrypted data */public function encryptByKey($data, $inputKey, $info = null)&#123; ...&#125;/** * 获取解密(解码)后的数据 * 和encryptByKey 配对使用 * Verifies and decrypts data encrypted with [[encryptByKey()]]. * @param string $data the encrypted data to decrypt。加密后的数据 * @param string $inputKey the input to use for encryption and authentication 加密使用的key1 * @param string $info optional context and application specific information, see [[hkdf()]] 加密使用的key2 * @return bool|string the decrypted data or false on authentication failure */public function decryptByKey($data, $inputKey, $info = null)&#123; ...&#125; 注意，encryptByPassword进行加密后的数据不是ASCII，也就是在显示的时候会乱码，可以通过base64_encode和base64_decode在外层包装下实例：将用户id组合key1234567891011121314public function actionIndex()&#123; $userId = 30; echo $temp = Yii::$app-&gt;security-&gt;encryptByKey("security", "bunao", $userId); echo "&lt;br/&gt;"; echo Yii::$app-&gt;security-&gt;decryptByKey($temp, "bunao", $userId); echo "&lt;br/&gt;"; // 进行base64编码，防止乱码 echo $temp = base64_encode(Yii::$app-&gt;security-&gt;encryptByKey("security", "bunao", $userId)); echo "&lt;br/&gt;"; echo Yii::$app-&gt;security-&gt;decryptByKey(base64_decode($temp), "bunao", $userId);&#125; token 的生成和验证maskToken &amp; unmaskToken根据提供的字符串token，生成加密的token1234567891011121314151617/** * 生成token 提供一个源token可以生成一些列加密的token，可以通过生成的token逆转出来源token * csrf使用这个 * 和 unmaskToken 配对使用 * Masks a token to make it uncompressible. * Applies a random mask to the token and prepends the mask used to the result making the string always unique. * Used to mitigate BREACH attack by randomizing how token is outputted on each request. * @param string $token An unmasked token. * @return string A masked token. * @since 2.0.12 */public function maskToken($token)&#123; // The number of bytes in a mask is always equal to the number of bytes in a token. $mask = $this-&gt;generateRandomKey(StringHelper::byteLength($token)); return StringHelper::base64UrlEncode($mask . ($mask ^ $token));&#125; 对加密的token进行解密，获取原token，就可以判断token时候正确1234567891011121314151617/** * 解码 * Unmasks a token previously masked by `maskToken`. * @param string $maskedToken A masked token. 加密的token * @return string An unmasked token, or an empty string in case of token format is invalid. * @since 2.0.12 */public function unmaskToken($maskedToken)&#123; $decoded = StringHelper::base64UrlDecode($maskedToken); $length = StringHelper::byteLength($decoded) / 2; // Check if the masked token has an even length. if (!is_int($length)) &#123; return ''; &#125; return StringHelper::byteSubstr($decoded, $length, $length) ^ StringHelper::byteSubstr($decoded, 0, $length);&#125; 实例：csrf 实例Yii csrf获取csrftoken12345678910111213141516171819202122232425262728293031323334353637yii\web\Request/** * 获取csrftoken * 如果cookie或session中不存在则生成csrftoken * @param bool $regenerate whether to regenerate CSRF token. When this parameter is true, each time 是否重新生成令牌 * this method is called, a new CSRF token will be generated and persisted (in session or cookie). * @return string the token used to perform CSRF validation. */public function getCsrfToken($regenerate = false)&#123; if ($this-&gt;_csrfToken === null || $regenerate) &#123; if ($regenerate || ($token = $this-&gt;loadCsrfToken()) === null) &#123; $token = $this-&gt;generateCsrfToken(); &#125; $this-&gt;_csrfToken = Yii::$app-&gt;security-&gt;maskToken($token); &#125; return $this-&gt;_csrfToken;&#125;/** * 生成csrftoken * Generates an unmasked random token used to perform CSRF validation. * @return string the random token for CSRF validation. */protected function generateCsrfToken()&#123; $token = Yii::$app-&gt;getSecurity()-&gt;generateRandomKey(); if ($this-&gt;enableCsrfCookie) &#123; $cookie = $this-&gt;createCsrfCookie($token); // 添加到cookie中 Yii::$app-&gt;getResponse()-&gt;getCookies()-&gt;add($cookie); &#125; else &#123; // 添加到session中 Yii::$app-&gt;getSession()-&gt;set($this-&gt;csrfParam, $token); &#125; return $token;&#125; 验证csrftoken12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152yii\web\Request/** * 验证csrf * Performs the CSRF validation. * * This method will validate the user-provided CSRF token by comparing it with the one stored in cookie or session. * This method is mainly called in [[Controller::beforeAction()]]. * * Note that the method will NOT perform CSRF validation if [[enableCsrfValidation]] is false or the HTTP method * is among GET, HEAD or OPTIONS. * * @param string $clientSuppliedToken the user-provided CSRF token to be validated. If null, the token will be retrieved from * the [[csrfParam]] POST field or HTTP header. * This parameter is available since version 2.0.4. * @return bool whether CSRF token is valid. If [[enableCsrfValidation]] is false, this method will return true. */public function validateCsrfToken($clientSuppliedToken = null)&#123; $method = $this-&gt;getMethod(); // 'GET', 'HEAD', 'OPTIONS' 这三种方法不验证csrf // only validate CSRF token on non-"safe" methods http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1 if (!$this-&gt;enableCsrfValidation || in_array($method, ['GET', 'HEAD', 'OPTIONS'], true)) &#123; return true; &#125; $trueToken = $this-&gt;getCsrfToken(); if ($clientSuppliedToken !== null) &#123; return $this-&gt;validateCsrfTokenInternal($clientSuppliedToken, $trueToken); &#125; // 获取请求数据或者header头中的数据进行验证 return $this-&gt;validateCsrfTokenInternal($this-&gt;getBodyParam($this-&gt;csrfParam), $trueToken) || $this-&gt;validateCsrfTokenInternal($this-&gt;getCsrfTokenFromHeader(), $trueToken);&#125;/** * Validates CSRF token * * @param string $clientSuppliedToken The masked client-supplied token. * @param string $trueToken The masked true token. * @return bool */private function validateCsrfTokenInternal($clientSuppliedToken, $trueToken)&#123; if (!is_string($clientSuppliedToken)) &#123; return false; &#125; $security = Yii::$app-&gt;security; return $security-&gt;unmaskToken($clientSuppliedToken) === $security-&gt;unmaskToken($trueToken);&#125; 密码的加密和验证generatePasswordHash &amp; validatePassword为了数据安全，存储的用户密码肯定是要加密的，而且是难以破解的，即使数据库被盗，对方依旧很难通过存储的加密信息破解出密码 根据原密码生成密码对应的加密数据123456789101112131415/** * 加密密码 * 和validatePassword 配对使用 * @param string $password The password to be hashed. 要加密的密码 * @param int $cost Cost parameter used by the Blowfish hash algorithm. 数值越大暴力破解越难，生成也越耗费资源 * @return string The password hash string. When [[passwordHashStrategy]] is set to 'crypt', * the output is always 60 ASCII characters, when set to 'password_hash' the output length * might increase in future versions of PHP (http://php.net/manual/en/function.password-hash.php) * @throws Exception on bad password parameter or cost parameter. * @see validatePassword() */public function generatePasswordHash($password, $cost = null)&#123; ...&#125; 验证密码是否匹配原密码生成的hash1234567891011121314/** * 验证密码 * 和generatePasswordHash配对使用 * Verifies a password against a hash. * @param string $password The password to verify. 用户输入的密码 * @param string $hash The hash to verify the password against. 使用generatePasswordHash生成的加密后的密码 * @return bool whether the password is correct. * @throws InvalidParamException on bad password/hash parameters or if crypt() with Blowfish hash is not available. * @see generatePasswordHash() */public function validatePassword($password, $hash)&#123; ...&#125; 实例：12345678910// generates the hash (usually done during user registration or when the password is changed)$hash = Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash($password);// ...save $hash in database... *// during login, validate if the password entered is correct using $hash fetched from databaseif (Yii::$app-&gt;getSecurity()-&gt;validatePassword($password, $hash) &#123; // password is good&#125; else &#123; // password is bad&#125; 数据的防篡改(也算加解密)hashData &amp; validateData就是我给你看，但是你不能改对原始数据进行加密，然后拼接原始数据12345678910111213141516171819/** * 加密数据 防篡改 * 和 validateData 配对使用 * * Prefixes data with a keyed hash value so that it can later be detected if it is tampered. * There is no need to hash inputs or outputs of [[encryptByKey()]] or [[encryptByPassword()]] * as those methods perform the task. * @param string $data the data to be protected 要加密的数据 * @param string $key the secret key to be used for generating hash. Should be a secure 加密使用的key * cryptographic key. * @param bool $rawHash whether the generated hash value is in raw binary format. If false, lowercase * hex digits will be generated. * @return string the data prefixed with the keyed hash * @throws InvalidConfigException when HMAC generation fails. */public function hashData($data, $key, $rawHash = false)&#123; ...&#125; 验证 hashData 后的数据,并返回数据1234567891011121314151617181920/** * 验证数据 * 使用 和 hashData 配对使用 * Validates if the given data is tampered. * @param string $data the data to be validated. The data must be previously 让hashData加密后的数据 * generated by [[hashData()]]. * @param string $key the secret key that was previously used to generate the hash for the data in [[hashData()]]. 加密时用的key * function to see the supported hashing algorithms on your system. This must be the same * as the value passed to [[hashData()]] when generating the hash for the data. * @param bool $rawHash this should take the same value as when you generate the data using [[hashData()]]. * It indicates whether the hash value in the data is in binary format. If false, it means the hash value consists * of lowercase hex digits only. * hex digits will be generated. * @return string|false the real data with the hash stripped off. False if the data is tampered. * @throws InvalidConfigException when HMAC generation fails. */public function validateData($data, $key, $rawHash = false)&#123; ...&#125; 实例：12345678public function actionIndex3()&#123; $userId = 30; echo $temp = Yii::$app-&gt;security-&gt;hashData("security", "bunao"); echo "&lt;br/&gt;"; echo Yii::$app-&gt;security-&gt;validateData($temp, "bunao"); # security echo "&lt;br/&gt;";&#125; cookie 加解密Yii写读cookie的时候使用12345678910111213141516171819202122232425262728293031323334353637383940414243在cookie的时候会对cookie数据进行加密 yii/web/Response /** * 发送cookie * Sends the cookies to the client. */protected function sendCookies()&#123; ... ... // 加密存入cookie foreach ($this-&gt;getCookies() as $cookie) &#123; $value = $cookie-&gt;value; if ($cookie-&gt;expire != 1 &amp;&amp; isset($validationKey)) &#123; $value = Yii::$app-&gt;getSecurity()-&gt;hashData(serialize([$cookie-&gt;name, $value]), $validationKey); &#125; setcookie($cookie-&gt;name, $value, $cookie-&gt;expire, $cookie-&gt;path, $cookie-&gt;domain, $cookie-&gt;secure, $cookie-&gt;httpOnly); &#125;&#125;获取cookie的时候对其进行解密 yii/web/Request/** * 获取cookie并转换 * Converts `$_COOKIE` into an array of [[Cookie]]. * @return array the cookies obtained from request * @throws InvalidConfigException if [[cookieValidationKey]] is not set when [[enableCookieValidation]] is true */protected function loadCookies()&#123; ... ... // 验证后获取源数据 $data = Yii::$app-&gt;getSecurity()-&gt;validateData($value, $this-&gt;cookieValidationKey); if ($data === false) &#123; continue; &#125; ... ...&#125; 生成随机字符generateRandomKey &amp; generateRandomString两个都是随机一串字符，但是 generateRandomKey 生成的不是Ascii码，所以在显示的时候有可能乱码，而 generateRandomString 是对 generateRandomKey 的封装，加了 base64_encode 使其不会乱码生成指定长度随机字符，可能不是 ASCII字符，显示的时候会出现乱码12345678910111213141516/** * 生成随机key。 * 和 generateRandomString 的区别就是输出的可能不是 Ascii码的 * Generates specified number of random bytes. * Note that output may not be ASCII. * @see generateRandomString() if you need a string. * * @param int $length the number of bytes to generate 生成的长度 * @return string the generated random bytes * @throws InvalidParamException if wrong length is specified * @throws Exception on failure. */public function generateRandomKey($length = 32)&#123; ...&#125; 生成指定长度随机字符12345678910111213/** * 生成指定长度的随机字符串 * Generates a random string of specified length. * The string generated matches [A-Za-z0-9_-]+ and is transparent to URL-encoding. * * @param int $length the length of the key in characters 生成字符的长度 * @return string the generated random key * @throws Exception on failure. */public function generateRandomString($length = 32)&#123; ...&#125;]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>加解密</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis实现文章根据点赞及时间排序]]></title>
    <url>%2F2018%2F10%2F07%2Fredis%2Fredis%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E6%A0%B9%E6%8D%AE%E7%82%B9%E8%B5%9E%E5%8F%8A%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[redis教程和命令redis教程和命令Redis 命令参考 需求： 根据对文章的点赞数来计算文章受欢迎程度，假设一篇文章至少需要200个赞才算有趣的文章，有趣的文章要求保留在列表前排至少 1 天 对文章进行分组，文章分值排序同样作用与一个组内的文章 思路：实现文章评分：因为要实现随时间流逝不断减少的分数，我们可以用文章发布时间来作为文章分数的基数，也就相对于随着时间的流逝文章的分数越低，因为后发布的分数比前发布的分数要高。根据需求需要超过200个赞的要在前排保留一天，我们可以计算出一个赞是多少分，一天的秒数86400除以200，等于432，也就是每获得一个赞将会的到432分 redis数据结构存储文章的 hash 结构数据结构 以文章 1 为例 字段 值 备注 key article:1 redis的key value redis的值，值的结构如下 标题 title learn redis 作者 poster echo-ding 发布时间 time 123456789 投票数 votes 12 根据发布时间排序文章的有序集合 zset 字段 值 备注 key time: redis的key value redis的值，值的结构如下 article:1 123456789 article:2 123456666 根据文章评分排序文章的有序集合 zset 字段 值 备注 key score: redis的key value redis的值，值的结构如下 article:1 123456789+432 article:2 123456666+432 记录文章投票人的集合 set以文章 1 为例 字段 值 备注 key voted:1 redis的key value redis的值，值的结构如下 user:1 文章分组，记录一个组内的文章 set以programming组为例 字段 值 备注 key group:programming redis的key value redis的值，值的结构如下 article:1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#!/usr/local/bin python3# -*-coding:utf-8-*-import redisimport time# 链接redisconn = redis.Redis(host='127.0.0.1',port=6609,db=0)# 一周的秒数ONE_WEEK_IN_SECONDS = 7 * 86400# 没个赞增加的积分数VOTE_SCORE = 432def article_vote(conn, user, article): ''' 投票函数 :param conn: redis资源 :param user: 用户 user:id :param article: 文章 article:id :return: ''' cutoff = time.time() - ONE_WEEK_IN_SECONDS # 如果创建文章的时间，如果已经一星期之前的，则不能再点赞 if conn.zscore('time:', article) &lt; cutoff: return # 获取文章id article_id = article.partition(':')[-1] # 如果没有投票，记录对此文章投票的人，并增加积分 if conn.sadd('voted:'+article_id, user): # 增加此文章的积分数 conn.zincrby('score:', article, VOTE_SCORE) # 增加文章的点赞数 conn.hincrby(article, 'votes', 1)def post_article(conn, user, title, article_id): ''' 创建文章 :param conn: redis资源 :param user: 用户 user:id :param title: 题目 :param article_id: 文章id :return: ''' voted = 'voted:' + article_id # 把作者添加到此文章的点赞栏 conn.sadd(voted, user) # 一星期后释放此文章的点赞人 conn.expire(voted, ONE_WEEK_IN_SECONDS) now = time.time() article = 'article:' + article_id # 存储文章信息 conn.hmset(article, &#123; 'title' : title, 'poster': user, 'time' : now, 'votes' : 1, &#125;) # 存储此文章的分值 conn.zadd('score:', article, now + VOTE_SCORE) # 存储此文章的时间 conn.zadd('time:', article, now)ARTICELS_PER_PAGE = 25def get_articles(conn, page, order = 'score:'): ''' 根据分值或创建时间获取文章 :param conn: redis资源 :param page: 页码 :param order: 根据哪个有序集合获取数据，默认是分值score: :return: 文章信息列表 ''' # 计算开始 start = (page - 1)*ARTICELS_PER_PAGE # 计算结尾 end = start + ARTICELS_PER_PAGE - 1 # 获取分值排序后的 start位到end位之间的数据 ids = conn.zrevrange(order, start, end) # 存储符合的文章 articles = [] for id in ids: # 获取该文章的信息 article_data = conn.hgetall(id) article_data['id'] = id articles.append(article_data) return articlesdef add_remove_grouops(conn, article_id, to_add = [], to_remove = []): ''' 把文章添加／移除到某些组 :param conn: redis资源 :param article_id: 文章id :param to_add: 要添加的组列表 :param to_remove: 要删除的组列表 :return: ''' article = 'article:' + article_id # 要添加到的组 for group in to_add: conn.sadd('group:' + group, article) # 要移除的组 for group in to_remove: conn.srem('group:' + group, article)def get_group_articles(conn, group, page, order = 'score:'): ''' 获取组内指定页的文章 :param conn: redis资源 :param group: 组id :param page: 页码 :param order: 根据哪个排序 分值score: 或 时间time: :return: 文章列表 ''' # 存储组文章排序的key key = order + group # 查看是否已经存在，避免频繁的计算 if not conn.exists(key): # 获取 集合'group:' + group 与 有序集合 order 的交集并将结果集存储在新的有序集合 key 中 # 集合 'group:' + group 中值对应的分值为1 # aggregate = 'max' 表示取交集中分值较大的分值 conn.zinterstore(key, ['group:' + group, order], aggregate = 'max' ) conn.expire(key, 60) # 获取文章 return get_articles(conn, page, key)if __name__ == '__main__': print('main') 参考 [redis实战 Josiah L. Carlson 著 人民邮电出版社]]]></content>
      <categories>
        <category>redis实战</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request组件和Response组件]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FRequest%E7%BB%84%E4%BB%B6%26%26Response%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Request组件前言Request 中的方法并不难，主要是一些功能的封装罢了，原理上没有很复杂的东西。只是涉及到许多HTTP的有关知识,具体的代码分析和相关知识可以看 这里主要归纳一下使用方法，以常用的 yii\web\Request 为例 请求头请求体getHeaders() 获取请求头可以获取所有的请求头 getRawBody() 获取请求体使用了 php://input 来获取请求体，这个 php://input 有这么几个特点： php://input 是个只读流，用于获取请求体。php://input 是返回整个HTTP请求中，除去HTTP头部的全部原始内容， 而不管是什么 Content Type（或称为编码方式）。 相比较之下， $_POST 只支持 application/x-www-form-urlencoded 和 multipart/form-data-encoded 两种 Content Type 。其中前一种就是简单的HTML表单以 method=&quot;post&quot; 提交时的形式， 后一种主要是用于上传文档。因此，对于诸如 application/json 等 Content Type，这往往是在 AJAX 场景下使用， 那么使用 $_POST 得到的是空的内容，这时就必须使用 php://input 。相比较于 $HTTP_RAW_POST_DATA ， php://input 无需额外地在 php.ini 中 激活 always-populate-raw-post-data ，而且对于内存的压力也比较小。当编码方式为 multipart/form-data-encoded 时， php://input 是无效的。这种情况一般为上传文档。 这种情况可以使用传统的 $_FILES 或者 yii\web\UploadedFile 获取/判断请求方法getMethod() 获取请求的方法可以以指定 $_POST[&#39;_method&#39;] 的方式来用POST请求来模拟其他方法的请求。 getIsAjax() 是否是AJAX请求这其实不是HTTP请求方法, 需要js在写入相应的header头 HTTP_X_REQUESTED_WITH: XMLHttpRequest getIsDelete() 是否是DELETE请求getIsFlash() 是否是Adobe Flash 或 Adobe Flex 发出的请求，这其实也不是HTTP请求方法。getIsGet() 是否是一个GET请求getIsHead() 是否是一个HEAD请求getIsOptions() 是否是一个OPTIONS请求getIsPatch() 是否是PATCH请求getIsPjax() 是否是一个PJAX请求，这也并非是HTTP请求方法。getIsPost() 是否是一个POST请求getIsPut() 是否是一个PUT请求获取请求数据get($name = null, $defaultValue = null) 获取get请求的数据 如果不带参数，则表示获取所有的get参数 getQueryParams() 常用的方式，获取某个值，如果这个值不存在就给指定的默认值 getQueryParam($name, $defaultValue = null) 1get('ding', 'ding') post($name = null, $defaultValue = null) 获取post请求的数据和get用法一样 getBodyParams() 解析请求体中的数据这个方法会根据请求的 content-type 来找对应的解析类把 请求体 的数据给解析出来 getBodyParam($name = null, $defaultValue = null) 解析请求体中的数据获取getBodyParams()解析后的内容中对应的key 域名相关getHostInfo() 获取当前的域名，带协议(http或https)和端口号举例1234请求www.yiibasic.com/test/test输出http://www.yiibasic.com getHostName() 获取当前域名，只是域名12解析的 getHostInfo() 获取到的值 parse_url($this-&gt;getHostInfo(), PHP_URL_HOST) 1234请求www.yiibasic.com/test/test输出www.yiibasic.com getServerName() 也是返回域名 和 getHostName一样url相关getUrl() 返回当前请求(域名后的所有内容)如http://localhost/learn/yii/yiilearn/basic/web/index.php/test/request返回/learn/yii/yiilearn/basic/web/index.php/test/request getScriptUrl() 获取入口文件相对域名的路径，带入口文件如 www.bunao.me/web/index.php 获取到的是 /web/index.phpwww.bunao.me/index.php 和 www.bunao.me 获取到的就是 /index.php如果开启了省略入口文件，则获取到的为空 getBaseUrl() 获取入口文件相对域名的路径,不带入口文件getBaseUrl() 获取到的是对 getScriptUrl() 的处理,去掉了入口文件假设域名指向的不是 web 而是 web的外层则获取到的是 /web getAbsoluteUrl() 获取完整的当前请求1$this-&gt;getHostInfo() . $this-&gt;getUrl(); getScriptFile() 获取当前脚本的实际物理路径例如1D:/ding/wamp64/www/learn/yii/yiilearn/basic/web/index.php getPathInfo() 返回真正的 pathInfo? 问号前和入口文件之间的部分例子1234567urlwww.bunao.me/index.php/ding/ran?bunao=yes 带入口文件的情况www.bunao.me/ding/ran?bunao=yes 不带入口文件www.bunao.me/web/index.php/ding/ran?bunao=yes 带入口文件 www.bunao.me/web/ding/ran?bunao=yes 不带入口文件pathInfo ding/ran 加解密相关的getCookies() 获取cookie默认是必须用这个方法来获取cookie的，因为默认存取cookie是存取的加密数据，而这个方法获取时会对加密的数据进行解密 Csrf这里理解一下yii如何实现csrf的 生成token:在渲染页面的时候通过 getCsrfToken() 方法获取到token，嵌到页面里，参考 BaseHtml::csrfMetaTags() 方法 验证token:在请求的时候通过 validateCsrfToken() 方法来验证token，参考 Controller::beforeAction() 方法 info1: 在生成token的时候同时会保存在 cookie、session 中，验证的时候将 接口(页面)传来的数据 和正确的数据(从 cookie、session 中获取) 进行比较。也就是说csrf依赖cookie。info2: 为什么敢将token同时存在cookie？因为存cookie时候是加密的形式，所以也就不害怕了。 其他方法getQueryString() 返回url中?后的部分getIsSecureConnection() 判读不是 https请求getServerPort() 获取端口号getReferrer() 获取 ReferergetUserAgent() 获取浏览器信息，简单防爬虫getUserIP() 获取用户ipgetPort() 获取http端口号，默认是80getSecurePort() 获取https端口号，默认是443getContentType() 获取 content-typeresolve() 获取解析后的请求Application 会用它来执行解析Url请求，分析出正确的路由和参数 其他的其他getUserHost() 获取用户主机名/域名getAuthUser() http认证机制getAuthPassword() http认证密码getAcceptableContentTypes() 获取用户能够接受的content-type类型看示例吧123456789$_SERVER['HTTP_ACCEPT'] = 'text/plain; q=0.5, application/json; version=1.0, application/xml; version=2.0;';$types = $request-&gt;getAcceptableContentTypes();print_r($types);// 结果// [// 'application/json' =&gt; ['q' =&gt; 1, 'version' =&gt; '1.0'],// 'application/xml' =&gt; ['q' =&gt; 1, 'version' =&gt; '2.0'],// 'text/plain' =&gt; ['q' =&gt; 0.5],// ] parseAcceptHeader($header) 解析获取到的请求头字段，看示例123456789$header = 'text/plain; q=0.5, application/json; version=1.0, application/xml; version=2.0;';$accepts = $request-&gt;parseAcceptHeader($header);print_r($accepts);// displays:// [// 'application/json' =&gt; ['q' =&gt; 1, 'version' =&gt; '1.0'],// 'application/xml' =&gt; ['q' =&gt; 1, 'version' =&gt; '2.0'],// 'text/plain' =&gt; ['q' =&gt; 0.5],// ] getAcceptableLanguages() 获取能够接收的语言类型getPreferredLanguage(array $languages = []) 返回该应用程序应该用的首选语言getETags() 返回etags内容, 在http缓存有用使用ETags减少Web应用带宽和负载 参考深入理解yii-Request(完全参考) Response组件前言我觉得官网上的已经很清晰够用了，代码也比较简单。直接看 官网]]></content>
      <categories>
        <category>yii</category>
        <category>请求和响应组件</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>Response</tag>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-controller]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2F%E6%8E%A7%E5%88%B6%E5%99%A8-Controller%2F</url>
    <content type="text"><![CDATA[前言控制器作为最常用的一个类，也比较简单，这里只简单梳理一下因为常用的是web形式，这里就以 yii\web\Controller 为基础进行分析 属性常用属性列表12345$id # 控制器id$module # 如果有，则是该控制器所在的module模块对象 $defaultAction # 默认的action，在请求没有指定控制器的action的时候默认请求这个 $layout # 指定layout文件，如果不使用layout设置值为 false ，后面会详细分析 $enableCsrfValidation # 是否验证csrf, 如果关闭，在beforeAction 中将不进行校验 执行操作通过下面这两种方式执行action和正常的通过对象调用执行有什么区别？直接通过对象调用的方式执行某个方法，只是执行了这个方法；而通过下面这两种方式(通过路由)执行的方式会完整的执行所属modules、controller的 beforeAction 和 afterAction(动作过滤器) runAction() 执行本控制器的action通过本控制器的 actionId 完整的执行(就是包含动作过滤器)对应的 独立action 或 内联action run() 根据路由相应的动作看下面源码先有三种不同的情况 单独一个actionid 执行相对当前控制器下的action controllerid/actionid || module/controllerid/actionid 执行相对当前module下的路由 /module/controllerid/actionid 执行绝对路由 其中第三种就是我们发送请求的时候所要执行的操作，而第二种其实和第三种是一样的($app也是module)，只不过使用当前module往后找1234567891011121314151617181920/** * 运行路由指向的action * 三种路由形式 * 1. 单独一个actionid 执行相对当前控制器下的action * 2. controllerid/actionid 执行相对当前module * 3. /module/controllerid/actionid 绝对路由 */public function run($route, $params = [])&#123; $pos = strpos($route, '/'); // route 不包含 / 执行本控制器的action if ($pos === false) &#123; return $this-&gt;runAction($route, $params); // route 为 controller/action 的形式，执行本module下的控制器方法 &#125; elseif ($pos &gt; 0) &#123; return $this-&gt;module-&gt;runAction($route, $params); &#125; // route 以 / 开头 和路由一样了 return Yii::$app-&gt;runAction(ltrim($route, '/'), $params);&#125; 钩子方法||方法过滤器就是在执行动作之前 beforeAction 进行请求过滤,在请求之后 afterAction 进行结果过滤，基础控制器中这两个方法都会触发响应的事件看一下web在 beforeAction 进行的csrf验证1234567891011121314151617181920212223242526272829303132333435363738394041/** * 执行动作之前 ， 验证 csrf csrf验证 * @inheritdoc */public function beforeAction($action)&#123; if (parent::beforeAction($action)) &#123; if ($this-&gt;enableCsrfValidation &amp;&amp; Yii::$app-&gt;getErrorHandler()-&gt;exception === null &amp;&amp; !Yii::$app-&gt;getRequest()-&gt;validateCsrfToken()) &#123; throw new BadRequestHttpException(Yii::t('yii', 'Unable to verify your data submission.')); &#125; return true; &#125; return false;&#125;``` ## 视图相关 ### 设置 layout 根据 `findLayoutFile()` 方法可以知道根据 `layout` 属性值的不同获取 layout 的方法也不相同 1. `$this-&gt;layout = false` 不使用layout 2. `$this-&gt;layout = @abc/ad.php` 以别名的形式开头指定layout路径，直接用的就是这个文件 3. `$this-&gt;layout = /ding.php` 以绝对路径指定layout路径，用的是 `$app` 模块下默认layout文件夹下的对应的文件 4. `$this-&gt;layout = ding` 使用当前模块下layout文件夹下的对应的文件5. `$this-&gt;layout = null` 默认情况，如果当前moudle设置了 `layout` 属性，则使用该模块下layout文件夹下的 `layout` 属性值所代表的文件，如果当前模块没有设置，则往上一级模块寻找，直到 `$app` 模块 ### 渲染视图相关 渲染视图功能其实是通过 `view` 组件实现的，这里先简单说一下, 下面的四个方法其实极其的相似 #### render 方法 `render()` 方法会根据传入 `$view` 值的形式不同而去找相对应的文件 1. `@abc/efg.php` 以别名 `@` 形式，直接通过别名找到对应的文件 2. `//abc/ding.php` 以 `//` 开头的，直接从 `$app` 模块的 views 目录下开始找对应的文件 3. `/abc/ding.php` 以 `/` 开头的，从 **当前模块** 的 views 目录下开始找对应的文件 4. `ding` 这种就是我们最长用的，就是找当前模块视图文件夹下控制器对应的文件夹下的视图文件 ```phppublic function render($view, $params = [])&#123; // 视图文件经过变量替换后的内容 $content = $this-&gt;getView()-&gt;render($view, $params, $this); return $this-&gt;renderContent($content);&#125; renderPartial 不使用layout这个就更简单了，和 render() 方法的唯一区别就是不使用layout了1234public function renderPartial($view, $params = [])&#123; return $this-&gt;getView()-&gt;render($view, $params, $this);&#125; renderContent 将字符串填充到layout就是将 $content 填充到layout文件中，上面的 render() 方法就用到了123456789public function renderContent($content)&#123; $layoutFile = $this-&gt;findLayoutFile($this-&gt;getView()); if ($layoutFile !== false) &#123; // 渲染layout return $this-&gt;getView()-&gt;renderFile($layoutFile, ['content' =&gt; $content], $this); &#125; return $content;&#125; renderFile 直接指定要渲染的文件路径上面的三个方法，最终都需要通过 View::renderFile() 方法来获取文件数据的，只不过 render() 方法有找对应文件的规则罢了1234public function renderFile($file, $params = [])&#123; return $this-&gt;getView()-&gt;renderFile($file, $params, $this);&#125; 独立动作 action使用场景：多个控制器都用到同样的方法，或者是作为第三方扩展方便引入。只需要在控制器中配置一下，指定一下动作id，即可通过该控制器进行访问。 比较简单但又常用到，偷个懒直接 引用一下官方文档 内容独立操作通过继承 yii\base\Action 或它的子类来定义。 例如Yii发布的 yii\web\ViewAction 和 yii\web\ErrorAction 都是独立操作。 要使用独立操作，需要通过控制器中覆盖 yii\base\Controller::actions() 方法在中申明， 如下例所示：12345678910111213public function actions()&#123; return [ // 用类来申明"error" 动作 'error' =&gt; 'yii\web\ErrorAction', // 用配置数组申明 "view" 动作 'view' =&gt; [ 'class' =&gt; 'yii\web\ViewAction', 'viewPrefix' =&gt; '', ], ];&#125; 页面跳转作为方便，这里封装了四个跳转相关的方法，其中用到的一些其他类的方法，请跳转到对应的文章查看 redirect 页面跳转Url 帮助类1234public function redirect($url, $statusCode = 302)&#123; return Yii::$app-&gt;getResponse()-&gt;redirect(Url::to($url), $statusCode);&#125; goHome 跳转到首页1234public function goHome()&#123; return Yii::$app-&gt;getResponse()-&gt;redirect(Yii::$app-&gt;getHomeUrl());&#125; goBack 返回上一页(上一个记录的链接)这个依赖于 cookie 因为用的 session 进行保存访问记录的首先在访问的时候记录一下访问的路由1234567891011121314// 记录访问路由Yii::$app-&gt;getUser()-&gt;setReturnUrl(['admin/index', 'ref' =&gt; 1]);// 记录访问路由，和上面一样。方便一点 Url::remember(['admin/index', 'ref' =&gt; 1]);// 控制器中跳转到上一个记录点 $this-&gt;goBack();``` 通过下面的方法进行跳转上个记录点 ```phppublic function goBack($defaultUrl = null)&#123; return Yii::$app-&gt;getResponse()-&gt;redirect(Yii::$app-&gt;getUser()-&gt;getReturnUrl($defaultUrl));&#125; refresh 刷新当前页1234public function refresh($anchor = '')&#123; return Yii::$app-&gt;getResponse()-&gt;redirect(Yii::$app-&gt;getRequest()-&gt;getUrl() . $anchor);&#125;]]></content>
      <categories>
        <category>yii</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>controller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-model]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2F%E6%A8%A1%E5%9E%8B%E7%B1%BB-Model%2F</url>
    <content type="text"><![CDATA[前言简单的接收数据的表单，使用继承自 Model 类的模型即可，如果是需要增删改之类的牵扯到表的则用 Active Record 活动记录(也是继承自 Model) 下面所述，字段和属性一个意思 像数组一样访问和遍历模型可像访问数组单元项一样访问属性，这要感谢 yii\base\Model 支持 ArrayAccess 数组访问参考链接 和 ArrayIterator 数组迭代器参考链接:1234567891011121314public function actionModel()&#123; $model = new TestForm; // 显示所有的公有属性 var_dump($model-&gt;attributes); // yii\base\Model 支持 ArrayAccess 数组访问 可以像访问数组但愿项一样访问属性 $model['name'] = 'example'; echo $model['name']; // Model 支持 ArrayIterator 数组迭代器，迭代器遍历模型，访问所有的公有属性 foreach ($model as $name =&gt; $value) &#123; echo "$name: $value\n"; &#125;&#125; 属性标签属性标签多用在小部件展示字段的时候显示的字段名，默认情况下，属性标签通过 yii\base\Model::generateAttributeLabel() 方法自动从属性名生成. 它会自动将驼峰式大小写变量名转换为多个首字母大写的单词， 例如 username 转换为 Username ， firstName 转换为 First Name。 获取属性标签获取 name 字段的属性标签1$model-&gt;getAttributeLabel('name'); 手动设置属性标签自定义属性标签123456public function attributeLabels()&#123; return [ 'name' =&gt; 'Your name', ];&#125; 场景一个模型可以根据不同的场景所支持的字段来执行对应的验证或块赋值，从而实现一个Model对应可以对应多个不同业务。 例如 User 模块可能会在收集用户登录输入， 也可能会在用户注册时使用。在不同的场景下， 模型可能会使用不同的业务规则和逻辑， 例如 email 属性在注册时强制要求有，但在登陆时不需要。 定义场景默认情况下，模型支持一个名为 default 的场景 方式一：在场景 scenarios() 方法中定义12345678910111213class User extends ActiveRecord&#123; const SCENARIO_LOGIN = 'login'; const SCENARIO_REGISTER = 'register'; //定义场景 public function scenarios() &#123; return [ self::SCENARIO_LOGIN =&gt; ['username', 'password'], self::SCENARIO_REGISTER =&gt; ['username', 'email', 'password'], ]; &#125;&#125; 方式二：在规则 rolus() 方法中定义直接在规则 rolus() 方法中 使用 on 来指定场景，没使用 on 将 用在所有场景中 这里的所有场景是指规则中所有通过 on 或 except 定义的场景 使用规则如下，请按照顺序 如果 on 没有指定场景，这条规则上的字段将会添加到所有的场景 如果 on 没有指定场景，而使用 except 指定场景，那么这条规则上的字段将作用于除了 except 指定场景外的所有场景 如果 on 指定了场景，那这条规则上的字段就将会使用所指定的场景 12345678910public function rules()&#123; return [ // 在"register" 场景下 username, email 和 password 必须有值 [['username', 'email', 'password'], 'required', 'on' =&gt; 'register'], // 在 "login" 场景下 username 和 password 必须有值 [['username', 'password'], 'required', 'on' =&gt; 'login'], ];&#125; 两种方式定义规则方式的区别其实两种方式是一样的，第一种方式更加清楚一些，而第二种方法更加灵活一些。我们看一下第二种是怎么实现的。其实就是将规则 rules 中定义的场景提取出来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public function scenarios()&#123; // 默认场景 $scenarios = [self::SCENARIO_DEFAULT =&gt; []]; // 遍历rules定义的所有的验证器 foreach ($this-&gt;getValidators() as $validator) &#123; // rule数组中定义的场景 on=&gt;scenario foreach ($validator-&gt;on as $scenario) &#123; $scenarios[$scenario] = []; &#125; // 验证规则中除去某个场景都验证的情况 except=&gt;scenario foreach ($validator-&gt;except as $scenario) &#123; $scenarios[$scenario] = []; &#125; &#125; // 获取所有的场景 $names = array_keys($scenarios); // 将字段添加到对应的场景中 foreach ($this-&gt;getValidators() as $validator) &#123; // 如果 某个 rule 中没有定义场景 // 表示这个rule中所有的字段用在所有的场景中 if (empty($validator-&gt;on) &amp;&amp; empty($validator-&gt;except)) &#123; foreach ($names as $name) &#123; foreach ($validator-&gt;attributes as $attribute) &#123; $scenarios[$name][$attribute] = true; &#125; &#125; // 如果 rule 没有定义使用的场景 on &#125; elseif (empty($validator-&gt;on)) &#123; foreach ($names as $name) &#123; // 如果不在定义的排除 except 的场景 if (!in_array($name, $validator-&gt;except, true)) &#123; foreach ($validator-&gt;attributes as $attribute) &#123; $scenarios[$name][$attribute] = true; &#125; &#125; &#125; // 如果定义了使用的场景 on &#125; else &#123; foreach ($validator-&gt;on as $name) &#123; foreach ($validator-&gt;attributes as $attribute) &#123; $scenarios[$name][$attribute] = true; &#125; &#125; &#125; &#125; // 除去没用到的场景 foreach ($scenarios as $scenario =&gt; $attributes) &#123; if (!empty($attributes)) &#123; $scenarios[$scenario] = array_keys($attributes); &#125; &#125; return $scenarios;&#125;``` ### 使用场景 如下展示两种设置场景的方法:```php// 场景作为属性来设置$model-&gt;scenario = 'login';// 场景通过构造初始化配置来设置$model = new Model(['scenario' =&gt; 'login']); 验证规则为什么写在场景之后，因为用到场景啊 示例先看一下下面的内容，之后我们在分析原理，内容来自官方文档 当模型接收到终端用户输入的数据，数据应当满足某种规则(称为 验证规则, 也称为 业务规则)。 可调用 yii\base\Model::validate() 来验证接收到的数据， 该方法使用 yii\base\Model::rules() 申明的验证规则来验证每个相关属性， 如果没有找到错误，会返回 true， 否则它会将错误保存在 yii\base\Model::errors 属性中并返回 false ，例如：1234567891011$model = new \app\models\ContactForm;// 用户输入数据赋值到模型属性$model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm');// 验证数据if ($model-&gt;validate()) &#123; // 所有输入数据都有效 all inputs are valid&#125; else &#123; // 验证失败：$errors 是一个包含错误信息的数组 $errors = $model-&gt;errors;&#125; 通过覆盖 yii\base\Model::rules() 方法指定 模型属性应该满足的规则来申明模型相关验证规则。 下述例子显示ContactForm模型申明的验证规则:12345678910public function rules()&#123; return [ // name, email, subject 和 body 属性必须有值 [['name', 'email', 'subject', 'body'], 'required'], // email 属性必须是一个有效的电子邮箱地址 ['email', 'email'], ];&#125; 一条规则可用来验证一个或多个属性，一个属性可对应一条或多条规则。 有时你想一条规则只在某个 场景 下应用， 为此你可以指定规则的 on 属性，如下所示:12345678910public function rules()&#123; return [ // 在"register" 场景下 username, email 和 password 必须有值 [['username', 'email', 'password'], 'required', 'on' =&gt; 'register'], // 在 "login" 场景下 username 和 password 必须有值 [['username', 'password'], 'required', 'on' =&gt; 'login'], ];&#125; 如果没有指定 on 属性，规则会在所有场景下应用， 在当前 yii\base\Model::scenario 下应用的规则称之为 active rule活动规则。 一个属性只会属于scenarios()中定义的活动属性且在 rules() 申明对应一条或多条活动规则的情况下被验证。 原理根据 rules 中定义的规则生成验证器，然后在根据场景来获取到需要验证的字段进行验证 使用rules 配置下面随便写几条规则理解一下1234567891011121314151617181920212223242526public function rules()&#123; return [ // 在"register" 场景下 username, email 和 password 必须有值 [['username', 'email', 'password'], 'required', 'on' =&gt; 'register'], // 验证之前会先执行 when 定义的匿名函数，如果返回的true才往后进行验证。 参数：(当前模型对象, 验证的属性) [['username', 'email', 'password'], 'required', 'when' =&gt; function ($model, $attribute)&#123;&#125;], // 通过匿名函数进行校验 参数：(验证的属性, 规则中定义的params, InlineValidator对象) [['username', 'email', 'password'], function ($attribute, $params, $validator)&#123;&#125;, 'params' =&gt; ['a', 'b']], // 使用当前model中的 myValidator() 方法进行验证 [['username', 'email', 'password'], 'myValidator'], // 除了 register 场景,其他场景 username 和 password 必须有值; skipOnError = false 时，如果之前的验证器出现验证错误，该验证器依旧进行验证; message 配置自定义的错误信息 [['!username', 'password'], 'required', 'except' =&gt; 'register', 'skipOnError' =&gt; false, 'message' =&gt; 'Please choose a username.'], ];&#125;``` &gt; 以 !开头的属性为 非安全属性(只验证，不赋值) #### yii自定义的验证器了解一下 `yii\validators\Validator` 类中定义了一些常用的验证器，去了解一下 ### 相关方法 #### 返回当前场景需要验证的字段 ```php# 返回当前场景需要验证的字段，包括以 !开头的 非安全属性(只验证，不赋值) activeAttributes() 返回当前场景 所有/某字段 有效的验证器123# 如果 $attribute = null 返回当前场景有效的验证器# 如果 $attribute = 字段值 返回 该字段 在当前场景下所有的验证器 getActiveValidators($attribute = null) 验证 validate默认验证所有需要验证的字段，可以指定验证的字段12# 如果传 $attributeNames = ['字段1', '字段2'] 将会只验证这两个字段 validate($attributeNames = null, $clearErrors = true) 关于验证器的属性配置在验证属性的时候用到了验证器的两个属性 skipOnError 和 skipOnEmpty , 分别表示当如果之前的验证器已经有错误是否跳过和该字段值为空时是否跳过验证。跳过验证后将不会进行验证，也就不发获取到全部的验证错误信息 如果需要获取所有的验证错误信息，需要在配置 rules 时将 skipOnError 配置上去，值为 false 几个和error相关的方法1234567891011121314# 给属性添加错误信息，一般自定义验证方法的时候会用到 addError($attribute, $error = '')# 上面的复数形式 addErrors(array $items)# 获取 所有/指定的属性 是否有验证错误 hasErrors($attribute = null)# 获取 所有/指定的属性 的验证错误信息 getErrors($attribute = null)# 清除 所有/指定的属性 的验证错误信息 clearErrors($attribute = null)# 获取该属性的第一个错误信息 getFirstError($attribute)# 获取所有属性的第一个错误信息getFirstErrors() 临时验证有时，你需要对某些没有绑定任何模型类的值进行 临时验证。 若你只需要进行一种类型的验证 (e.g. 验证邮箱地址)，你可以调用所需验证器的 `validate()`` 方法。像这样：12345678$email = 'test@example.com';$validator = new yii\validators\EmailValidator();if ($validator-&gt;validate($email, $error)) &#123; echo '有效的 Email 地址。';&#125; else &#123; echo $error;&#125; 块赋值setAttributes() 块赋值块赋值只用一行代码将用户所有输入填充到一个模型，非常方便， 它直接将输入数据对应填充到 yii\base\Model::attributes() 属性。 以下两段代码效果是相同的， 都是将终端用户输入的表单数据赋值到 ContactForm 模型的属性， 明显地前一段块赋值的代码比后一段代码简洁且不易出错。123456789$model = new \app\models\ContactForm;$model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm');$model = new \app\models\ContactForm;$data = \Yii::$app-&gt;request-&gt;post('ContactForm', []);$model-&gt;name = isset($data['name']) ? $data['name'] : null;$model-&gt;email = isset($data['email']) ? $data['email'] : null;$model-&gt;subject = isset($data['subject']) ? $data['subject'] : null;$model-&gt;body = isset($data['body']) ? $data['body'] : null; 块赋值调用的是 setAttributes($values, $safeOnly = true) 方法，第二个参数默认为 true ,表示需要 rolus() 方法在声明了的字段(属性)且字段前面没有 ! 才给赋值(赋值，并验证)，改为 false 表示只要对应的有这个属性(字段)，就给赋值 load() 表单块赋值通过表单上传的数据通常是通过 load 进行块赋值的(前端用到表单小部件的情况，因为表单小部件默认会在表单提交的name属性值带上 $model-&gt;formName() 来对应该模型)。当然也可以手动指定 $formName 值为自定义的值123456789101112131415161718public function load($data, $formName = null)&#123; // form表名 $scope = $formName === null ? $this-&gt;formName() : $formName; // 如果没有表单名 if ($scope === '' &amp;&amp; !empty($data)) &#123; $this-&gt;setAttributes($data); return true; // 如果有表名，获取表单名下的数据 // 获取提交的类名下的数据 &#125; elseif (isset($data[$scope])) &#123; $this-&gt;setAttributes($data[$scope]); return true; &#125; return false;&#125; 哈哈，其实还是用的 setAttributes() 嘛，就是用表单小部件的时候用这个方便 数据导出 toArray()其实这个应该放在 restful 和 AR模型 是分析的，这里先简单看一下用法下面都是官网的 默认情况下，字段名对应属性名，但是你可以通过覆盖 fields() 和/或 extraFields() 方法来改变这种行为， 两个方法都返回一个字段定义列表，fields() 方法定义的字段是默认字段， 表示 toArray() 方法默认会返回这些字段。 extraFields() 方法定义额外可用字段， 通过toArray()方法指定$expand参数来返回这些额外可用字段。 例如如下代码会返回fields()方法定义的所有字段和extraFields()方法定义的prettyName and fullAddress字段。12// toArray(array $fields = [], array $expand = [], $recursive = true) 方法参数$array = $model-&gt;toArray([], ['prettyName', 'fullAddress']); 可通过覆盖 fields() 来增加、删除、重命名和重定义字段， fields() 方法返回值应为数组， 数组的键为字段名，数组的值为对应的可为属性名或匿名函数返回的字段定义对应的值。 特使情况下，如果字段名和属性定义名相同，可以省略数组键， 例如：1234567891011121314151617181920212223242526272829// 明确列出每个字段，特别用于你想确保数据表或模型// 属性改变不会导致你的字段改变(保证后端的API兼容)。public function fields()&#123; return [ // 字段名和属性名相同 'id', // 字段名为 "email"，对应属性名为 "email_address" 'email' =&gt; 'email_address', // 字段名为 "name", 值通过PHP代码返回 'name' =&gt; function () &#123; return $this-&gt;first_name . ' ' . $this-&gt;last_name; &#125;, ];&#125;// 过滤掉一些字段，特别用于// 你想继承父类实现并不想用一些敏感字段public function fields()&#123; $fields = parent::fields(); // 去掉一些包含敏感信息的字段 unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']); return $fields;&#125; 警告： 由于模型的所有属性会被包含在导出数组，最好检查数据确保没包含敏感数据， 如果有敏感数据，应覆盖 fields() 方法过滤掉， 在上述列子中，我们选择过滤掉 auth_key, password_hash and password_reset_token]]></content>
      <categories>
        <category>yii</category>
        <category>model</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>model</tag>
        <tag>验证器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom-小技巧]]></title>
    <url>%2F2017%2F07%2F01%2Fatom%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[关于代码高亮``` 后面跟上语言如 php、js等 如 js但是有时 php 在 Atom 上并不会高亮，这时在首航添加 &lt;?php 即可123456789101112&lt;?php/****/class ClassName extends AnotherClass&#123; function __construct(argument) &#123; # code... &#125;&#125; 插件使用方法每个插件的使用方法都可以在 setting-&gt;packages 中点击插件名来进入到插件的介绍也面]]></content>
      <categories>
        <category>工具</category>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom-上手]]></title>
    <url>%2F2017%2F07%2F01%2Fatom%2FAtom%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Atom使用教程详细的操作可以参考下面的教程极客学院 W3C 删除Atom使用的360进行删除，删除后会发现 C:\Users\你的用户名\ 有一个隐藏的文件夹 .atom 将其删除，不删除的话重新安装atom的时候依旧会保留原来的配置及插件 插件安装完 Atom 之后自带了79个插件，基本的功能都已经可以使用了 安装插件 在 setting 页面可以看到 Packages 和 Install 两个选项， Packages 查看已经安装的插件， Install 来安装插件的，可以使用 ctrl+Shift+p 进入这个页面 插件 是否安装 file-icons yes pigments no minimap yes autocomplete-paths no atom-ternjs no emmet yes docblockr yes vim-mode no platformio-ide-terminal no atom-beautify yes php-debug yes linter-jshint yes simplified-chinese-menu no goto-definition yes Highlight Selected yes file-icons 显示文件类型对应的图标 pigments css/less 写表示颜色时显示颜色 minimap 右边代码预览框 autocomplete-paths 补全路径 atom-ternjs 补全Js emmet 前端实用工具 教程 docblockr 代码注释 vim-mode 在 Atom 上使用 Vim Highlight Selected 选中单词所有相同的高亮 platformio-ide-terminal Atom 中集成终端 atom-beautify 美化代码段 快捷键 ctrl + alt + b ，如果弹出出错信息，可能是需要依赖一些其他插件，比如 php的 就需要装 php-cs-fixer 插件 linter-php 检查php语法错误 ，可能需要将php配置成全局 ，安装它的时候会让安装一些依赖插件，按照提示安装即可 linter-jshint 检查js语法错误 ，需要安装node，使用npm 全局安装jshint (没有配置成功，报错incompatible values for the esversion and es3 linting option ，配置文件写错了) 相关资料 jshint配置 linter-jshint配置 首先安装 node ，使用npm 全局安装jshint 在 ~ (~,表示用户目录，在windows下是C:\Users\dingran)文件下放置js配置文件 .jshintrc 配置文件 atom 配置插件，如下图勾选lint inline javaScript,可以在html或php中检查js点击 open config folder 找到配置文件，查看配置文件 config.cson 123&quot;linter-jshint&quot;: disableWhenNoJshintrcFileInPath: false lintInlineJavaScript: true php-debug xdebug调试 simplified-chinese-menu 汉化 goto-definition 文件跳转，放到方法或类名上右键 goto definition 就会出现列表，选择跳转，有快捷键，还是不用了 remote-ftp sftp上传工具插件配置：把 auto upload on save 由 aways 改为 nerver 可以在 packages-&gt;Remote-Ftp-&gt;Create …… 来生成配置文件 .ftpconfig (生成在添加到Atom项目文件根目录，上传的时候也是在根目录中寻找配置文件，限制啊)，上传只能在左边 menu 菜单来选中上传和下载 (限制啊) 12345678910111213141516171819202122&#123; &quot;protocol&quot;: &quot;sftp&quot;, # 协议 &quot;port&quot;: 22, # 端口 &quot;host&quot;: &quot;128.128.1.79&quot;, # ip &quot;user&quot;: &quot;root&quot;, # 用户 &quot;pass&quot;: &quot;******&quot;, # 密码 &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/usr/share/nginx/html/protected&quot;, # 对应的项目文件地址 &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500&#125; Markdown相关Markdown相关Markdown相关 markdown-scroll-sync 预览同步滚动tidy-markdown Markdown美化，在保存的时候或者主动调用插件时触发 python相关编辑器里运行直接运行代码 js、python 等都可以atom-runer编辑器运行代码快捷键看插件介绍win配置12345File-&gt;Config...末尾添加 runner: scopes: python: &quot;D:\\ding\\python&quot; mac配置1234Atom-&gt;Config...末尾添加 runner: python: &quot;/usr/local/bin/python3&quot; autocomplete-python自动提示 装逼神奇 activate-power-mode 颤抖吧 快捷键慕课ATOM编辑器快捷键大全 Atom 兼容sublime快捷键，同时也有自己的快捷键 12345678910111213141516171819202122Ctrl + / 启用注释 同sublimeCtrl + \ 展示隐藏目录树 同时也可以 ctrl+k ctrl+bCtrl + Alt + I 打开Chrome调试器 nbCtrl + [ 向右缩进Ctrl + ] 向左缩进Shift + Home 选定光标至行首Shift + End 选定光标至行尾Shift + PageUp 选定光标至页首Shift + PageDown 选定光标至页尾Ctrl + Home 光标到页首Ctrl + End 光标至页尾Ctrl + PageUp 切换上一个打开的标签Ctrl + PageDown 切换下一个打开的标签Ctrl + D 匹配选定下一个 同sublimeAlt + F3 匹配选定所有Ctrl + ↑ 选中行上移 和sublime有区别，sulime为ctrl+Shift+↑Ctrl + ↓ 选中行下移cmd + b 在打开的文件之间切换Ctrl + Shift + L 切换文本内容类型，例如 html/php 和sublime不同 cmd + shift + b 只搜索从上次git commit后修改或者新增的文件cmd + shift + d 复制选中代码并粘贴到选中的后面cmd + shift + u 选择文件编码格式 折叠1234Alt + Ctrl + [ 折叠Alt + Ctrl + ] 展开Alt + Ctrl + Shift + &#123; 折叠全部Alt + Ctrl + Shift + &#125; 展开全部 Markdown1Ctrl + Shift + M Markdown预览 Markdown 语法补全1234567891011b **加粗**legal Copyright (c) 2017 Copyright Holder All Rights Reserved.img ![]()l []()i **code \```code\```\t - [ ] 多选按钮table | Header One | Header Two || :------------- | :------------- || Item One | Item Two | 更改快捷键 有些时候需要更改快捷键，比如快捷键冲突时 打开快捷键设置，如图搜索要改的快捷键 如 ctrl-shift-m,发现有两个，出现了冲突，这时可以自定义一个(优先级最高)将其覆盖点击需要自定义快捷键的最左边的小按钮进行复制 打开自定义文件(点击链接 your keymap file) 将复制的快捷键定义粘贴在自定义文件中，如图 备份插件备份插件教程 将配置文件上传到github 备份使用快捷键 Ctrl + Shift + P 呼出命令栏，输入 sync backup恢复备份使用快捷键 Ctrl + Shift + P 呼出命令栏，输入 sync restore 补充 获取 Gist Id 进入到github，点击你的头像会看到 Your gists,点击进去 如果没有，则需要创建一个：起个名称(用途)，写个简介 获取 Gist Id，进入创建好的 Gist 看到连接 https://gist.github.com/Ibunao/654a98d3e154348eaebba448312b0152 其中 654a98d3e154348eaebba448312b0152 就是 Gist Id xdebug调试相关教程 atom 安装 php-debug 插件，不用配置 php开启xdebugwin上安装的是wamp所以xdebug都是有的php.ini 配置 12345678910111213141516[xdebug]zend_extension =&quot;D:/ding/wamp64/bin/php/php5.6.25/zend_ext/php_xdebug-2.4.1-5.6-vc11-x86_64.dll&quot;;xdebug.remote_enable = Offxdebug.profiler_enable = Onxdebug.profiler_enable_trigger = offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir =&quot;D:/ding/wamp64/tmp&quot;xdebug.show_local_vars=0xdebug.remote_enable=1xdebug.remote_host=127.0.0.1xdebug.remote_connect_back=1xdebug.remote_port=9000xdebug.remote_handler=dbgpxdebug.remote_mode=reqxdebug.remote_autostart=true 调试 开启debug插件 atom左下角debug按钮打开debug，没有监听到时显示的是 Listening on address:port 127.0.0.1:9000 在方法中打断点 (断点要注意了，如果打到空行，或者for循环里面将会无法监听到) 如图 浏览器中访问能进入到打断点的方法中 ，如 www.basic.com/test/test如果操作正确将会看到监听状态由 Listening on address:port 127.0.0.1:9000 改变成 Connected ,此时就可以使用debug调试了 如果没有改变监听状态，可能就是断点打错了，请检查如果atom的debug启动不起来，可能是9000端口被占用了，更改插件端口和php.ini 中的xdebug配置的端口即可 操作详解进入到断点将会输出一下内容，如下图其中，主要的有两部分内容 栈信息Stack 和变量值信息 Context其中 Stack 显示的是走到这个断点所经过的方法，如图从7到0，可以点击不同的栈来查看他的 变量值信息 Context Context 中显示的是变量信息，其中 Locals 显示的是方法中的变量值信息Superglobals 显示的是全局的信息 ，如 $_COOKLE、$_POST 等一些全局的信息User defined constants 显示的是定义的常量 操作 添加断点在代码的左边栏上点击，因为比较窄不好点击，也可以使用快捷键 alt + f9 Stop 释放掉监听 alt + f5Continue 走向下一个断点 Step Over 一步一步往下走 alt + f6Step In 进入到方法内 alt + f7Step Out 跳出方法 alt + f8 Restore Panels 恢复原始的展示窗口其他两个就是切换展示位置的 xdebug使用 xdebug使用 xdebug使用 xdebug使用 xdebug相关 xdebug相关 mac 安装 设置代码段 snippet 代码块 有一点不好的是，只能在某个语言环境中触发为某个语言设置的代码段 教程 实例 12345678&apos;.text.html.php&apos;: # 语言类型的 scope &apos;php&apos;: # 随便 &apos;prefix&apos;: &apos;header&apos; #触发单词 &apos;body&apos;: &apos;header(&quot;Content-Type:text/html;charset=utf-8&quot;);\n&apos; #\n 换行&apos;.text.html.php&apos;: &apos;yii&apos;: &apos;prefix&apos;: &apos;vy&apos; &apos;body&apos;: &apos;&lt;?=$$&#123;1:this&#125; ;?&gt;&apos; 问题 ctrl+, 快捷键无法打开 setting ,可能是因为快捷键冲突 Atom问题与解决 打开多个窗口时，在一个窗口添加项目，项目目录变的不可见点击并会报错解决 ： 参考 注意：先保存任何未保存的作业 win系统cmd运行 atom --clear-window-state 即可]]></content>
      <categories>
        <category>工具</category>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F06%2F29%2FHello-hexo%2F</url>
    <content type="text"><![CDATA[特别声明文章md头部设置1234567891011121314---title: test #标题名称date: 2017-06-29 11:56:02 #时间tags: #创建标签 - Testing #标签名称 - begin #标签名称categories: hello hexo #分类---# 多级分类格式示例 categories: - 工具 - Atom 添加图片123456在source下创建images文件夹。![&apos;tupian&apos;](/images/my.jpg) images 是source下的文件夹也可以吧图片放在七牛进行引用。 使用详细操作请转到 hexo官方文档下面只用到一些基础的操作 第一步：先进入到博客目录 没有权限的加 sudo 1/Users/echo-ding/Documents/ding/www/github-blog 第二步：创建文章1hexo new &quot;My New Post&quot; #my new post 为文章名 也可以直接在source中创建md文档(一般用这个) 第三步：启动服务(为了先本地预览)1hexo server 简写&amp;带参数12hexo s --debug #默认以4000端口启动sudo hexo s --debug -p 80 #以80端口启动 第四部：生成文件(md转成html)1hexo generate 第五部：推送到远端1hexo deploy 如果不需要本地预览，就可以省略第三步了，直接生成、上传 代码高亮 在代码块开头后添加php表示php代码，用来高亮显示。 12345678class ClassName extends AnotherClass&#123; public function FunctionName($value='') &#123; echo "string"; &#125;&#125;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
