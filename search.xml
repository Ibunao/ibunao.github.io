<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F28%2Fphp%2FArrayAccess%2F</url>
    <content type="text"><![CDATA[让对象像数组一样操作参考 ArrayAccess接口1234567891011&lt;?phpArrayAccess &#123; // isset判断的时候自动调用 abstract public boolean offsetExists ( mixed $offset ) // 获取数组数据的时候自动调用 abstract public mixed offsetGet ( mixed $offset ) // 添加数据的时候自动调用 abstract public void offsetSet ( mixed $offset , mixed $value ) // unset的时候自动调用 abstract public void offsetUnset ( mixed $offset )&#125; 实现上面的方法，下面举个实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * Created by PhpStorm. * User: wangHan * Date: 2016/10/21 * Time: 14:07 */class Human implements ArrayAccess&#123; private $elements; public function __construct() &#123; $this-&gt;elements = [ "boy" =&gt; "male", "girl" =&gt; "female" ]; &#125; /** * isset判断的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetExists($offset) &#123; // TODO: Implement offsetExists() method. return isset($this-&gt;elements[$offset]); &#125; /** * 获取值的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetGet($offset) &#123; // TODO: Implement offsetGet() method. return $this-&gt;elements[$offset]; &#125; /** * 存放值的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetSet($offset, $value) &#123; // TODO: Implement offsetSet() method. $this-&gt;elements[$offset] = $value; &#125; /** * unset的时候调用 * @param &#123;[type]&#125; $offset key键 */ public function offsetUnset($offset) &#123; // TODO: Implement offsetUnset() method. unset($this-&gt;elements[$offset]); &#125;&#125;$human = new Human();$human['people'] = "boyAndGirl"; // 自动调用offsetSetif(isset($human['people'])) &#123; // 自动调用offsetExists echo $human['boy'];// 自动调用offsetGet echo '&lt;br /&gt;'; unset($human['boy']);// 自动调用offsetUnset var_dump($human['boy']);&#125;// // 输出结果 male null]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F28%2Fphp%2F%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator%2F</url>
    <content type="text"><![CDATA[迭代器是让对象可以像数组一样 foreach 遍历 PHP文档 Iterator接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Iterator extends Traversable &#123; //重置索引游标 abstract public void rewind ( void ) //移动当前索引游标到下一元素 abstract public void next ( void ) //判断当前索引游标指向的元素是否有效 abstract public boolean valid ( void ) //返回当前索引游标指向的元素 abstract public mixed current ( void ) //返回当前索引游标指向的键 abstract public scalar key ( void ) &#125; ``` ## 使用 Iterator 迭代器 ```phpclass myIterator implements Iterator &#123; // 记录数组的位置 private $position = 0; // 要遍历的数组 private $array = array( "firstelement", "secondelement", "lastelement", ); // foreach开始时执行一次，重置索引 function rewind() &#123; var_dump(__METHOD__); $this-&gt;position = 0; &#125; // 返回下一个索引 function next() &#123; var_dump(__METHOD__); ++$this-&gt;position; &#125; // 判断当前索引对应的值是否有效，返回false将会终止遍历 function valid() &#123; var_dump(__METHOD__); return isset($this-&gt;array[$this-&gt;position]); &#125; // 每次循环获取当前索引对应的值 function current() &#123; var_dump(__METHOD__); return $this-&gt;array[$this-&gt;position]; &#125; // 返回当前的索引 function key() &#123; var_dump(__METHOD__); return $this-&gt;position; &#125;&#125;$it = new myIterator;foreach($it as $key =&gt; $value) &#123; var_dump($key, $value); echo "\n";&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F25%2Fjs%2FJS-%E6%B5%81%E6%B0%B4%E8%B4%A6%2F</url>
    <content type="text"><![CDATA[参考阮雪峰教程 变量提升JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。请注意，变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。 12console.log(a);var a = 1; 真正运行的是下面的这段代码123var a;console.log(a);a = 1; 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 区块作用域判断类型typeoftypeof在判断数组或者对象的时候返回的都是 Object ，想要详细判断属于那个类型还要使用 instanceof12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true instanceof运算符有待详细看http://javascript.ruanyifeng.com/grammar/function.html Object.prototype.toString方法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F25%2Fjs%2FJS-%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[php-设计模式]]></title>
    <url>%2F2017%2F07%2F03%2Fphp%2Fphp-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式 工厂模式封装了类的声明过程，实例化对象不使用new声明了，可以解决 改类名需要去找到所有new此对象一个一个改的问题，通过将new对象封装在一个方法里，如果类名进行改动，可以在方法里直接改，而不影响其他地方工厂模式是一种良好的代码规范，是编写代码遵守的很好的一种习惯。使用工厂模式，可以使代码更简洁易懂，层次清晰。同时工厂模式也可以提高代码的可维护性。 第一个版本只是省略了 new 的过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849比如，我们有一些类，它们都继承自交通工具类：interface Vehicle&#123; public function drive();&#125;class Car implements Vehicle&#123; public function drive() &#123; echo '汽车靠四个轮子滚动行走。'; &#125;&#125;class Ship implements Vehicle&#123; public function drive() &#123; echo '轮船靠螺旋桨划水前进。'; &#125;&#125;class Aircraft implements Vehicle&#123; public function drive() &#123; echo '飞机靠螺旋桨和机翼的升力飞行。'; &#125;&#125;再创建一个工厂类，专门用作类的创建，：class VehicleFactory&#123; public static function build($className = null) &#123; $className = ucfirst($className); if ($className &amp;&amp; class_exists($className)) &#123; return new $className(); &#125; return null; &#125;&#125;工厂类用了一个静态方法来创建其他类，在客户端中就可以这样使用：VehicleFactory::build('Car')-&gt;drive();VehicleFactory::build('Ship')-&gt;drive();VehicleFactory::build('Aircraft')-&gt;drive();省去了每次都要new类的工作。 第二个版本 可以更换类名 123456789101112/** * 工厂类 */class Factory&#123; static function createDatabase() &#123; //这里的类名可以进行修改，而不影响其他代码 $db = new Database; return $db; &#125;&#125; 单例模式 单例模式：声明周期内，一个类只会实例化一次对象。主要用于防止多次创建数据库连接，造成资源浪费 注册器模式 创建一个注册器类，将创建的对象绑定到注册树上，之后可以在全局通过注册树类进行访问绑定过的类可以结合在工厂模式中结合使用，其实可以实现单利模式的目的，即创建一次，全局使用； 1234567891011121314151617181920212223/*** 注册树类*/class Register&#123; protected static $objects; //通过别名的方式，将对象绑定到注册树上 static function set($alias, $object) &#123; self::$objects[$alias] = $object; &#125; //通过别名获取对象 static function get($alias) &#123; return self::$objects[$alias]; &#125; //销毁 static function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125; 适配器模式 多个相同功能目的的类，通过相同的方法来实现相同的功能目的 适配器模式，可以将截然不同的函数接口封装成同一的API 实例应用举例，PHP的数据库操作有mysql、mysqli，pdo3种，可以用适配器模式统一成一致，类似的场景还有cache适配器，将memcache、redis、file等不同的缓存函数，同一成一致 实现： 定义一个定义了约定要实现的方法的接口 不同的类实现这个接口，来各自完成自己的实现相应方法的逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//定义接口interface IDatabase&#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125;//不同的数据库实现此接口 #mysqliclass MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125;#pdoclass PDO implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function close() &#123; unset($this-&gt;conn); &#125;&#125; 策略模式实现分支逻辑的处理 避免在 if else 中直接写实现的代码，将实现代码封装到不同的类(策略)中，有利于解耦，同时，也可以提高复用性 策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境 实际应用举例，加入一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告 实现和适配器模式相似： 定义一个定义了约定要实现的方法的接口 不同的策略类实现这个接口，来各自完成自己的实现相应方法的逻辑 在 if else 中调用不同的策略 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 策略接口 */interface OutputStrategy&#123; public function render($array);&#125;/** * 策略类1：返回序列化字符串 */class SerializeStrategy implements OutputStrategy&#123; public function render($array) &#123; return serialize($array); &#125;&#125;/** * 策略类2：返回JSON编码后的字符串 */class JsonStrategy implements OutputStrategy&#123; public function render($array) &#123; return json_encode($array); &#125;&#125;/** * 策略类3：直接返回数组 */class ArrayStrategy implements OutputStrategy&#123; public function render($array) &#123; return $array; &#125;&#125;/** * 环境角色类 */class Output&#123; private $outputStrategy; // 传入的参数必须是策略接口的子类或子类的实例 public function __construct(OutputStrategy $outputStrategy) &#123; $this-&gt;outputStrategy = $outputStrategy; &#125; public function renderOutput($array) &#123; return $this-&gt;outputStrategy-&gt;render($array); &#125;&#125;/** * 客户端代码 */$test = ['a', 'b', 'c'];// 需要返回数组$output = new Output(new ArrayStrategy());$data = $output-&gt;renderOutput($test);// 需要返回JSON$output = new Output(new JsonStrategy());$data = $output-&gt;renderOutput($test); 依赖倒置、控制反转在一个类中的方法需要用到某个类的对象，如果在类的方法中直接创建，就导致了紧耦合，可以到要执行方法时，再将需要的对象创建出来赋值给所需此类的对象或方法。简单的理解就是，尽量不要再类中创建另一个类，而是通过传参的方式传递进去 数据对象映射模式 类似于yii的AR模式，通过操作对象的属性和方法来完成对数据的增删改查 数据对象映射模式，将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作 123456789101112131415161718192021222324252627282930313233343536373839404142class User&#123; protected $id; protected $data; protected $db; protected $change = false; function __construct($id) &#123; $this-&gt;db = Factory::getDatabase(); $res = $this-&gt;db-&gt;query("select * from user where id = $id limit 1"); $this-&gt;data = $res-&gt;fetch_assoc(); $this-&gt;id = $id; &#125; //魔术方法获取对象不存在的属性时调用 function __get($key) &#123; if (isset($this-&gt;data[$key])) &#123; return $this-&gt;data[$key]; &#125; &#125; //魔术方法设置对象不存在的属性时调用 function __set($key, $value) &#123; $this-&gt;data[$key] = $value; $this-&gt;change = true; &#125; //析构方法，对象销毁时调用 function __destruct() &#123; if ($this-&gt;change) &#123; foreach ($this-&gt;data as $k =&gt; $v) &#123; $fields[] = "$k = '&#123;$v&#125;'"; &#125; $this-&gt;db-&gt;query("update user set " . implode(', ', $fields) . "where id = &#123;$this-&gt;id&#125; limit 1"); &#125; &#125;&#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生改变时，依赖他的对象全部会受到通知，并自动更新 场景：一个事件发生后，要执行一连串更新操作，传统的编程方式，就是在事件的代码之后直接加入处理逻辑当更新的逻辑增多之后，代码会变的难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码 观察者模式实现了低耦合，非侵入式的通知与更新机制 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445//事件产生者 抽象类EventGenerator.phpabstract class EventGenerator&#123; private $obserers = array(); //为事件添加观察者 function addObsever(Observer $observer)&#123; $this-&gt;obserers[] = $observer; &#125; //通知观察者 调用观察者响应的方法 function ontify()&#123; foreach ($this-&gt;obserers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125;//事件event.phpclass Event extends EventGenerator&#123; function trigger()&#123; echo "Event &lt;br&gt;"; $this-&gt;ontify(); &#125;&#125;//观察者接口，定义要实现的被触发的方法 Observer.phpinterface Observer&#123; function update($event_info = null);&#125;//观察者1Observer1.phpclass Observer1 implements Observer&#123; function update($event_info = null)&#123; echo "逻辑1"; &#125;&#125;…………//使用index.php$event = new Event();$event-&gt;addObsever(new Observer1());$event-&gt;addObsever(new Observer2());$event-&gt;addObsever(new Observer3());$event-&gt;trigger(); 原型模式 对与需要大量初始化的对象，多次创建比较耗费资源，即可将初始化后的对象当作原型，使用 clone 的方式创建多个不同的对象 原型模式与工厂模式作用类似,都是用来创建对象 与工厂模式的实现不同,原型模式是先创建好一个原型对象,然后通过clone原型对象来创建新的对象,这样就免去了类创建时重复的初始化操作 原型模式适用于大对象的创建,创建一个大对象需要很大的开销,如果每次new就会消耗很大,原型模式仅需内存拷贝即可 装饰器模式 扩展类的原有方法，不需要继承重写，在方法的开始和结尾增加预处理方法 装饰模式,可以动态的添加修改类的功能 一个类提供了一项功能,如果要在修改并添加额外的功能,传统的编程模式,需要写一个之类继承它,并重新实现类的方法 使用装饰模式,仅需在运行时添加一个装饰对象即可实现,可以实现最大的灵活性 实现： 定义一个装饰器接口，定义要实现的方法 创建一个对象实现装饰器的接口 在指定类中使用装饰器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//定义装饰器接口 interface DrawDecorator&#123; function beforeDraw(); function afterDraw();&#125;//创建装饰器，实现装饰器接口 class ColorDrawDecorator implements DrawDecorator&#123; protected $color; function __construct($color = 'red') &#123; $this-&gt;color = $color; &#125; function beforeDraw() &#123; echo "&lt;div style='color: &#123;$this-&gt;color&#125;;'&gt;"; &#125; function afterDraw() &#123; echo "&lt;/div&gt;"; &#125;&#125;//使用装饰器class Canvas&#123; protected $decorators = array(); //添加装饰器 function addDecorator(DrawDecorator $decorator) &#123; $this-&gt;decorators[] = $decorator; &#125; //调用方法之前先调用装饰器的方法 function beforeDraw() &#123; foreach($this-&gt;decorators as $decorator) &#123; $decorator-&gt;beforeDraw(); &#125; &#125; //调用方法之后调用装饰器的方法 function afterDraw() &#123; $decorators = array_reverse($this-&gt;decorators); foreach($decorators as $decorator) &#123; $decorator-&gt;afterDraw(); &#125; &#125; //此方法使用装饰器的方法 function draw() &#123; $this-&gt;beforeDraw(); foreach($this-&gt;data as $line) &#123; foreach($line as $char) &#123; echo $char; &#125; echo "&lt;br /&gt;\n"; &#125; $this-&gt;afterDraw(); &#125;&#125; 迭代器模式 遍历对象，迭代器实现遍历的细节与输出数据 迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。 相比传统的编程模式，迭代器模式可以隐藏遍历元素的所需操作。 实现：实现php自带的 Iterator 接口，分别实现接口5个方法spl迭代器执行顺序： rewind，将索引重置到数组第一个元素； valid，验证数据有效性； current，获取当前数据； next，将索引值向下移动； key，获取当前索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//遍历表中所有的数据//实现迭代器class AllUser implements \Iterator&#123; protected $ids; protected $data = array(); protected $index; //查询出所有用户的id function __construct() &#123; $db = Factory::getDatabase(); $result = $db-&gt;query("select id from user"); $this-&gt;ids = $result-&gt;fetch_all(MYSQLI_ASSOC); &#125; //3. 获取当前索引的值(id的记录) function current() &#123; $id = $this-&gt;ids[$this-&gt;index]['id']; return Factory::getUser($id); &#125; //4. 将索引值向下移动 function next() &#123; $this-&gt;index ++; &#125; //2. 验证当前索引是否合理 function valid() &#123; return $this-&gt;index &lt; count($this-&gt;ids); &#125; //1. 遍历开始，重置索引到第一个数组的元素 function rewind() &#123; $this-&gt;index = 0; &#125; //5. 获取当前索引 function key() &#123; return $this-&gt;index; &#125;&#125;//遍历 ,遍历到的就是 current() 返回的值$users = new AllUser;foreach ($users as $user) &#123; var_dump($user-&gt;user)&#125; AR模式遍历所有记录对象应该比这个高明，应该是开销比这个小，不用每遍历一个就请求一次mysql获取数据，有待查阅 代理模式 对于多个服务(myql主从之类的)只管正常的使用，代理类中帮助实现选用和实现具体的细节 在客户端与实体之间建立一个代理对象(proxy)，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体细节 典型的应用：mysql读写分离1234567891011121314151617181920//代理类class Proxy&#123; //获取数据时，使用从库 function getUserName($id) &#123; $db = Factory::getDatabase('slave'); $db-&gt;query("select name from user where id =$id limit 1"); &#125; //修改数据时，使用主库 function setUserName($id, $name) &#123; $db = Factory::getDatabase('master'); $db-&gt;query("update user set name = $name where id =$id limit 1"); &#125;&#125;//通过代理对象，正常的实现读写功能，而不用手动的切换库了 $proxy = new Proxy;$proxy-&gt;getUserName($id);$proxy-&gt;setUserName($id, $name); 歪麦博客(UML类图的使用，php设计模式)慕课网-php设计模式参考资料]]></content>
      <categories>
        <category>php</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化-静态化]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[ab测试工具 -n 请求的总数量 -c 并发数 -t 请求的总时间 单位秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//在并发数100的情况下，发出5000个请求，所消耗的时间 ding:github-blog echo-ding$ ab -n 5000 -c 100 http://www.yiifirst.com///在并发100的情况下，持续10秒，可以完成多少请求数//ding:github-blog echo-ding$ ab -t 10 -c 100 http://www.yiifirst.com/----------------输出-------------------//软件信息This is ApacheBench, Version 2.3 &lt;$Revision: 1796539 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org///测试进度Benchmarking www.yiifirst.com (be patient)Completed 500 requestsCompleted 1000 requestsCompleted 1500 requestsCompleted 2000 requestsCompleted 2500 requestsCompleted 3000 requestsCompleted 3500 requestsCompleted 4000 requestsCompleted 4500 requestsCompleted 5000 requestsFinished 5000 requests//服务器信息Server Software: Apache/2.4.26Server Hostname: www.yiifirst.comServer Port: 80//响应信息Document Path: /Document Length: 25938 bytes//测试结果Concurrency Level: 100 #并发级别Time taken for tests: 61.459 seconds #测试总用时Complete requests: 5000 #完成请求数量Failed requests: 0 #请求失败数Total transferred: 132882558 bytes #总的数据传输量HTML transferred: 129690000 bytes #总的数据量，响应主体Requests per second: 81.36 [#/sec] (mean) #请求数量／每秒Time per request: 1229.171 [ms] (mean) #每组请求消耗的时间Time per request: 12.292 [ms] (mean, across all concurrent requests) #平均每个请求消耗的时间Transfer rate: 2111.47 [Kbytes/sec] received #传输效率//结果的统计//最佳，最差，平均结果Connection Times (ms) min mean[+/-sd] median maxConnect: 0 2 7.7 0 120Processing: 77 1223 264.1 1219 2608Waiting: 47 1146 235.2 1166 1998Total: 78 1225 264.0 1221 2608//统计结果Percentage of the requests served within a certain time (ms) 50% 1221 66% 1310 75% 1372 80% 1413 90% 1539 95% 1658 98% 1793 //98%的请求可以在 1793ms内完成 99% 1909 100% 2608 (longest request) 静态化 页面静态化，就是将需要后段数据配合生成的页面缓存起来，下次访问将不再需要对后段的各种请求解析，直接访问存取的静态页面框架正常都带有方便的缓存设置功能方法，不需要手动写ob了 ob缓存简单操作123456789101112131415161718192021222324252627282930313233343536ob_start()开启输出缓冲 之后的任意的响应主体输出，都会存储到该缓冲区。 ob_get_content() 获取缓冲中内容 所有的响应主体都输出完毕后，需要获取到。 Ob_get_clean();// 获取后清空;之前的输出将不会在客户端输出Ob_get_flush();// 获取后刷新；之前的输出立刻输出到客户端ob_end_clean(); 关闭同时清空输出缓冲；将不会输入 file_put_contents($filename, $content); //将获取到的内容输出到文件开启 startOb_start()获取 getOb_get_contents();// 获取内容Ob_get_clean();// 获取后清空Ob_get_flush();// 获取后刷新刷新 flush将缓冲内容向下传输Ob_flush();// 直接刷新 在需要将内容立即在浏览器端显示时，通常使用！Ob_end_flush(); 刷新后关闭Ob_get_flush(); 获取后刷新即使没有刷新，脚本结束时，PHP核心会自动刷新。清空 clean清空缓存区内容Ob_clean(); 直接清空Ob_get_clean(); 获取后清空Ob_end_clean(); 清空关闭关闭 endOb_end_clean(); 清空后关闭Ob_end_flush(); 刷新后关闭。后续的输出就不会再出现在输出缓存中。 多obob缓冲区，允许开启多次每当执行一次OB_start()就会开启一次输出缓存。而对OB的操作，都是针对于当前的活跃缓存区。–最新开启的这个缓存区。 1Ob_get_level()获取当前缓存的深度。 PHP默认会开启一个输出缓冲。12php.inioutput_buffering = 4096 开启缓冲，并设置最大缓冲大小 4096byte 缓冲处理器开启缓冲时，可以制定一个函数，用于处理当缓冲内容被刷新时，处理缓存数据。 典型的处理器：ob_gzhandler();根据浏览器所能够接受的压缩类型，对缓冲数据进行压缩。 使用缓存压缩 –开启的时候加入处理器名字即可1ob_start( 'ob_gzhandler'); 程序缓存PHP默认的缓冲区。一直在，几乎不能操作。一个函数对该缓存进行操作：123flush(); #刷新程序缓存Ob_flush(); #输出ob缓冲 如果需要将数据立即在浏览器端显示时。使用 ob_flush() 和 flush() 配合使用。 12345678910// 浏览器在没有收到一定量的数据可能不给渲染// echo str_repeat('--', 1024);for ($i=0; $i &lt; 10; $i++) &#123; echo $i; //刷新ob输出缓存 ob_flush(); //刷新程序缓存 flush(); sleep(1);&#125;]]></content>
      <categories>
        <category>网站优化</category>
      </categories>
      <tags>
        <tag>静态化</tag>
        <tag>ab测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化-Mysql]]></title>
    <url>%2F2017%2F07%2F02%2Fmysql%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-Mysql%2F</url>
    <content type="text"><![CDATA[4个方向的优化 其一：设计方面。存储引擎的选择，列类型的选择 其二：功能方面。索引，查询缓存，分区。 其三：架构层面。读写分离，负载均衡。 其四：SQL层面。经验。 设计方面存储引擎的选择 存储数据的格式，方式常用的有两种，innodb 和 MyISAM 查看mysql支持的引擎情况1show engines\G MyISAM引擎 记录按照顺序插入进行存储的 12345678910USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 数据和索引分别存储 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 表压缩myisam支持压缩存储制作一张大量数据的表，利用蠕虫复制(自身复制)技术，完成大量数据；1insert into myisam_1 select null,title from myisam_1; 多次执行后查看如果文件大小没有更新，可以刷新表写入到文件1flush table myisam_1; 查看文件大小 工具压缩查找123456find / -name myisampack发现工具目录 /usr/local/Cellar/mysql/5.7.18_1/binmyisampack 打包压缩myisamchk 检测修复 进入到数据库目录中/usr/local/var/mysql/test 可以通过 find / -name *.frm 查找 执行1myisampack myisam_1 //myisam_1是带压缩的表名 最后会显示1Remember to run myisamchk -rq on compressed tables 可以看出数据文件压缩，但是索引文件出问题了，需要重建修复索引1myisamchk -rq myisam_1 修复后索引正常 压缩后为只读表，不能再进行插入操作，仅仅可以完成更快速的查询工作 表解压如果需要对压缩过的表进行修改需要进行解压同样进入到要解压的数据库目录中1myisamchk --unpack myisam_1 执行后即可,如果文件大小没变，需要进入到mysql中执行1flush table 修复表myisam新增数据时，都是在表末尾完成的插入如果存在被删除的记录。所占用的记录空间就会空下来，但是不会再存放记录。最好定时，完成修复表空间漏洞！删除数据后myisam表的大小并不会发生改变 ，需要进行修复进入到需要修复的数据库的目录中12myisamchk -rq myisam_1 #修复索引 myisamchk -r myisam_1 #修复数据 myisam 不支持行锁，支持表锁，导致并发性降低 ；提供高效的查询、插入操作；不擅长大量更新、删除业务； innodb引擎mysql默认存储引擎支持事务，行级锁定，外键 存储机制数据按照主键顺序进行排序导致innodb的表的记录与逐渐索引存在一个结构中(聚簇)插入数据时，因为要额外的执行排序工作，导致插入速度相对较慢 创建innodb表12345678910USE test; #选用数据库CREATE TABLE innodb_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = innodb CHARSET=utf8;#innodb引擎的INSERT INTO innodb_1 VALUES (23, '李牧');INSERT INTO innodb_1 VALUES (12, '王翦');INSERT INTO innodb_1 VALUES (34, '廉颇');INSERT INTO innodb_1 VALUES (15, '白起'); 查看文件 innodb_1.frm innodb的结构文件ibdata1 默认的innodb表空间文件，所有的innodb表的数据和索引都在该文件中(最新的默认为每个表分开存储)innodb_1.ibd innodb表空间文件(每个表单独存储的时候会有这个文件) 如果默认为所有的表存储在一个文件中，可以进行配置来实现每个表分开存储1show variables like 'innodb_file_per_table'; 如果值为 OFF 则为所有表存在一个文件中，进行设置更改即可1set global innodb_file_per_table = 1; innodb额外支持事务，外键约束，行级锁定擅长处理复杂数据完整性，一致性。擅长处理并发。 列类型的选择在满足需求的情况下尽可能占用小的存储空间尽可能使用整数类型整数行的运算速度最快，也可以考虑 Enum枚举 和 Set集合 类型，不过这两种也可以配合代码用数值型实现例如：存储 ipv4； varchar(15) 15+个字节可以将ip转换为int型的 int unsigned 就只需要4个字节ip转整1select inet_aton('192.168.1.234'); 整数转ip1select inet_ntoa(3232236010); 尽可能使用 not nullNull值，特殊值，mysql需要额外的存储空间存储。无论在计算，存储上都需要消耗资源。 逆范式 范式：规范的格式： 满足三范式：1NF：原子性。2NF：消除部分依赖。3NF：消除传递依赖。每张表，存储一类实体的信息。实体间通过关联字段进行联系。 但 有时需要 打破规范，来提升某种操作的效率：例如：1234567891011121314151617181920商品表：GoodsGoods_id, goods_name, cat_id分类表：categoryCat_id, cat_title,业务逻辑：分类列表分类ID，分类标题，分类下商品数量典型的实现：连接查询。Select c.cat_id, c.cat_title, count(g.goods_id) as goods_count from category as c left join goods as g On c.cat_id=g.cat_id group by c.cat_id where Condition如果 在查询分类列表时，通常需要 商品数量：则可以采用下面的设计：在分类表，增加商品数量的字段：分类表：categoryCat_id, cat_title,goods_count每当 商品 增，删，改的时候，修改相关分类的goods_count的值。但是，如果执行查询分类列表了，就不需要 连接操作：Select * from category; 优化根据具体的业务需求对表结构进行优化 功能方面索引在终端执行 select 语句的时候会显示执行时间例如：128388608 rows in set (2.79 sec)执行了2.79秒 可以通过设置索引对查询进行优化 索引就好比字典的目录，通过关键词获取记录所在位置通过使用 数据中的部分数据作为关键字，建立该关键字与数据间位置的对应关系，称之为索引。 在没有索引的情况下，定位记录，需要采用的是全表扫描，从第一条记录扫描到最后一条记录，确定要找的数据而索引的关键词是排序过的，查找的时候先在索引中进行检索，快速的定位该关键词对应的记录位置 索引的增删改查看 mysql基础 执行计划在执行sql之前，mysql会形成执行计划，内包含了当前的sql执行所采用的策略 mysql执行计划获取通过 explain select 语法1explain select * from test where id = 123456\G 123456789101112131415mysql&gt; explain select * from myisam_1 where id = 123456\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: myisam_1 partitions: NULL type: const #这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL，all为全表扫描possible_keys: PRIMARY #查询可能会使用到索引 key: PRIMARY #实际使用的索引 key_len: 4 #使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref: const rows: 1 #MYSQL认为必须检查的用来返回请求数据的行数 filtered: 100.00 Extra: NULL #关于MYSQL如何解析查询的额外信息1 row in set, 1 warning (0.00 sec) 索引使用场景条件检索 wherewhere 后的字段如果有索引是可以使用索引的 排序 order byorder by 后的字段如果有索引是可以使用索引的 联表join 关联字段联接查询是，关联字段 (on后面的条件) 可以使用索引两个表的关联字段都要创建索引 索引使用语法细节字段独立字段需要使用索引时，要求，字段独立存在于表达式的一侧。不能参与表达式运算。函数调用。例如：12where id = 123456; #字段独立where id+1 = 123455; #字段未独立 左原则like模糊查询匹配字符串，左侧必须要固定才可以使用索引。即 like abc% 复合索引创建复合索引时，在使用索引的时候左边的字段才能直接使用该索引。左边字段确定时，右边字段的索引才可以使用。 原因：复合索引的关键字顺序，先按照左边字段排序，如果左边字段相同，则按照右边字段排，以此类推。 or原则要保证 OR两侧的条件表达式中的字段都有索引可以使用，才会用到索引。 mysql自动判断当搜索的记录数比较多时，mysql可能会放弃使用索引来减少大量的随机io开销，而选择使用顺序开销来代替例如：1where empno &gt; 1121212; 如果查询的记录数太多，会放弃索引 前缀索引 可以使用 某个字段的前一部分（左边）数据，作为索引的关键字，而不是使用全部的字段内容。称之为前缀索引。字段 32 字节长度。只使用前10个长度，作为索引关键字。目的：减少 关键字的长度，索引的速度就会提升！实际中，前缀 具有 足够的标识度，才可以使用前缀索引。 例如：以 密码为例： 首先需要计算当前缀达到多长时，标识度就够了。 先计算整体的标识度 1select 总记录条数／count(distinct epassword) from emp; #计算总条数除以不重复密码的比值 计算使用不同的前缀是的标识度的值，找到最接近的即可 1select 总记录条数／count(distinct substring(epassword, 1, n)) from emp; 随着 n 的不断增大，将会越来越接近整体标识度，并且随着增大标识度将会不变，这时去不变时的最小值最为前缀长度 建立前缀索引 1alter table emp add index 'index_password' (epassword(n)); #n为计算出的长度 查询缓存mysql服务器提供的可以缓存查询结果的缓存区12345678910mysql&gt; show variables like 'query_cache_%';+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 1048576 |#缓存大小| query_cache_type | OFF |#开关| query_cache_wlock_invalidate | OFF |+------------------------------+---------+ 看出默认是开着的 设置配置变量：12set global query_cache_type = 1;#打开set global query_cache_size = 1024*1024*64;--64M 注意：一旦开启查询缓存，则只要执行的时Select操作，通常结果都会被缓存。无论客户端是否要求。 实际使用时：有些数据仅仅需要使用一次。数据很大。不希望数据被缓存。通过 SQL_NO_CACHE 语法，进行提示 MySQL 该select不需要缓存1select sql_no_cache from emp where empno = 12345; 动态数据不能缓存1select * ,now() from emp where empno=12345; 缓存是基于 select 语句的如果多打了空格或字母大小写不一样都会导致不会使用缓存 索引的状态的查看123456789101112mysql&gt; show status like 'handler_read_%';+-----------------------+----------+| Variable_name | Value |+-----------------------+----------+| Handler_read_first | 4 || Handler_read_key | 5 |#该选项值高 则证明系统高效使用了索引| Handler_read_last | 0 || Handler_read_next | 0 || Handler_read_prev | 0 |#上面的数量越高，索引利用率越高| Handler_read_rnd | 0 |#下面两项数值高的需要优化，执行全表扫面的| Handler_read_rnd_next | 27264190 |+-----------------------+----------+ 管理查询缓存12345678910111213mysql&gt; show status like 'Qcache_%';+-------------------------+---------+| Variable_name | Value |+-------------------------+---------+| Qcache_free_blocks | 1 || Qcache_free_memory | 1031832 || Qcache_hits | 0 | #查询命中数| Qcache_inserts | 0 | #缓存项数量| Qcache_lowmem_prunes | 0 || Qcache_not_cached | 30 || Qcache_queries_in_cache | 0 || Qcache_total_blocks | 1 |+-------------------------+---------+ 重置／清空缓存1reset query cache; 缓存失效如果对数据表进行更改操作(增、删、改)，则会删除该表对应的所有的缓存； 分表分区当表中的记录数很多时，采用多张表进行存储，策略就是分表策略 将大量数据按照算法分开存储，可以提高查询的效率和io开销吧 mysql服务器可以实现表的分区分区后mysql服务器将会根据分区算法和数量创建多个表，然后像普通正常使用就行 分区将一个表分成多个区(partition),将数据分散到不同的区中。就是横向分表区：就是一个物理表， 4种分区算法key、hash、range、list hash分区分区的字段要求是整数类型的如果是要对非整型字段进行hash分区，需要自己用表达式将非整形转换成整形12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by hash(id) partition 10;--或通过 birthday 划分成10个 ,要将date转换成int类型的partition by hash(YEAR(birthday)) partition 10; key分区针对任意类型字段与hash相似，只不过转成 int 的函数不是用户指定，而是由mysql指定12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by key(id) partition 10;--或通过 birthday 划分成10个partition by key(birthday) partition 10; range范围分区为每一个分区的条件指定一个范围123456789101112131415create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据年代划分partition by key(YEAR(birthday)) ( partition p_old values less than (1970), -- 小于 &lt; (value) partition p_70 values less than (1980), partition p_80 values less than (1990), partition p_90 values less than (2000), partition p_new values less than MAXVALUE, -- 最大值); list 列表值条件分区12345678910111213create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据月份划分partition by key(month(birthday)) ( partition p_chun values in (3,4), partition p_xia values in (5,6,7,8), partition p_80 values in (9,10), partition p_90 values in (11,12,1,2),); 分区管理求余类型的 hash和key分区类型减少分区将原来的10个分区减少至7个分区123alter table student coalesce partition 3;--查看 show create table student\G 增加分区123alter table add partition partitions 5;--查看 show create table student\G 条件类型的 range和list分区类型添加具体的条件分区123alter table student_list add partition( partition p_undefined values in (0);) 删除具体的条件分区1alter table student_list drop partition p_qiu; 删除分区时会导致分区内的数据同时被删除 垂直分表可以根据表的字段使用情况将一张表垂直拆分成几个表常用信息一个表，不常用信息一个表 架构优化读写分离web项目，读写比例大概 7:1，配置一台住服务器负责写，多台从服务器负责读 负载均衡将访问数据均匀的分配到不同的读服务器，nginx反向代理 mysql配置优化my.ini最大连接数1max_connections = 100; myisam键缓存1key_buffer_size = 55M innodb的缓冲池1innodb_buffer_pool_size = 107M 表文件句柄缓存可以缓存打开的table的句柄1table_cache=256 sql优化找到执行慢的sql将执行超过多久的sql记录下来 1234567mysql&gt; show variables like 'slow_query_%';+---------------------+------------------------------------+| Variable_name | Value |+---------------------+------------------------------------+| slow_query_log | OFF |#慢查询开关,默认打开| slow_query_log_file | /usr/local/var/mysql/ding-slow.log |#慢查询日志位置+---------------------+------------------------------------+ 123456mysql&gt; show variables like 'long_query_%';+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 | #记录 慢 的临界值+-----------------+-----------+ 12set global slow_query_log = 1；#开启慢查询 set long_query_time = 1; #设置记录慢查询时间临界值,超过的将都会记录下来 通过查询慢查询日志，找到需要优化的sql 插入大量数据建议将索引关闭(每条记录维护索引，相比一起维护索引，一起维护更容易)也可以现将索引删除，插入数据后再创建索引 order by null禁止排序group by的时候，默认的按照分组字段排序；执行explain计划可以看到 extra: useing filesort如果排序没有意义，可以通过添加 order by null 来禁用排序 select查询的字段尽可能是自己需要的，尽量不要使用 * 会导致数量变大，拖慢速度 单表查询一次操作仅仅操作一张表，当数据量较大的时候使用连表操作将会导致内存不够单表查询的好处 一次占用一个表，减少并发 消耗内存少 提高查询缓存的利用率缺点由于多次执行sql会多次向mysql服务器进行联接，联接响应也是影响速度的重要原因 能用join的尽量不要用子查询，mysql对子查询的支持不是太好，效率略低]]></content>
      <categories>
        <category>网站优化</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom-上手]]></title>
    <url>%2F2017%2F07%2F01%2Fatom%2FAtom%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[Atom使用教程极客学院 W3C win7环境删除Atom使用的360进行删除，删除后会发现 C:\Users\你的用户名\ 有一个隐藏的文件夹 .atom 将其删除，不删除的话重新安装atom的时候依旧会保留原来的配置及插件 插件安装完 Atom 之后自带了79个插件，基本的功能都已经可以使用了安装插件 在 setting 页面可以看到 Packages 和 Install 两个选项， Packages 查看已经安装的插件， Install 来安装插件的，可以使用 ctrl+Shift+p 进入这个页面插件 | 是否安装:———————- | :—file-icons | yespigments | nominimap | yesautocomplete-paths | noatom-ternjs | noemmet | yesdocblockr | yesvim-mode | noplatformio-ide-terminal | noatom-beautify | yesphp-debug | yeslinter-jshint | yessimplified-chinese-menu | nogoto-definition | yesHighlight Selected | yes file-icons 显示文件类型对应的图标 pigments css/less 写表示颜色时显示颜色 minimap 右边代码预览框 autocomplete-paths 补全路径 atom-ternjs 补全Js emmet 前端实用工具 教程 docblockr 代码注释 vim-mode 在 Atom 上使用 Vim Highlight Selected 选中单词所有相同的高亮 platformio-ide-terminal Atom 中集成终端 atom-beautify 美化代码段 快捷键 ctrl + alt + b ，如果弹出出错信息，可能是需要依赖一些其他插件，比如 php的 就需要装 php-cs-fixer 插件 linter-php 检查php语法错误 ，可能需要将php配置成全局 ，安装它的时候会让安装一些依赖插件，按照提示安装即可 linter-jshint 检查js语法错误 ，需要安装node，使用npm 全局安装jshint (没有配置成功，报错incompatible values for the esversion and es3 linting option ，配置文件写错了) 相关资料 jshint配置 linter-jshint配置 首先安装 node ，使用npm 全局安装jshint 在 ~ (~,表示用户目录，在windows下是C:\Users\dingran)文件下放置js配置文件 .jshintrc 配置文件 atom 配置插件，如下图勾选lint inline javaScript,可以在html或php中检查js点击 open config folder 找到配置文件，查看配置文件 config.cson 123&quot;linter-jshint&quot;: disableWhenNoJshintrcFileInPath: false lintInlineJavaScript: true php-debug xdebug调试 simplified-chinese-menu 汉化 goto-definition 文件跳转，放到方法或类名上右键 goto definition 就会出现列表，选择跳转，有快捷键，还是不用了 remote-ftp sftp上传工具插件配置：把 auto upload on save 由 aways 改为 nerver 可以在 packages-&gt;Remote-Ftp-&gt;Create …… 来生成配置文件 .ftpconfig (生成在添加到Atom项目文件根目录，上传的时候也是在根目录中寻找配置文件，限制啊)，上传只能在左边 menu 菜单来选中上传和下载 (限制啊) 12345678910111213141516171819202122&#123; &quot;protocol&quot;: &quot;sftp&quot;, # 协议 &quot;port&quot;: 22, # 端口 &quot;host&quot;: &quot;128.128.1.79&quot;, # ip &quot;user&quot;: &quot;root&quot;, # 用户 &quot;pass&quot;: &quot;******&quot;, # 密码 &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/usr/share/nginx/html/protected&quot;, # 对应的项目文件地址 &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500&#125; Markdown相关Markdown相关Markdown相关 markdown-scroll-sync 预览同步滚动tidy-markdown Markdown美化，在保存的时候或者主动调用插件时触发 python相关编辑器里运行直接运行代码 js、python 等都可以atom-runer编辑器运行代码快捷键看插件介绍win配置12345File-&gt;Config...末尾添加 runner: scopes: python: &quot;D:\\ding\\python&quot; mac配置1234Atom-&gt;Config...末尾添加 runner: python: &quot;/usr/local/bin/python3&quot; autocomplete-python自动提示 装逼神奇 activate-power-mode 颤抖吧 快捷键慕课ATOM编辑器快捷键大全 Atom 兼容sublime快捷键，同时也有自己的快捷键 12345678910111213141516171819202122Ctrl + / 启用注释 同sublimeCtrl + \ 展示隐藏目录树 同时也可以 ctrl+k ctrl+bCtrl + Alt + I 打开Chrome调试器 nbCtrl + [ 向右缩进Ctrl + ] 向左缩进Shift + Home 选定光标至行首Shift + End 选定光标至行尾Shift + PageUp 选定光标至页首Shift + PageDown 选定光标至页尾Ctrl + Home 光标到页首Ctrl + End 光标至页尾Ctrl + PageUp 切换上一个打开的标签Ctrl + PageDown 切换下一个打开的标签Ctrl + D 匹配选定下一个 同sublimeAlt + F3 匹配选定所有Ctrl + ↑ 选中行上移 和sublime有区别，sulime为ctrl+Shift+↑Ctrl + ↓ 选中行下移cmd + b 在打开的文件之间切换Ctrl + Shift + L 切换文本内容类型，例如 html/php 和sublime不同 cmd + shift + b 只搜索从上次git commit后修改或者新增的文件cmd + shift + d 复制选中代码并粘贴到选中的后面cmd + shift + u 选择文件编码格式 折叠1234Alt + Ctrl + [ 折叠Alt + Ctrl + ] 展开Alt + Ctrl + Shift + &#123; 折叠全部Alt + Ctrl + Shift + &#125; 展开全部 Markdown 写作1Ctrl + Shift + M Markdown预览 Markdown 语法补全1234567891011b **加粗**legal Copyright (c) 2017 Copyright Holder All Rights Reserved.img ![]()l []()i **code \```code\```\t - [ ] 多选按钮table | Header One | Header Two || :------------- | :------------- || Item One | Item Two | 更改快捷键 有些时候需要更改快捷键，比如快捷键冲突时 打开快捷键设置，如图搜索要改的快捷键 如 ctrl-shift-m,发现有两个，出现了冲突，这时可以自定义一个(优先级最高)将其覆盖点击需要自定义快捷键的最左边的小按钮进行复制 打开自定义文件(点击链接 your keymap file) 将复制的快捷键定义粘贴在自定义文件中，如图 备份插件备份插件教程 将配置文件上传到github 备份使用快捷键 Ctrl + Shift + P 呼出命令栏，输入 sync backup恢复备份使用快捷键 Ctrl + Shift + P 呼出命令栏，输入 sync restore 补充 获取 Gist Id 进入到github，点击你的头像会看到 Your gists,点击进去 如果没有，则需要创建一个：起个名称(用途)，写个简介 获取 Gist Id，进入创建好的 Gist 看到连接 https://gist.github.com/Ibunao/654a98d3e154348eaebba448312b0152 其中 654a98d3e154348eaebba448312b0152 就是 Gist Id 问题 ctrl+, 快捷键无法打开 setting ,可能是因为快捷键冲突 xdebug调试相关教程 atom 安装 php-debug 插件，不用配置 php开启xdebugwin上安装的是wamp所以xdebug都是有的php.ini 配置 12345678910111213141516[xdebug]zend_extension =&quot;D:/ding/wamp64/bin/php/php5.6.25/zend_ext/php_xdebug-2.4.1-5.6-vc11-x86_64.dll&quot;;xdebug.remote_enable = Offxdebug.profiler_enable = Onxdebug.profiler_enable_trigger = offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir =&quot;D:/ding/wamp64/tmp&quot;xdebug.show_local_vars=0xdebug.remote_enable=1xdebug.remote_host=127.0.0.1xdebug.remote_connect_back=1xdebug.remote_port=9000xdebug.remote_handler=dbgpxdebug.remote_mode=reqxdebug.remote_autostart=true 调试 开启debug插件 atom左下角debug按钮打开debug，没有监听到时显示的是 Listening on address:port 127.0.0.1:9000 在方法中打断点 (断点要注意了，如果打到空行，或者for循环里面将会无法监听到) 如图 浏览器中访问能进入到打断点的方法中 ，如 www.basic.com/test/test如果操作正确将会看到监听状态由 Listening on address:port 127.0.0.1:9000 改变成 Connected ,此时就可以使用debug调试了 如果没有改变监听状态，可能就是断点打错了，请检查如果atom的debug启动不起来，可能是9000端口被占用了，更改插件端口和php.ini 中的xdebug配置的端口即可 操作详解进入到断点将会输出一下内容，如下图其中，主要的有两部分内容 栈信息Stack 和变量值信息 Context其中 Stack 显示的是走到这个断点所经过的方法，如图从7到0，可以点击不同的栈来查看他的 变量值信息 Context Context 中显示的是变量信息，其中 Locals 显示的是方法中的变量值信息Superglobals 显示的是全局的信息 ，如 $_COOKLE、$_POST 等一些全局的信息User defined constants 显示的是定义的常量 操作 添加断点在代码的左边栏上点击，因为比较窄不好点击，也可以使用快捷键 alt + f9 Stop 释放掉监听 alt + f5Continue 走向下一个断点 Step Over 一步一步往下走 alt + f6Step In 进入到方法内 alt + f7Step Out 跳出方法 alt + f8 Restore Panels 恢复原始的展示窗口其他两个就是切换展示位置的 xdebug使用 xdebug使用 xdebug使用 xdebug使用 xdebug相关 xdebug相关 mac 安装 设置代码段 snippet 代码块 有一点不好的是，只能在某个语言环境中触发为某个语言设置的代码段 教程 实例 12345678&apos;.text.html.php&apos;: # 语言类型的 scope &apos;php&apos;: # 随便 &apos;prefix&apos;: &apos;header&apos; #触发单词 &apos;body&apos;: &apos;header(&quot;Content-Type:text/html;charset=utf-8&quot;);\n&apos; #\n 换行&apos;.text.html.php&apos;: &apos;yii&apos;: &apos;prefix&apos;: &apos;vy&apos; &apos;body&apos;: &apos;&lt;?=$$&#123;1:this&#125; ;?&gt;&apos; Atom问题与解决 打开多个窗口时，在一个窗口添加项目，项目目录变的不可见点击并会报错解决 ： 参考 注意：先保存任何未保存的作业 win系统cmd运行 atom --clear-window-state 即可]]></content>
      <categories>
        <category>工具</category>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-面向对象]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象操作 访问属性是通过 . 操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用 &#39;&#39; 括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong 的属性名 middle-school 不是一个有效的变量，就需要用 &#39;&#39; 括起来。访问这个属性也无法使用.操作符，必须用 [&#39;xxx&#39;] 来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 删除属性1delete xiaohong.name; // 删除name属性 如果我们要检测 xiaoming 是否拥有某一属性，可以用 in 操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果 in 判断一个属性存在，这个属性 不一定 是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为 toString 定义在 object 对象中，而所有对象最终都会在 原型链 上指向 object，所以xiaoming也拥有 toString 属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 面向对象编程面向对象编程 JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。在JavaScript中，这个概念需要改一改。 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象： 1234567var robot = &#123; name: 'Robot', height: 1.6, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;; 我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！于是我们把它改名为Student，然后创建出xiaoming： 12345678910111213var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;var xiaoming = &#123; name: '小明'&#125;;xiaoming.__proto__ = Student; 注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的： 123xiaoming.name; // '小明'xiaoming.run(); // 小明 is running...xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用： JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 如果你把 xiaoming 的原型指向其他对象： 1234567891011var Bird = &#123; fly: function () &#123; console.log(this.name + ' is flying...'); &#125;&#125;;xiaoming.__proto__ = Bird;现在xiaoming已经无法run()了，他已经变成了一只鸟：xiaoming.fly(); // 小明 is flying...在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.proto去改变一个对象的原型，并且，低版本的IE也无法使用proto。 创建对象Object.create()创建 Object.create() 方法可以传入一个 原型对象 ，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建 xiaoming： 1234567891011121314151617181920// 原型对象:var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125;var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true new 创建 理解：将定义的构造函数比作成class，创建这个构造函数的时候会同时创建一个与之对象，暂且叫做源对象(原型)，通过构造函数创建的对象的原型就是这个源对象，而构造函数中会有一个 .prototype 属性指向这个源对象(原型), 源对象(原型)也会有一个 constructor 指向构造函数。创建的对象又有 __proto__ 指向这个源对象(原型) JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 例如，创建一个Array对象： 123456789101112131415var arr = [1, 2, 3];其原型链是：arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; nullArray.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。当我们创建一个函数时：function foo() &#123; return 0;&#125;函数也是一个对象，它的原型链是：foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 构造函数 除了直接用{ … }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数： 123456function Student(name) &#123; this.name = name; this.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象： 123var xiaoming = new Student(&apos;小明&apos;);xiaoming.name; // &apos;小明&apos;xiaoming.hello(); // Hello, 小明! 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 新创建的xiaoming的原型链是： xiaoming —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：123xiaoming ↘xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; nullxiaojun ↗ 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true 看晕了吧？用一张图来表示这些乱七八糟的关系就是： 红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。 另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用proto这个非标准用法来查看。 现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。 12345678不过还有一个小问题，注意观察：xiaoming.name; // &apos;小明&apos;xiaohong.name; // &apos;小红&apos;xiaoming.hello; // function: Student.hello()xiaohong.hello; // function: Student.hello()xiaoming.hello === xiaohong.hello; // falsexiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。 xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype： 12345678910修改代码如下：function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;;用new创建基于原型的JavaScript的对象就是这么简单！ 忘记写new怎么办 如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写new怎么办？ 在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。 所以，调用构造函数千万不要忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 最后，我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样： 12345678910111213141516171819function Student(props) &#123; this.name = props.name || &apos;匿名&apos;; // 默认值为&apos;匿名&apos; this.grade = props.grade || 1; // 默认值为1&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125;这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传：var xiaoming = createStudent(&#123; name: &apos;小明&apos;&#125;);xiaoming.grade; // 1 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。 原型继承 JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 但是办法还是有的。我们先回顾Student构造函数： 1234567function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125; 以及Student的原型链： 现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent： 12345function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null 必须想办法把原型链修改为： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。 如果你想用最简单粗暴的方法这么干： 1PrimaryStudent.prototype = Student.prototype; 是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？ 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: &apos;小明&apos;, grade: 2&#125;);xiaoming.name; // &apos;小明&apos;xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 用一张图来表示新的原型链： 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 每个创建的对象，都会有一个 __proto__ 属性来指向上级原型对象，上图其实应该是有new F() 指向 F -prototype 的 如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 12345678910111213141516171819202122232425262728function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;这个inherits()函数可以复用：function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; 小结 JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。 class继承 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 我们先回顾用函数实现Student的方法： 1234567function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125; 如果用新的class关键字来编写Student，可以这样写： 123456789class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {…}这样分散的代码。 最后，创建一个Student对象代码和前面章节完全一样： 12var xiaoming = new Student(&apos;小明&apos;);xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： 12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert(&apos;I am at grade &apos; + this.grade); &#125;&#125; 注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 你一定会问，class这么好用，能不能现在就用上？ 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试 Babel 这个工具。]]></content>
      <categories>
        <category>js面向对象</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础操作]]></title>
    <url>%2F2017%2F07%2F01%2Fmysql%2Fmysql%2F</url>
    <content type="text"><![CDATA[终端使用安装数据库brew 安装 启动 连接数据库12345678910mysql -uroot -p``` **数据库存放位置** `/usr/local/var/mysql/`&gt; 可以通过 `find / -name *.frm` 查找 **创建数据库** ```sqlcreate database 数据库名 [charset 字符编码名] [collate 排序规则名]; 查看mysql中的所有字符编码名(字符集) 1show charset; 查看所有的排序规则名 1show collation; 创建数据库1CREATE DATABASE test CHARSET utf8; 修改数据库1alter database 数据库名 [charset 字符编码名] [collate 排序规则名]; 数据文件 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 退出quit 或者 exit备份数据库 mysqldump -h要备份的数据库所在的服务器 -u用户名 -p 数据库名 &gt; 完整目标文件名不需要进入mysql服务执行 1mysqldump -hlocalhost -uroot -p test &gt; /Users/echo-ding/Documents/ding/test.sql 恢复数据库1234567先把原来的删除 drop database test;#删除数据库show databases;#显示所有的数据库CREATE DATABASE test CHARSET utf8;还原 注意：先要创建还原的数据库testmysql -hlocalhost -uroot -p test &lt; /Users/echo-ding/Documents/ding/test.sql 命名规则 本身并不区分大小写，但是由于在unix、linux上的文件名区分大小写，所以数据库名字和表名、视图是区分大小写的对于可能用到系统关键词的 使用反撇号 ` 包裹 删除数据库 drop database 数据库名 查看所有数据库 show databases; 选择数据库 use 数据库名称; 表的一般操作查看当前数据库下的表1show tables; 删除表1drop 表名； 查看表结构1desc 表名; 查看表的创建语句1show create table 表名; 复制表结构1create table [if not exists] 新表名 like 原表名; 清空一张表1truncate 表名; 相当于删除一张表重新创建 添加列1alter table 表名 add 字段 类型; 更改表名1alter table oldtablename to newtablename; 创建表123456789create table [if not exists] 表名(键名 类型 , ……)``` 创建指定编码格式的表 ```sqlcreate table 表名(键名 类型 , ……) charset utf8;``` 例子： ```sqlcreate table msg(id int primary key auto_increment,title varchar(60)) charset utf8; 123456USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的 字段属性 索引 primary key (fields1[,fields2,……]) :设定主键，每个表需要(必须,只能)有一个,字段值不能重复。可以多个字段共同组成一个主键。unique key (fields1[,fields2,……]) ：用于设定该字段的值，在这个表中，不可以重复（即是唯一的）key (fields1[,fields2,……]) : 普通索引，仅仅是建立了索引fulltext key (fields1[,fields2,……]) ：全文索引，目前对中文支持不好foreign (fields1[,fields2,……]) references 其他表(fields1[,fields2,……]) : 设定外键，附加外键索引和外键约束 外键：构建两个表之间的联系，表1中的外键和另表2的主键(只要是不重复的应该都可以)对应，这样通过表1的外键就可以在表2，查出对应的数据。表1的外键和表2的主键字段的类型必须一致。 一张表可以有多个外键指向不同的表 创建索引可以加快查找的速度，但是添加的速度会变慢，但一般程序查的功能较多 . 其它 auto_increment ：用于设定一个字段值(整型的)的自动增长(自增)，而且，它设定后还必须同时设定在一个字段为一个“key”(比如:priamry key 或 unique key)not null： 用于设定一个字段的值不能为空值（null）——如果不设定，则就是可为空值；非空约束null是一种类型,比较时,只能用专门的is null 和 is not null来比较.碰到运算符,一律返回null,效率不高,影响提高索引效果 default XX值：用于设定某个字段的值，在插入数据的时候如果没有给值，就使用该默认值；comment ‘说明文字’：就是一个说明字段含义的文字，备注 修改表的字段／属性／索引1234567891011121314151617181920212223242526272829//添加字段(添加列)：alter table 表名 add 新字段名 字段类型 [附加属性];//删除字段(删除列):alter table 表名 drop 字段名;//修改字段:alter table 表名 change 旧字段名 新字段名 新字段属性;//修改表名:alter table 表名 rename 新表名;#操作索引//添加普通索引alter table xiugai_test add key (realname);//添加唯一索引alter table xiugai_test add unique key(realname);//添加主键索引alter table xiugai_test add primary key(id);//添加外键索引alter table xiugai_test add foreign key(xuehao) references students(id);//添加字段默认值alter table xiugai_test alter realname set default 0;//删除字段默认值alter table xiugai_test alter realname drop default;//删除主键alter table xiugai_test drop primary key; 如果要删除主键，需要先删除自动增长 alter table xiugai_test modify column id int unsigned not null;//删除外键alter table xiugai_test drop foreign key xuehao;//删除索引alter table xiugai_test drop key realname; 查12基本查询语句select 字段 from 表名 where 条件; ###where字句###算数运算符12+ - * / %例子：select * from 表名 where 字段名 + 100 &lt; 200;//筛选出相应列加上100依旧小于200的数据 //最好不要字段参与运算，不利于索引 比较运算符1234&gt; &gt;= &lt; &lt;= =(等于) &lt;&gt;或!=(不等于) 最常用比较运算符可以在字段中使用，返回的值是0(不满足时)或1(满足时)例如 SELECT goods_name ,cat_id&lt;8 FROM goods; //cat_id&lt;8列显示的是0或1这样方便在用sum等函数统计，如sum(cat_id&lt;8) 逻辑运算符12and(与) or(或) not(非) 例子：select * from 表 where id&lt;6 and c5&gt;1; is运算符12345只能对特殊的几个数据进行判断xx字段 is truexx字段 is falsexx字段 is nullxx字段 is not null between运算符123用法： 字段x between 值1 and 值2;值1 和 值2 范围之内的都符合条件例如： where id between 3 and 6; //id在3和6之间都符合要求 in运算符12用法： 字段x in (值1,值2,……) // not in() 相反 只要字段x的值满足括号中给定的任意的数值就算满足条件 like运算符——模糊查找123456用法：字段x like '要查找的字符'要查找的字符需要配合 % _ 才能完成模糊查询% 匹配任意长度的任意字符_ 匹配一个长度的任意字符如果要特意的匹配数据中包含 % 或 _ 的数据，需要进行转义例如：9_\% 表示匹配 9x% (x为任意字符) group by 字句 —分组 group by 根据 select 查询语句查询出的结果进行分组 用法1group by 字段名 [asc|desc]，字段名 [asc|desc] , …… 1，group by子句是用于将“前面”取得的数据，按某种标准（依据）——也就是字段——来进行分组的。分组，基本上就是，按给定字段的值，相同的值，分在相同的组中，不同的值分在不同的组中。2，asc表示分组后，按组的值的大小正序排列，desc是倒序——默认是正序，可以不写。3，一个最重要的理解（观念）：分组之后的结果，也是一行一行数据，只是每一行代表“一组” 特别注意：分组之后，结果行中的数据，都只能出现“组信息”——描述该组的“应有信息”。具体来说，对于分组查询的结果数据（select子句部分），只能出现如下几类数据：1， 分组依据本身——即该字段；2， 原始字段信息中的数字类型的最大值，最小值，平均值，总和值；max(字段)：获得该字段的在组中的最大值；min(字段)：获得该字段的在组中的最小值；avg(字段)：获得该字段的在组中的平均值；sum(字段)：获得该字段的在组中的总和值；3， 每一组中所包含的原始数据行的行数，获得方式为：count(*) 123例子：select 字段1,max(字段2) as 最大值,min(字段3) as 最小值,avg(字段4)as 平均值,sum(字段5)as 总和,count(*)as 总条数, from 表名 group by 字段1;as 用来给查询出的字段设置别名，用来表头的显示，也可以在条件部分使用别名代替原字段按照 字段1 进行分组，分别显示分组后对应字段的一组所有数据的最小值，最大值等等 如果没有使用聚合函数直接使用字段，默认显示该字段的第一个值 having字句 having条件语句和where条件语句的区别，使用的目标不一样，where是对原始数据(表数据)进行的筛选行为，而having是对group by分组后形成的数据进行的筛选(可以把group by分组后的结果当成一张表)，having能用的筛选条件只能是select子句中出现的字段 用法：1having 条件判断 例子：123select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having count(*) &gt; 2;或条件用as别名：select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having 数量 &gt; 2; //和上面的一样 order by排序子句 对查询结果进行排序 用法：1order by 字段名 [ [asc|desc] , 字段名[asc|desc] ,……]; 按照字段名进行顺序或倒序排序，多个字段名时，先按照第一个字段名排序，再按照第二个字段名进行排序…… limit 子句用法：123limit [offset,]n offset:偏移量(跳过几行) n取出的条目 offset省略相当于 limit 0,n DISTINCT关键字合并查询记过重复行合并查询字段结果的重复的行1SELECT DISTINCT mobile, nationality FROM `person`; 子查询就是通过把查询语句的值作为条件进行查询的 子查询方便，但是性能原因略低，一般也会回用，省略 执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。 union 子查询 合并两个查询的结果 用法：12345select 语句1union [distinct | all ]select语句2[order by 子句][limit 子句] ; 说明： distinct | all用于设定是否消除重复行，默认不写就是distinct，表示会消除重复行； order by子句和limit子句，是对整个联合之后的数据结果进行排序和数量限定； 这两个select语句，要求字段数量必须一致，对应字段类型最好一致； 联合查询的结果数据中，字段名以第一个select语句中的字段名为准； 第一个select语句中的字段名如果有别名，则后续的order by子句就必须使用该别名； 将两个“字段一致”的查询语句所查询到的结果以“纵向堆叠”的方式合并到一起，成为一个新的结果集。结果集的行数是两个独立select查询语句的结果行数的和例子：12 连表查询用法：1select XX1, XX2, .... from 表1 [连接方式] join 表2 [ on 连接条件] where ... 常用的两个连表查询 内连接 inner join1from 表1 inner join 表2 on 表1.字段1 = 表2.字段2 结果：是在交叉连接的结果(两表之间做全相乘的结果)中筛选出符合 on 后面条件的也是左连接和右连接的交集 左(外)连接 left [outer] join1from 表1 left [outer] join 表2 on 表1.字段1 = 表2.字段2 假设A表在左，不动。B表在A表的右侧滑动，A表和B表通过一个关系(条件)来筛选B表的行，如果符合条件，则B表取出对应的行与A表对应的行组成新的一行数据，添加到结果集中，形成的结果集可以看成一张表，设为C，形成的结果集(表c)最少的行数为左边表(表A)的行数。也可以理解为 内连接的结果添加上没有匹配上的表A的没有匹配上数据的行(右边部分填充null)此时，可以对C表进行查询操作，where ，group，having，order by，limit依旧可以使用 视图和将查询出来的数据存放到一张新表里一样，不常用。略 增1234567891011形式1：常用insert [into] 表名 [(字段1,2,3，……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //插入多行时用逗号分开形式2：replace [into] 表名[(字段1,2,……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //和insert的区别是插入的数据的主键值在表中已存在时插入的将会替换这行数据，而insert将执行失败形式3：insert [into] 表名 [(字段1,2,3，……)] select 字段1,字段2,……from 其他表表名; //插入select中查询到的数据形式4：insert [into] 表名 字段1=值表达式,字段2=值表达式,字段3=值表达式，……;形式5：load data 导入数据 加载数据文件 load data infile '完整的数据文件路径.文件格式后缀' into table 表名;可以在txt中创建，数据与数据之间需要用tab进行隔开 ，注意需要使用utf-8格式的，还有与表的字段定义的类型保持一致(数据不用加引号)，路径中的\可以用/也可以进行转义\\使用 插入数据1234INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 删1234delete from 表名 [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定]; 1.where 几乎必须，如果省略将删除所有数据2.order by 排序设定用于设定删除这些数据的时候指定的字段的顺序来删除，3.limit 用于删除数据的时候指定只删除“前面的多少行” 改12update 表名 set 字段1=新值,字段2=新值,…… [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定];和删的用法相似 列类型整数类型 名称 字节 最小值(带符号／不带符号) 最大值(带符号／不带符号) tinyint 1 -128/0 127/255 smallint 2 -32768/0 …… mediumint 3 -8388608/0 …… int 4 -2147483648/0 …… bigint 8 -9223372036854775808/0 …… 1字节(byte)有8位(bit),当显示负数的时候需要占用首位进行表示，所以表示数值的只有7位 使用形式 类型名 [M(长度)] [unsigned] [zerofill] 其中M表示“显示长度”，其需与zerofill结合使用才有效，即不够该长度的会自动左侧补0，当然如果超出也不影响。长度，就是用来设定要显示的长度位数(数字个数) unsigned表示“无符号数”，表示其中的数值是“非负”数字 如果设置了zerofill，则自动也就表示同时具备了unsigned修饰 如果设置了zerofill但没有设定长度M，则其会默认将所有数的左边补0到该类型的最大位数 小数类型 类型 名称 字节 精度 浮点型 单精度 float(m,d) 4 6-7位 双精度 double(m,d) 8 15位 定点型 decimal(m,d) 如果M&gt;D，为M+2否则为D+2 总精度65位/小数部分精度30位 m叫“精度”，代表“总位数”， d表示“标度”，代表小数位浮点型的小数，内部是二进制形式，所以很可能是非精确的，基本多有语言都有的毛病 字符串类型 类型 大小(字节) 用途 CHAR 0-255(字符) 固定长度 VARCHAR 0-65535 变化长度 TEXT 0-65535 长文本数据 enum 最多65535选项 单选类型 set 最多64选项 多选类型 char(m)类型:定长字符串，m表示设定的字符长度，存储内容和编码格式无关，其存储的时候，就是该长度——不够就会自动补空格填满；最大可设定为255，表示可存储255个 字符； varchar(m)类型：变长字符串，m表示设定的字节数长度，存储内容和编码格式有关，是可存储的最大长度，实际存储长度可以小于该长度；该类型存储的时候，还需要在字段内的最前面额外存储该字段的实际长度；最大可设定为65533，表示最大可存储65533个 字节；因为考虑因素：一行 的总的存储空间限制是65535 字节，但有考虑字符编码的问题，又会出现：如果存储的是纯英文字符，则实际最多可存储65533个字符；如果存储的是纯gbk的中文字符，则实际最多可存储的是65533/2个字符；如果存储的是纯utf8的中文字符，则实际最多可存储的是65533/3个字符； text类型：它通常用于存储“大文本”，因为其可存储65535个字节，并且， 不受行存储空间的限制；不能设置默认值 varchar和text存储结构上是有区别的，text是单独存储的，不受行存储空间限制;对于大文本的字段最好分拆成单独一个表从存储上来讲大于255的varchar可以说是转换成了text.这也是为什么varchar大于65535了会转成mediumtext 字段的额外开销 varchar 小于255byte 1byte overhead varchar 大于255byte 2byte overhead tinytext 0-255 1 byte overhead text 0-65535 byte 2 byte overhead mediumtext 0-16M 3 byte overhead longtext 0-4Gb 4byte overhead 备注 overhead是指需要几个字节用于记录该字段的实际长度。在固定的长度下 char 类型比 varchar 占用空间更少，并且由于 char 是固定长度，所以更利于搜索速度 . enum类型：用于存储若干个“可选项之一”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为单选项，实际存储数据的时候，就可以选择其中一个存入数据库。它适合于存储在网页中的“单选项”数据，比如：单选按钮，下拉列表选项值等等；形式：enum(‘单选项1’, ‘单选项2’, ‘单选项3’, ……. ); //最多65535个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 3, 4, 5, 6, …. set类型：用于存储若干个“多选项”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为多选项，实际存储数据的时候，就可以选择其中若干个选项值存入数据库。它适合于存储在网页中的“多选项”数据，比如：多选按钮；形式：set(‘多选项1’, ‘多选项2’, ‘多选项3’, ……. ); //最多64个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 4, 8, 16, …. 3表示选择类1和2 时间类型 类型 大小(字节) 范围 DATE 3 1000-01-01/9999-12-31 TIME 3 -838:59:59/838:59:59 YEAR 1 1901/2155 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 TIMESTAMP 8 1970-01-01 00:00:00/2037 年某时 timestamp和datetime基本相似timestamp额外特性：用于记录一个“当前时间”的精确的时间戳——也就是某个时刻的对应整数值；该整数值，表示，从1970年1月1日0时0分0秒开始算起到该时候所经历的秒数；而且，其有如下特征：该字段的值，会在一个表的某行数据执行insert或update的时候，自动获取该时刻的时间戳值；显示格式 YYYY-MM-DD HH:MM:SS特性:不用赋值,该列会为自己赋当前的具体时间 ，但是要添加not null属性1`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', //默认值为插入的时间 更新数据时也自动更新为当前时间 注意：作为时间日期类型的数据，如果是在代码中插入一个具体的字面数据值，则需要用单引号引起来——跟字符类型一样。 用户管理添加用户mysql中的用户数据，都存储在mysql的系统数据库“mysql”中的user表中1create user ‘用户名’@’允许登录的网络位置’ identified by ‘密码’; “允许登录的网络位置”表示，该用户，在输入正确的用户名和密码的同时，也必须在“指定”的位置来登录该服务器。位置就是网络地址，通常是ip地址；其中，localhost表示只允许在本机（本地）登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。 添加权限1grant 权限名1，权限名2，.... on 某库．某下级单位 to ‘用户名’@’允许登录的网络位置’ identified by ‘密码’ 说明： 权限名，就是上述那些单词或单词组合，比如：select，insert，delete，等等； 某下级单位，指的是，一个数据库中的下级可操作对象，比如表，视图， 2.1 举例：shuangyuan.join1, 或者shuangyuan.tab1, mysql.user 2.2 特例1：*.*表示整个系统中的所有数据库的所有下级单位； 2.3 特例2：某库名.*，表示该指定数据库的所有下级单位； identified 用于给现有的该用户改密码。如果不改密码，就可以不写； 该grant语句，还可以给“不存在的用户”进行授权，此时实际上，会同时创建该用户。如果是这种情况，则此时，identified部分就不可以省略，而是必须给出密码； 例子：1grant select,insert on test.test to 'test'@'localhost'; 权限列表： 取消权限1revoke 权限名1，权限名2，.... on 某库．某下级单位 from ‘用户名’@’允许登录的网络位置’]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom-小技巧]]></title>
    <url>%2F2017%2F07%2F01%2Fatom%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[关于代码高亮``` 后面跟上语言如 php、js等 如 1234567891011121314但是有时 `php` 在 Atom 上并不会高亮，这时在首航添加 `&lt;?php` 即可 ```php&lt;?php/****/class ClassName extends AnotherClass&#123; function __construct(argument) &#123; # code... &#125;&#125; 插件使用方法每个插件的使用方法都可以在 setting-&gt;packages 中点击插件名来进入到插件的介绍也面]]></content>
      <categories>
        <category>工具 - Atom</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-闭包]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 闭包：函数返回的值是一个函数，并且这个函数使用了父函数中的变量 注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 12345678910111213141516171819202122function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：f1(); // 16f2(); // 16f3(); // 16全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920212223242526function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9//f1、f2、f3的值function () &#123; return function () &#123; return n * n; &#125;&#125; 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写：1function (x) &#123; return x * x &#125; (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：1(function (x) &#123; return x * x &#125;) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：123(function (x) &#123; return x * x;&#125;)(3); 闭包实现私有变量 闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： 12345678910111213141516171819202122&apos;use strict&apos;;function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125;它用起来像这样：var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量 x，并且，从外部代码根本无法访问到变量 x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 闭包还可以把多参数的函数变成单参数的函数。例如，要计算 xy 可以用 Math.pow(x, y) 函数，不过考虑到经常计算 x2 或 x3 ，我们可以利用闭包创建新的函数 pow2 和 pow3：123456789101112function make_pow(n) &#123; return function (x) &#123; return Math.pow(x, n); &#125;&#125;// 创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3);pow2(5); // 25pow3(7); // 343]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-this]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-this%2F</url>
    <content type="text"><![CDATA[this 在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window对象的方法中的this指向对象，但是方法中的函数this指向的是window或undefinedthis 指向函数外层，外层如果是对象，则指向此对象，如果不是则指向 undefined 或 window 在一个方法内部，this 是一个特殊变量，它始终指向当前对象，也就是 xiaoming 这个变量。所以，this.birth 可以拿到xiaoming的birth属性。 123456789101112131415让我们拆开写：function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 如果以对象的方法形式调用，比如 xiaoming.age() ，该函数的 this 指向被调用的对象，也就是 xiaoming，如果单独调用函数，比如 getAge() ，此时，该函数的 this 指向全局对象，也就是 window。 更坑爹的是，如果这么写：12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 也是不行的！要保证 this 指向正确，必须用 obj.xxx() 的形式调用！ 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在 strict模式 下让函数的 this 指向 undefined，因此，在strict模式下，你会得到一个错误：12345678910111213'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。 有些时候，喜欢重构的你把方法重构了一下：123456789101112131415'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 修复的办法也不是没有，我们用一个that变量首先捕获this：12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用 var that = this; ，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。]]></content>
      <categories>
        <category>this</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F06%2F29%2FHello-hexo%2F</url>
    <content type="text"><![CDATA[文章md头部设置 123456789---title: test #标题名称date: 2017-06-29 11:56:02 #时间tags: #创建标签 - Testing #标签名称 - begin #标签名称categories: hello hexo #分类--- 添加图片 123456在source下创建images文件夹。![&apos;tupian&apos;](/images/my.jpg) images 是source下的文件夹也可以吧图片放在七牛进行引用。 使用 进入到目录没有权限的加 sudo 1/Users/echo-ding/Documents/ding/www/github-blog 创建文章1hexo new &quot;My New Post&quot; #my new post 为文章名 也可以直接在source中创建md文档 启动服务1hexo server 生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 写博客 写完之后直接。生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 本地测试(s 就是 server的缩写) 12hexo s --debug #默认以4000端口启动sudo hexo s --debug -p 80 #以80端口启动 代码高亮 在代码块开头后添加php表示php代码，用来高亮显示。 12345678class ClassName extends AnotherClass&#123; public function FunctionName($value='') &#123; echo "string"; &#125;&#125;]]></content>
      <categories>
        <category>hello world</category>
      </categories>
      <tags>
        <tag>begin</tag>
      </tags>
  </entry>
</search>