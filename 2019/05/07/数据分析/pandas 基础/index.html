<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/bunao.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/bunao.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/bunao.ico?v=6.4.2">


  <link rel="mask-icon" href="/images/bunao.ico?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="《利用 python 进行数据分析*第二版》 123456import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAimport sqlite3import re 基础部分数据结构Series 数据结构Series 数据结构就是列表和字典的结合体，下面看一下">
<meta name="keywords" content="pandas">
<meta property="og:type" content="article">
<meta property="og:title" content="pandas 基础">
<meta property="og:url" content="http://bunao.win/2019/05/07/数据分析/pandas 基础/index.html">
<meta property="og:site_name" content="不孬">
<meta property="og:description" content="《利用 python 进行数据分析*第二版》 123456import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAimport sqlite3import re 基础部分数据结构Series 数据结构Series 数据结构就是列表和字典的结合体，下面看一下">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-efa3dbd4b83c61ec.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-e5c671e09ecf94be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-ba8de524e08b1b6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-7e8bb217f599b4ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-c9e01844c4803a42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/7178691-6c602152c2bba658.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:updated_time" content="2019-05-07T12:21:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pandas 基础">
<meta name="twitter:description" content="《利用 python 进行数据分析*第二版》 123456import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAimport sqlite3import re 基础部分数据结构Series 数据结构Series 数据结构就是列表和字典的结合体，下面看一下">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240">






  <link rel="canonical" href="http://bunao.win/2019/05/07/数据分析/pandas 基础/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>pandas 基础 | 不孬</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4719716f509495788172dc0058a6f11e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不孬</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">less is more</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bunao.win/2019/05/07/数据分析/pandas 基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="echo-ding">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不孬">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">pandas 基础
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-07 20:20:02 / 修改时间：20:21:10" itemprop="dateCreated datePublished" datetime="2019-05-07T20:20:02+08:00">2019-05-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据分析/pandas/" itemprop="url" rel="index"><span itemprop="name">pandas</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/07/数据分析/pandas 基础/" class="leancloud_visitors" data-flag-title="pandas 基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://seancheney.gitbook.io/python-for-data-analysis-2nd/" target="_blank" rel="external">《利用 python 进行数据分析*第二版》</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</div><div class="line"><span class="keyword">import</span> sqlite3</div><div class="line"><span class="keyword">import</span> re</div></pre></td></tr></table></figure>
<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Series-数据结构"><a href="#Series-数据结构" class="headerlink" title="Series 数据结构"></a>Series 数据结构</h3><p>Series 数据结构就是列表和字典的结合体，下面看一下具体演示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建</span></div><div class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>0    4
1    7
2   -5
3    3
dtype: int64
</code></pre><a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取索引</span></div><div class="line">obj.index</div></pre></td></tr></table></figure>
<pre><code>RangeIndex(start=0, stop=4, step=1)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取值</span></div><div class="line">obj.values</div></pre></td></tr></table></figure>
<pre><code>array([ 4,  7, -5,  3], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建的同时制定索引</span></div><div class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</div><div class="line">obj2</div></pre></td></tr></table></figure>
<pre><code>d    4
b    7
a   -5
c    3
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj2.index</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;d&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;], dtype=&apos;object&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj2.values</div></pre></td></tr></table></figure>
<pre><code>array([ 4,  7, -5,  3], dtype=int64)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 通过字典进行创建</span></div><div class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</div><div class="line">obj3 = pd.Series(sdata)</div><div class="line">obj3</div></pre></td></tr></table></figure>
<pre><code>Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64
</code></pre><p>可以传入排好序的字典的键以改变顺序<br>sdata 中跟 states 索引相匹配的那3个值会被找出来并放到相应的位置上，但由于”California”所对应的 sdata 值找不到，所以其结果就为 NaN（即“非数字”（not a number），在 pandas 中，它用于表示缺失或 NA 值）。因为‘Utah’不在 states 中，它被从结果中除去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</div><div class="line">obj4 = pd.Series(sdata, index=states)</div><div class="line">obj4</div></pre></td></tr></table></figure>
<pre><code>California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 判断索引是否存在</span></div><div class="line"><span class="string">'ding'</span> <span class="keyword">in</span> obj4</div></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'Ohio'</span> <span class="keyword">in</span> obj4</div></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>Series 对象本身及其索引都有一个 name 属性，该属性跟pandas其他的关键功能关系非常密切：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obj4.name = <span class="string">'population'</span></div><div class="line">obj4.index.name = <span class="string">'state'</span></div><div class="line">obj4</div></pre></td></tr></table></figure>
<pre><code>state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
</code></pre><p>Series 的索引可以通过赋值的方式就地修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj4.index = [<span class="string">'Bob'</span>, <span class="string">'Steve'</span>, <span class="string">'Jeff'</span>, <span class="string">'Ryan'</span>]</div><div class="line">obj4</div></pre></td></tr></table></figure>
<pre><code>Bob          NaN
Steve    35000.0
Jeff     16000.0
Ryan     71000.0
Name: population, dtype: float64
</code></pre><h3 id="DataFrame-数据结构"><a href="#DataFrame-数据结构" class="headerlink" title="DataFrame 数据结构"></a>DataFrame 数据结构</h3><p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<p>columns 相当于 sql 中的字段， index 相当于 sql 中的索引</p>
<p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</div><div class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</div><div class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</div><div class="line">frame = pd.DataFrame(data)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>state</th><br>      <th>year</th><br>      <th>pop</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Ohio</td><br>      <td>2000</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Ohio</td><br>      <td>2001</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Ohio</td><br>      <td>2002</td><br>      <td>3.6</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Nevada</td><br>      <td>2001</td><br>      <td>2.4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>Nevada</td><br>      <td>2002</td><br>      <td>2.9</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>Nevada</td><br>      <td>2003</td><br>      <td>3.2</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 读取前 5 行，数据量大的时候非常有用</span></div><div class="line">frame.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>state</th><br>      <th>year</th><br>      <th>pop</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Ohio</td><br>      <td>2000</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Ohio</td><br>      <td>2001</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Ohio</td><br>      <td>2002</td><br>      <td>3.6</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Nevada</td><br>      <td>2001</td><br>      <td>2.4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>Nevada</td><br>      <td>2002</td><br>      <td>2.9</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 制定列顺序</span></div><div class="line">pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 同时制定 列名 和 索引名</span></div><div class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">'six'</span>])</div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>      <th>debt</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>four</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>five</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>six</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取 列名</span></div><div class="line">frame2.columns</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;year&apos;, &apos;state&apos;, &apos;pop&apos;, &apos;debt&apos;], dtype=&apos;object&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取某一列</span></div><div class="line">frame2[<span class="string">'state'</span>]</div></pre></td></tr></table></figure>
<pre><code>one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame2.state</div></pre></td></tr></table></figure>
<pre><code>one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 选取某一行</span></div><div class="line">frame2.loc[<span class="string">'one'</span>]</div></pre></td></tr></table></figure>
<pre><code>year     2000
state    Ohio
pop       1.5
debt      NaN
Name: one, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 赋值</span></div><div class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>      <th>debt</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>      <td>16.5</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>      <td>16.5</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>      <td>16.5</td><br>    </tr><br>    <tr><br>      <th>four</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>      <td>16.5</td><br>    </tr><br>    <tr><br>      <th>five</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>      <td>16.5</td><br>    </tr><br>    <tr><br>      <th>six</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>      <td>16.5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</div><div class="line">frame2[<span class="string">'debt'</span>] = val</div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>      <th>debt</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>      <td>-1.2</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>four</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>      <td>-1.5</td><br>    </tr><br>    <tr><br>      <th>five</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>      <td>-1.7</td><br>    </tr><br>    <tr><br>      <th>six</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个新列</span></div><div class="line">frame2[<span class="string">'test'</span>] = frame2.state == <span class="string">'Ohio'</span></div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>      <th>debt</th><br>      <th>test</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>      <td>NaN</td><br>      <td>True</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>      <td>-1.2</td><br>      <td>True</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>      <td>NaN</td><br>      <td>True</td><br>    </tr><br>    <tr><br>      <th>four</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>      <td>-1.5</td><br>      <td>False</td><br>    </tr><br>    <tr><br>      <th>five</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>      <td>-1.7</td><br>      <td>False</td><br>    </tr><br>    <tr><br>      <th>six</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>      <td>NaN</td><br>      <td>False</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除一列</span></div><div class="line"><span class="keyword">del</span> frame2[<span class="string">'test'</span>]</div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>state</th><br>      <th>pop</th><br>      <th>debt</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>2000</td><br>      <td>Ohio</td><br>      <td>1.5</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>2001</td><br>      <td>Ohio</td><br>      <td>1.7</td><br>      <td>-1.2</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2002</td><br>      <td>Ohio</td><br>      <td>3.6</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>four</th><br>      <td>2001</td><br>      <td>Nevada</td><br>      <td>2.4</td><br>      <td>-1.5</td><br>    </tr><br>    <tr><br>      <th>five</th><br>      <td>2002</td><br>      <td>Nevada</td><br>      <td>2.9</td><br>      <td>-1.7</td><br>    </tr><br>    <tr><br>      <th>six</th><br>      <td>2003</td><br>      <td>Nevada</td><br>      <td>3.2</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>另一种常见的数据形式是嵌套字典：<br>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = pd.DataFrame(pop)</div><div class="line">frame3</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Nevada</th><br>      <th>Ohio</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2000</th><br>      <td>NaN</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>2001</th><br>      <td>2.4</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2002</th><br>      <td>2.9</td><br>      <td>3.6</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果设置了 DataFrame 的 index 和 columns 的 name 属性，则这些信息也会被显示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame3.index.name = <span class="string">'year'</span>; frame3.columns.name = <span class="string">'state'</span></div><div class="line">frame3</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>state</th><br>      <th>Nevada</th><br>      <th>Ohio</th><br>    </tr><br>    <tr><br>      <th>year</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2000</th><br>      <td>NaN</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>2001</th><br>      <td>2.4</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2002</th><br>      <td>2.9</td><br>      <td>3.6</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取值 </span></div><div class="line">frame3.values</div></pre></td></tr></table></figure>
<pre><code>array([[nan, 1.5],
       [2.4, 1.7],
       [2.9, 3.6]])
</code></pre><h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：<br>DataFrame 的 index 和 columns 都是索引对象  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">obj.index</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], dtype=&apos;object&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame3</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>state</th><br>      <th>Nevada</th><br>      <th>Ohio</th><br>    </tr><br>    <tr><br>      <th>year</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2000</th><br>      <td>NaN</td><br>      <td>1.5</td><br>    </tr><br>    <tr><br>      <th>2001</th><br>      <td>2.4</td><br>      <td>1.7</td><br>    </tr><br>    <tr><br>      <th>2002</th><br>      <td>2.9</td><br>      <td>3.6</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame3.columns</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;Nevada&apos;, &apos;Ohio&apos;], dtype=&apos;object&apos;, name=&apos;state&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame3.index</div></pre></td></tr></table></figure>
<pre><code>Int64Index([2000, 2001, 2002], dtype=&apos;int64&apos;, name=&apos;year&apos;)
</code></pre><p>与python的集合不同，pandas的Index可以包含重复的标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dup_labels = pd.Index([<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>])</div><div class="line">dup_labels</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;foo&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;bar&apos;], dtype=&apos;object&apos;)
</code></pre><p>Index 索引对象有一些方法和属性，不怎么用 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_labels.unique()</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;foo&apos;, &apos;bar&apos;], dtype=&apos;object&apos;)
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Index 方法和属性"></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="重新索引-reindex"><a href="#重新索引-reindex" class="headerlink" title="重新索引 reindex"></a>重新索引 reindex</h3><p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
</code></pre><p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj2 = obj.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">obj2</div></pre></td></tr></table></figure>
<pre><code>a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64
</code></pre><p>重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用 ffill 可以实现前向值填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj3 = pd.Series([<span class="string">'blue'</span>, <span class="string">'purple'</span>, <span class="string">'yellow'</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</div><div class="line">obj3</div></pre></td></tr></table></figure>
<pre><code>0      blue
2    purple
4    yellow
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj3.reindex(range(<span class="number">6</span>), method=<span class="string">'ffill'</span>)</div></pre></td></tr></table></figure>
<pre><code>0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object
</code></pre><p>借助 DataFrame，reindex 可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], columns=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'California'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Texas</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重建行索引  </span></div><div class="line">frame.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Texas</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重建列索引</span></div><div class="line">frame.reindex(columns = [<span class="string">'Texas'</span>, <span class="string">'Utah'</span>, <span class="string">'California'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Texas</th><br>      <th>Utah</th><br>      <th>California</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1</td><br>      <td>NaN</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>NaN</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>7</td><br>      <td>NaN</td><br>      <td>8</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>reindex函数的各参数及说明<br><img src="http://upload-images.jianshu.io/upload_images/7178691-efa3dbd4b83c61ec.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="丢弃指定轴上的项-drop"><a href="#丢弃指定轴上的项-drop" class="headerlink" title="丢弃指定轴上的项 drop"></a>丢弃指定轴上的项 drop</h3><p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.drop(<span class="string">'c'</span>)</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</code></pre><p>对于DataFrame，可以删除任意轴上的索引值。 drop 默认会从行标签（axis 0）删除值(删除行), 通过传递 <code>axis=1</code> 或 <code>axis=&#39;columns&#39;</code> 可以删除列的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.drop([<span class="string">'Ohio'</span>, <span class="string">'Utah'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.drop(<span class="string">'c'</span>, inplace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</code></pre><h3 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h3><p>Series索引的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[<span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<pre><code>0.0
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<pre><code>0.0
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[:<span class="number">2</span>]</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</span></div><div class="line">obj[<span class="string">'a'</span>:<span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
c    2.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]]</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
d    3.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[[<span class="number">1</span>, <span class="number">3</span>]]</div></pre></td></tr></table></figure>
<pre><code>b    1.0
d    3.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[obj &lt; <span class="number">2</span>]</div></pre></td></tr></table></figure>
<pre><code>a    0.0
b    1.0
dtype: float64
</code></pre><p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：<br>用切片 <code>[:]</code> 切的是行  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'two'</span>]</div></pre></td></tr></table></figure>
<pre><code>Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[[<span class="string">'three'</span>, <span class="string">'one'</span>]]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>three</th><br>      <th>one</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>2</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>6</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>10</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>14</td><br>      <td>12</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 切行</span></div><div class="line">data[<span class="string">"Ohio"</span>:<span class="string">"Utah"</span>]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[:<span class="number">2</span>]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="用-loc-和-iloc-进行选取"><a href="#用-loc-和-iloc-进行选取" class="headerlink" title="用 loc 和 iloc 进行选取"></a>用 loc 和 iloc 进行选取</h3><p>特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 通过标签进行选择</span></div><div class="line">data.loc[<span class="string">'Ohio'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]]</div></pre></td></tr></table></figure>
<pre><code>one    0
two    1
Name: Ohio, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.loc[<span class="string">'Ohio'</span>:<span class="string">'Utah'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>]]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 通过 整数 进行选择</span></div><div class="line">data.iloc[<span class="number">2</span>, [<span class="number">0</span>, <span class="number">1</span>]]</div></pre></td></tr></table></figure>
<pre><code>one    8
two    9
Name: Utah, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.iloc[<span class="number">2</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>]]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>12</td><br>      <td>13</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但这会引起歧义，为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</div><div class="line">ser</div></pre></td></tr></table></figure>
<pre><code>0    0.0
1    1.0
2    2.0
dtype: float64
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 下面这个将会出错，因为整数索引中没有 -1 这个值, 不知道基于位置索引还是整数索引，导致歧义</div><div class="line">ser[-1]</div></pre></td></tr></table></figure>
<p>对于非整数索引，不会产生歧义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ser2 = pd.Series(np.arange(<span class="number">3.</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">ser2[<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<pre><code>2.0
</code></pre><h3 id="算术运算和数据对齐、在算术方法中填充值"><a href="#算术运算和数据对齐、在算术方法中填充值" class="headerlink" title="算术运算和数据对齐、在算术方法中填充值"></a>算术运算和数据对齐、在算术方法中填充值</h3><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1 = pd.Series([<span class="number">7.3</span>, <span class="number">-2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line">s2 = pd.Series([<span class="number">-2.1</span>, <span class="number">3.6</span>, <span class="number">-1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>])</div><div class="line">s1</div></pre></td></tr></table></figure>
<pre><code>a    7.3
c   -2.5
d    3.4
e    1.5
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2</div></pre></td></tr></table></figure>
<pre><code>a   -2.1
c    3.6
e   -1.5
f    4.0
g    3.1
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 索引对齐相加，自动的数据对齐操作在不重叠的索引处引入了NA值</span></div><div class="line">s1 + s2</div></pre></td></tr></table></figure>
<pre><code>a    5.2
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64
</code></pre><p>对于DataFrame，对齐操作会同时发生在行和列上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=list(<span class="string">'bcd'</span>), index=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Colorado'</span>])</div><div class="line">df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</div><div class="line">df1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df1 + df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>NaN</td><br>      <td>6.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>9.0</td><br>      <td>NaN</td><br>      <td>12.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df1.add(df2, fill_value=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Colorado</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>1.0</td><br>      <td>6.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>NaN</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>9.0</td><br>      <td>4.0</td><br>      <td>12.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>NaN</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>其他算数方法：<br>以字母r开头，它会翻转参数。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test1 = Series([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</div><div class="line">test2 = Series([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</div><div class="line">test1.div(test2)</div></pre></td></tr></table></figure>
<pre><code>0    0.5
1    0.5
2    0.5
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test1.rdiv(test2)</div></pre></td></tr></table></figure>
<pre><code>0    2.0
1    2.0
2    2.0
dtype: float64
</code></pre><h3 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h3><p>DataFrame和Series之间的运算,默认是横向进行广播的，如果需要在列上进行广播，就必须使用算数方法计算指定 <code>axis=&#39;index&#39;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">series = frame.iloc[<span class="number">0</span>]</div><div class="line">series</div></pre></td></tr></table></figure>
<pre><code>b    0.0
d    1.0
e    2.0
Name: Utah, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 行上进行广播计算</span></div><div class="line">frame + series</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>2.0</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>3.0</td><br>      <td>5.0</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>6.0</td><br>      <td>8.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>9.0</td><br>      <td>11.0</td><br>      <td>13.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列上进行广播计算 , 这里出现了问题，因为计算会根据索引进行匹配导致的</span></div><div class="line">frame.add(series, axis = <span class="string">'index'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>Utah</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># series2 = frame['b']</span></div><div class="line">series2 = frame.loc[:, <span class="string">'b'</span>]</div><div class="line">series2</div></pre></td></tr></table></figure>
<pre><code>Utah      0.0
Ohio      3.0
Texas     6.0
Oregon    9.0
Name: b, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.add(series2, axis = <span class="string">'index'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>6.0</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>12.0</td><br>      <td>13.0</td><br>      <td>14.0</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>18.0</td><br>      <td>19.0</td><br>      <td>20.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h3><p>将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>), index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>-0.618453</td><br>      <td>0.743194</td><br>      <td>-1.467120</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>0.272335</td><br>      <td>0.542511</td><br>      <td>-0.458843</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>-0.762976</td><br>      <td>0.330646</td><br>      <td>0.988022</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>-0.207557</td><br>      <td>0.425898</td><br>      <td>0.783251</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</div><div class="line"><span class="comment"># 没一列的最大值减去最小值</span></div><div class="line">frame.apply(f)</div></pre></td></tr></table></figure>
<pre><code>b    1.035311
d    0.412548
e    2.455142
dtype: float64
</code></pre><p>如果传递 <code>axis=&#39;columns&#39;</code> 到 apply ，这个函数会在每行执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.apply(f, axis=<span class="string">'columns'</span>)</div></pre></td></tr></table></figure>
<pre><code>Utah      2.210314
Ohio      1.001354
Texas     1.750998
Oregon    0.990809
dtype: float64
</code></pre><p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</div><div class="line">frame.apply(f1)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>min</th><br>      <td>-0.762976</td><br>      <td>0.330646</td><br>      <td>-1.467120</td><br>    </tr><br>    <tr><br>      <th>max</th><br>      <td>0.272335</td><br>      <td>0.743194</td><br>      <td>0.988022</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</div><div class="line">frame.applymap(format)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Utah</th><br>      <td>-0.62</td><br>      <td>0.74</td><br>      <td>-1.47</td><br>    </tr><br>    <tr><br>      <th>Ohio</th><br>      <td>0.27</td><br>      <td>0.54</td><br>      <td>-0.46</td><br>    </tr><br>    <tr><br>      <th>Texas</th><br>      <td>-0.76</td><br>      <td>0.33</td><br>      <td>0.99</td><br>    </tr><br>    <tr><br>      <th>Oregon</th><br>      <td>-0.21</td><br>      <td>0.43</td><br>      <td>0.78</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>Series 有一个用于应用元素级函数的 map 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">series = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">series.map(format)</div></pre></td></tr></table></figure>
<pre><code>0    1.00
1    2.00
2    3.00
dtype: object
</code></pre><h3 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h3><p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用 sort_index 方法，它将返回一个已排序的新对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>d    0
a    1
b    2
c    3
dtype: int64
</code></pre><h4 id="按照索引排序-sort-index"><a href="#按照索引排序-sort-index" class="headerlink" title="按照索引排序 sort_index"></a>按照索引排序 sort_index</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.sort_index()</div></pre></td></tr></table></figure>
<pre><code>a    1
b    2
c    3
d    0
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)), index=[<span class="string">'three'</span>, <span class="string">'one'</span>], columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>d</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>three</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>one</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 按照 0 轴排序</span></div><div class="line">frame.sort_index()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>d</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 按照 1 轴排序</span></div><div class="line">frame.sort_index(axis = <span class="number">1</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>three</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>one</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>数据默认是按升序排序的，但也可以降序排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>d</th><br>      <th>c</th><br>      <th>b</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>three</th><br>      <td>0</td><br>      <td>3</td><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>one</th><br>      <td>4</td><br>      <td>7</td><br>      <td>6</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<h4 id="按照值排序-sort-values"><a href="#按照值排序-sort-values" class="headerlink" title="按照值排序 sort_values"></a>按照值排序 sort_values</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>d    0
a    1
b    2
c    3
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>])</div><div class="line">obj.sort_values()</div></pre></td></tr></table></figure>
<pre><code>2   -3
3    2
0    4
1    7
dtype: int64
</code></pre><p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给 sort_values 的 by 选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>4</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>7</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.sort_values(by=<span class="string">'b'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>-3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>4</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>7</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.sort_values(by=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>-3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>4</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>7</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>0    7
1   -5
2    7
3    4
4    2
5    0
6    4
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.rank()</div></pre></td></tr></table></figure>
<pre><code>0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64
</code></pre><p>也可以根据值在原数据中出现的顺序给出排名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.rank(method=<span class="string">'first'</span>)</div></pre></td></tr></table></figure>
<pre><code>0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64
</code></pre><p>你也可以按降序进行排名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.rank(ascending=<span class="keyword">False</span>, method=<span class="string">'first'</span>)</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    7.0
2    2.0
3    3.0
4    5.0
5    6.0
6    4.0
dtype: float64
</code></pre><p>rank 方法在 DataFrame 可以在行或列上计算排名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>a</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>4.3</td><br>      <td>0</td><br>      <td>-2.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>7.0</td><br>      <td>1</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-3.0</td><br>      <td>0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2.0</td><br>      <td>1</td><br>      <td>-2.5</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.rank(axis=<span class="string">'columns'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>a</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>3.0</td><br>      <td>2.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>3.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3.0</td><br>      <td>2.0</td><br>      <td>1.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>排名时用于破坏平级关系的方法<br><img src="http://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h3><p>重复的标签会导致获取数据是数据结构复杂，不建议使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>a    0
a    1
b    2
b    3
c    4
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.index.is_unique</div></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[<span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<pre><code>a    0
a    1
dtype: int64
</code></pre><h2 id="汇总和计算描述统计"><a href="#汇总和计算描述统计" class="headerlink" title="汇总和计算描述统计"></a>汇总和计算描述统计</h2><p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, <span class="number">-4.5</span>], [np.nan, np.nan], [<span class="number">0.75</span>, <span class="number">-1.3</span>]], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.40</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>7.10</td><br>      <td>-4.5</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>0.75</td><br>      <td>-1.3</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 和 Numpy 不同的是，nan将会忽略掉继续进行计算</span></div><div class="line">df.sum()</div></pre></td></tr></table></figure>
<pre><code>one    9.25
two   -5.80
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在 1 周方向计算</span></div><div class="line">df.sum(axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>a    1.40
b    2.60
c    0.00
d   -0.55
dtype: float64
</code></pre><p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.sum(axis=<span class="number">1</span>, skipna = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<pre><code>a     NaN
b    2.60
c     NaN
d   -0.55
dtype: float64
</code></pre><p>所有与描述统计相关的方法<br><img src="http://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h3><p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自 Yahoo!Finance 的股票价格和成交量，使用的是 pandas-datareader 包（可以用conda或pip安装）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install pandas-datareader</div></pre></td></tr></table></figure></p>
<p>使用pandas_datareader模块下载了一些股票数据：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> web</div><div class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker)</div><div class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'MSFT'</span>, <span class="string">'GOOG'</span>]&#125;</div><div class="line"></div><div class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">'Adj Close'</span>]</div><div class="line">                     <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</div><div class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">'Volume'</span>]</div><div class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">returns = price.pct_change()</div><div class="line">returns.tail()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>      <th>GOOG</th><br>    </tr><br>    <tr><br>      <th>Date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2019-04-11</th><br>      <td>-0.008324</td><br>      <td>0.005314</td><br>      <td>0.001165</td><br>      <td>0.002046</td><br>    </tr><br>    <tr><br>      <th>2019-04-12</th><br>      <td>-0.000402</td><br>      <td>0.003964</td><br>      <td>0.005152</td><br>      <td>0.010999</td><br>    </tr><br>    <tr><br>      <th>2019-04-15</th><br>      <td>0.001810</td><br>      <td>-0.003118</td><br>      <td>0.000827</td><br>      <td>0.002652</td><br>    </tr><br>    <tr><br>      <th>2019-04-16</th><br>      <td>0.000100</td><br>      <td>0.008617</td><br>      <td>-0.002313</td><br>      <td>0.004938</td><br>    </tr><br>    <tr><br>      <th>2019-04-17</th><br>      <td>0.019473</td><br>      <td>-0.041546</td><br>      <td>0.008280</td><br>      <td>0.007505</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>Series 的 corr 方法用于计算两个 Series 中重叠的、非NA的、按索引对齐的值的相关系数。与此类似， cov 用于计算协方差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns[<span class="string">'MSFT'</span>].corr(returns[<span class="string">'IBM'</span>])</div></pre></td></tr></table></figure>
<pre><code>0.4865732693083368
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns[<span class="string">'MSFT'</span>].cov(returns[<span class="string">'IBM'</span>])</div></pre></td></tr></table></figure>
<pre><code>8.677797505286974e-05
</code></pre><p>DataFrame 的 corr 和 cov 方法将以 DataFrame 的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns.corr()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>      <th>GOOG</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>AAPL</th><br>      <td>1.000000</td><br>      <td>0.370756</td><br>      <td>0.452098</td><br>      <td>0.458110</td><br>    </tr><br>    <tr><br>      <th>IBM</th><br>      <td>0.370756</td><br>      <td>1.000000</td><br>      <td>0.486573</td><br>      <td>0.407424</td><br>    </tr><br>    <tr><br>      <th>MSFT</th><br>      <td>0.452098</td><br>      <td>0.486573</td><br>      <td>1.000000</td><br>      <td>0.537616</td><br>    </tr><br>    <tr><br>      <th>GOOG</th><br>      <td>0.458110</td><br>      <td>0.407424</td><br>      <td>0.537616</td><br>      <td>1.000000</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns.cov()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>      <th>GOOG</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>AAPL</th><br>      <td>0.000269</td><br>      <td>0.000075</td><br>      <td>0.000107</td><br>      <td>0.000116</td><br>    </tr><br>    <tr><br>      <th>IBM</th><br>      <td>0.000075</td><br>      <td>0.000152</td><br>      <td>0.000087</td><br>      <td>0.000077</td><br>    </tr><br>    <tr><br>      <th>MSFT</th><br>      <td>0.000107</td><br>      <td>0.000087</td><br>      <td>0.000209</td><br>      <td>0.000120</td><br>    </tr><br>    <tr><br>      <th>GOOG</th><br>      <td>0.000116</td><br>      <td>0.000077</td><br>      <td>0.000120</td><br>      <td>0.000236</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns.corrwith(returns.IBM)</div></pre></td></tr></table></figure>
<pre><code>AAPL    0.370756
IBM     1.000000
MSFT    0.486573
GOOG    0.407424
dtype: float64
</code></pre><p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">volume.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>IBM</th><br>      <th>MSFT</th><br>      <th>GOOG</th><br>    </tr><br>    <tr><br>      <th>Date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2009-12-31</th><br>      <td>88102700.0</td><br>      <td>4223400.0</td><br>      <td>31929700.0</td><br>      <td>2455400.0</td><br>    </tr><br>    <tr><br>      <th>2010-01-04</th><br>      <td>123432400.0</td><br>      <td>6155300.0</td><br>      <td>38409100.0</td><br>      <td>3937800.0</td><br>    </tr><br>    <tr><br>      <th>2010-01-05</th><br>      <td>150476200.0</td><br>      <td>6841400.0</td><br>      <td>49749600.0</td><br>      <td>6048500.0</td><br>    </tr><br>    <tr><br>      <th>2010-01-06</th><br>      <td>138040000.0</td><br>      <td>5605300.0</td><br>      <td>58182400.0</td><br>      <td>8009000.0</td><br>    </tr><br>    <tr><br>      <th>2010-01-07</th><br>      <td>119282800.0</td><br>      <td>5840600.0</td><br>      <td>50559700.0</td><br>      <td>12912000.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns.corrwith(volume)</div></pre></td></tr></table></figure>
<pre><code>AAPL   -0.061663
IBM    -0.156416
MSFT   -0.089665
GOOG   -0.018289
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returns.corrwith(returns)</div></pre></td></tr></table></figure>
<pre><code>AAPL    1.0
IBM     1.0
MSFT    1.0
GOOG    1.0
dtype: float64
</code></pre><blockquote>
<p>传入 <code>axis=&#39;columns&#39;</code> 即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
</blockquote>
<h3 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h3><p>unique 可以得到Series中的唯一值数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</div><div class="line">obj.unique()</div></pre></td></tr></table></figure>
<pre><code>array([&apos;c&apos;, &apos;a&apos;, &apos;d&apos;, &apos;b&apos;], dtype=object)
</code></pre><p>value_counts 用于计算一个 Series 中各值出现的频率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.value_counts()</div></pre></td></tr></table></figure>
<pre><code>c    3
a    3
b    2
d    1
dtype: int64
</code></pre><p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.value_counts(obj.values, sort=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<pre><code>b    2
d    1
a    3
c    3
dtype: int64
</code></pre><p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj</div></pre></td></tr></table></figure>
<pre><code>0    c
1    a
2    d
3    a
4    a
5    b
6    b
7    c
8    c
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line">mask</div></pre></td></tr></table></figure>
<pre><code>0     True
1    False
2    False
3    False
4    False
5     True
6     True
7     True
8     True
dtype: bool
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj[mask]</div></pre></td></tr></table></figure>
<pre><code>0    c
5    b
6    b
7    c
8    c
dtype: object
</code></pre><h1 id="数据加载、存储与文件格式"><a href="#数据加载、存储与文件格式" class="headerlink" title="数据加载、存储与文件格式"></a>数据加载、存储与文件格式</h1><h2 id="读写文本格式的数据"><a href="#读写文本格式的数据" class="headerlink" title="读写文本格式的数据"></a>读写文本格式的数据</h2><p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。表6-1对它们进行了总结，其中read_csv和read_table可能会是你今后用得最多的。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="">  </p>
<p>其中一些函数，比如pandas.read_csv，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如HDF5、Feather和msgpack，会在格式中存储数据类型。</p>
<h3 id="读取-csv-文件"><a href="#读取-csv-文件" class="headerlink" title="读取 csv 文件"></a>读取 csv 文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/ex1.csv</div></pre></td></tr></table></figure>
<pre><code>a,b,c,d,message
1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo
</code></pre><p>由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = pd.read_csv(<span class="string">'data/examples/ex1.csv'</span>)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>我们还可以使用read_table，并指定分隔符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_table(<span class="string">'data/examples/ex1.csv'</span>, sep = <span class="string">','</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>并不是所有文件都有标题行。看看下面这个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/ex2.csv</div></pre></td></tr></table></figure>
<pre><code>1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo
</code></pre><p>读入没有标题行的办法有两个。你可以让pandas为其分配默认的列名，也可以自己定义列名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex2.csv'</span>, header=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>      <th>4</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex2.csv'</span>, names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>指定某一列作为列索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex2.csv'</span>, names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>], index_col=<span class="string">'message'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>    <tr><br>      <th>message</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>hello</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>world</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>foo</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果希望将多个列做成一个层次化索引，只需传入由列编号或列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/csv_mindex.csv</div></pre></td></tr></table></figure>
<pre><code>key1,key2,value1,value2
one,a,1,2
one,b,3,4
one,c,5,6
one,d,7,8
two,a,9,10
two,b,11,12
two,c,13,14
two,d,15,16
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/csv_mindex.csv'</span>, index_col=[<span class="string">'key1'</span>, <span class="string">'key2'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>value1</th><br>      <th>value2</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="4" valign="top">one</th><br>      <th>a</th><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>5</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th rowspan="4" valign="top">two</th><br>      <th>a</th><br>      <td>9</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>11</td><br>      <td>12</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>13</td><br>      <td>14</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>15</td><br>      <td>16</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其它模式）。看看下面这个文本文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list(open(<span class="string">'data/examples/ex3.txt'</span>))</div></pre></td></tr></table></figure>
<pre><code>[&apos;            A         B         C\n&apos;,
 &apos;aaa -0.264438 -1.026059 -0.619500\n&apos;,
 &apos;bbb  0.927272  0.302904 -0.032399\n&apos;,
 &apos;ccc -0.264273 -0.386314 -0.217601\n&apos;,
 &apos;ddd -0.871858 -0.348382  1.100491\n&apos;]
</code></pre><p>虽然可以手动对数据进行规整，这里的字段是被数量不同的空白字符间隔开的。这种情况下，你可以传递一个正则表达式作为read_table的分隔符。可以用正则表达式表达为 <code>\s+</code>，于是有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_table(<span class="string">'data/examples/ex3.txt'</span>, sep=<span class="string">'\s+'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>A</th><br>      <th>B</th><br>      <th>C</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>aaa</th><br>      <td>-0.264438</td><br>      <td>-1.026059</td><br>      <td>-0.619500</td><br>    </tr><br>    <tr><br>      <th>bbb</th><br>      <td>0.927272</td><br>      <td>0.302904</td><br>      <td>-0.032399</td><br>    </tr><br>    <tr><br>      <th>ccc</th><br>      <td>-0.264273</td><br>      <td>-0.386314</td><br>      <td>-0.217601</td><br>    </tr><br>    <tr><br>      <th>ddd</th><br>      <td>-0.871858</td><br>      <td>-0.348382</td><br>      <td>1.100491</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>可以用skiprows跳过文件的第一行、第三行和第四行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/ex4.csv</div></pre></td></tr></table></figure>
<pre><code># hey!
a,b,c,d,message
# just wanted to make things more difficult for you
# who reads CSV files with computers, anyway?
1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex4.csv'</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/ex5.csv</div></pre></td></tr></table></figure>
<pre><code>something,a,b,c,d,message
one,1,2,3,4,NA
two,5,6,,8,world
three,9,10,11,12,foo
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex5.csv'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>something</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3.0</td><br>      <td>4</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>5</td><br>      <td>6</td><br>      <td>NaN</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>three</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11.0</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>na_values 可以用一个列表或集合的字符串表示缺失值：(把指定的值填充成 Nan)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 把 Null 填充成空缺值</span></div><div class="line">pd.read_csv(<span class="string">'data/examples/ex5.csv'</span>, na_values=[<span class="string">'NULL'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>something</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3.0</td><br>      <td>4</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>5</td><br>      <td>6</td><br>      <td>NaN</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>three</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11.0</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>字典的各列可以对不同的值用NA进行标记：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sentinels = &#123;<span class="string">'message'</span>: [<span class="string">'foo'</span>, <span class="string">'NA'</span>], <span class="string">'something'</span>: [<span class="string">'two'</span>]&#125;</div><div class="line">pd.read_csv(<span class="string">'data/examples/ex5.csv'</span>, na_values=sentinels)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>something</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3.0</td><br>      <td>4</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>NaN</td><br>      <td>5</td><br>      <td>6</td><br>      <td>NaN</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>three</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11.0</td><br>      <td>12</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pandas.read_csv和pandas.read_table常用的选项。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h3><p>在处理很大的文件时，或找出大文件中的参数集以便于后续处理时，你可能只想读取文件的一小部分或逐块对文件进行迭代。</p>
<p>在看大文件之前，我们先设置pandas显示地更紧些：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 最多显示 10 行</span></div><div class="line">pd.options.display.max_rows = <span class="number">10</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex6.csv'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>      <th>key</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.467976</td><br>      <td>-0.038649</td><br>      <td>-0.295344</td><br>      <td>-1.824726</td><br>      <td>L</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.358893</td><br>      <td>1.404453</td><br>      <td>0.704965</td><br>      <td>-0.200638</td><br>      <td>B</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-0.501840</td><br>      <td>0.659254</td><br>      <td>-0.421691</td><br>      <td>-0.057688</td><br>      <td>G</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.204886</td><br>      <td>1.074134</td><br>      <td>1.388361</td><br>      <td>-0.982404</td><br>      <td>R</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.354628</td><br>      <td>-0.133116</td><br>      <td>0.283763</td><br>      <td>-0.837063</td><br>      <td>Q</td><br>    </tr><br>    <tr><br>      <th>…</th><br>      <td>…</td><br>      <td>…</td><br>      <td>…</td><br>      <td>…</td><br>      <td>…</td><br>    </tr><br>    <tr><br>      <th>9995</th><br>      <td>2.311896</td><br>      <td>-0.417070</td><br>      <td>-1.409599</td><br>      <td>-0.515821</td><br>      <td>L</td><br>    </tr><br>    <tr><br>      <th>9996</th><br>      <td>-0.479893</td><br>      <td>-0.650419</td><br>      <td>0.745152</td><br>      <td>-0.646038</td><br>      <td>E</td><br>    </tr><br>    <tr><br>      <th>9997</th><br>      <td>0.523331</td><br>      <td>0.787112</td><br>      <td>0.486066</td><br>      <td>1.093156</td><br>      <td>K</td><br>    </tr><br>    <tr><br>      <th>9998</th><br>      <td>-0.362559</td><br>      <td>0.598894</td><br>      <td>-1.843201</td><br>      <td>0.887292</td><br>      <td>G</td><br>    </tr><br>    <tr><br>      <th>9999</th><br>      <td>-0.096376</td><br>      <td>-1.012999</td><br>      <td>-0.657431</td><br>      <td>-0.573315</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br><p>10000 rows × 5 columns</p><br></div>



<p>如果只想读取几行（避免读取整个文件），通过nrows进行指定即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_csv(<span class="string">'data/examples/ex6.csv'</span>, nrows=<span class="number">5</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>      <th>key</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.467976</td><br>      <td>-0.038649</td><br>      <td>-0.295344</td><br>      <td>-1.824726</td><br>      <td>L</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.358893</td><br>      <td>1.404453</td><br>      <td>0.704965</td><br>      <td>-0.200638</td><br>      <td>B</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-0.501840</td><br>      <td>0.659254</td><br>      <td>-0.421691</td><br>      <td>-0.057688</td><br>      <td>G</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.204886</td><br>      <td>1.074134</td><br>      <td>1.388361</td><br>      <td>-0.982404</td><br>      <td>R</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.354628</td><br>      <td>-0.133116</td><br>      <td>0.283763</td><br>      <td>-0.837063</td><br>      <td>Q</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>要逐块读取文件，可以指定chunksize（行数）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chunker = pd.read_csv(<span class="string">'data/examples/ex6.csv'</span>, chunksize=<span class="number">2</span>)</div><div class="line">chunker</div></pre></td></tr></table></figure>
<pre><code>&lt;pandas.io.parsers.TextFileReader at 0xa1a9710&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tot = pd.Series([])</div><div class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</div><div class="line">    tot = tot.add(piece[<span class="string">'key'</span>].value_counts(), fill_value=<span class="number">0</span>)</div><div class="line">print(piece)</div></pre></td></tr></table></figure>
<pre><code>           one       two     three      four key
9998 -0.362559  0.598894 -1.843201  0.887292   G
9999 -0.096376 -1.012999 -0.657431 -0.573315   0
</code></pre><h3 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_csv(<span class="string">'data/examples/ex5.csv'</span>)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>something</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3.0</td><br>      <td>4</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>5</td><br>      <td>6</td><br>      <td>NaN</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>three</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11.0</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出到文件</span></div><div class="line">data.to_csv(<span class="string">'data/examples/out.csv'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/out.csv</div></pre></td></tr></table></figure>
<pre><code>,something,a,b,c,d,message
0,one,1,2,3.0,4,
1,two,5,6,,8,world
2,three,9,10,11.0,12,foo
</code></pre><p>当然，还可以使用其他分隔符（由于这里直接写出到sys.stdout，所以仅仅是打印出文本结果而已）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置分割符 | </span></div><div class="line">data.to_csv(sys.stdout, sep=<span class="string">'|'</span>)</div></pre></td></tr></table></figure>
<pre><code>|something|a|b|c|d|message
0|one|1|2|3.0|4|
1|two|5|6||8|world
2|three|9|10|11.0|12|foo
</code></pre><p>禁止输出行和列的标签(索引)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.to_csv(sys.stdout, index=<span class="keyword">False</span>, header=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<pre><code>one,1,2,3.0,4,
two,5,6,,8,world
three,9,10,11.0,12,foo
</code></pre><p>输出部分列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.to_csv(sys.stdout, index=<span class="keyword">False</span>, columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div></pre></td></tr></table></figure>
<pre><code>a,b,c
1,2,3.0
5,6,
9,10,11.0
</code></pre><h3 id="JSON数据"><a href="#JSON数据" class="headerlink" title="JSON数据"></a>JSON数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">obj = <span class="string">"""</span></div><div class="line">&#123;"name": "Wes",</div><div class="line"> "places_lived": ["United States", "Spain", "Germany"],</div><div class="line"> "pet": null,</div><div class="line"> "siblings": [&#123;"name": "Scott", "age": 30, "pets": ["Zeus", "Zuko"]&#125;,</div><div class="line">              &#123;"name": "Katie", "age": 38,</div><div class="line">               "pets": ["Sixes", "Stache", "Cisco"]&#125;]</div><div class="line">&#125;</div><div class="line">"""</div><div class="line"><span class="keyword">import</span> json</div><div class="line">result = json.loads(obj)</div><div class="line">result</div></pre></td></tr></table></figure>
<pre><code>{&apos;name&apos;: &apos;Wes&apos;,
 &apos;places_lived&apos;: [&apos;United States&apos;, &apos;Spain&apos;, &apos;Germany&apos;],
 &apos;pet&apos;: None,
 &apos;siblings&apos;: [{&apos;name&apos;: &apos;Scott&apos;, &apos;age&apos;: 30, &apos;pets&apos;: [&apos;Zeus&apos;, &apos;Zuko&apos;]},
  {&apos;name&apos;: &apos;Katie&apos;, &apos;age&apos;: 38, &apos;pets&apos;: [&apos;Sixes&apos;, &apos;Stache&apos;, &apos;Cisco&apos;]}]}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">siblings = pd.DataFrame(result[<span class="string">'siblings'</span>], columns=[<span class="string">'name'</span>, <span class="string">'age'</span>])</div><div class="line">siblings</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>name</th><br>      <th>age</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Scott</td><br>      <td>30</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Katie</td><br>      <td>38</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat data/examples/example.json</div></pre></td></tr></table></figure>
<pre><code>[{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3},
 {&quot;a&quot;: 4, &quot;b&quot;: 5, &quot;c&quot;: 6},
 {&quot;a&quot;: 7, &quot;b&quot;: 8, &quot;c&quot;: 9}]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_json(<span class="string">'data/examples/example.json'</span>)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>7</td><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>将数据从pandas输出到JSON，可以使用to_json方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.to_json()</div></pre></td></tr></table></figure>
<pre><code>&apos;{&quot;a&quot;:{&quot;0&quot;:1,&quot;1&quot;:4,&quot;2&quot;:7},&quot;b&quot;:{&quot;0&quot;:2,&quot;1&quot;:5,&quot;2&quot;:8},&quot;c&quot;:{&quot;0&quot;:3,&quot;1&quot;:6,&quot;2&quot;:9}}&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.to_json(orient=<span class="string">'records'</span>)</div></pre></td></tr></table></figure>
<pre><code>&apos;[{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3},{&quot;a&quot;:4,&quot;b&quot;:5,&quot;c&quot;:6},{&quot;a&quot;:7,&quot;b&quot;:8,&quot;c&quot;:9}]&apos;
</code></pre><h2 id="二进制数据格式"><a href="#二进制数据格式" class="headerlink" title="二进制数据格式"></a>二进制数据格式</h2><p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.read_csv(<span class="string">'data/examples/ex1.csv'</span>)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.to_pickle(<span class="string">'data/examples/frame_pickle'</span>)</div></pre></td></tr></table></figure>
<p>通过pickle直接读取被pickle化的数据，或是使用更为方便的pandas.read_pickle：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_pickle(<span class="string">'data/examples/frame_pickle'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<blockquote>
<p>注意：pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的；今天pickle的对象可能无法被后续版本的库unpickle出来。虽然我尽力保证这种事情不会发生在pandas中，但是今后的某个时候说不定还是得“打破”该pickle格式。</p>
</blockquote>
<h3 id="使用HDF5格式"><a href="#使用HDF5格式" class="headerlink" title="使用HDF5格式"></a>使用HDF5格式</h3><p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。它可以被作为C标准库，带有许多语言的接口，如Java、Python和MATLAB等。HDF5中的HDF指的是层次型数据格式（hierarchical data format）。每个HDF5文件都含有一个文件系统式的节点结构，它使你能够存储多个数据集并支持元数据。与其他简单格式相比，HDF5支持多种压缩器的即时压缩，还能更高效地存储重复模式数据。对于那些非常大的无法直接放入内存的数据集，HDF5就是不错的选择，因为它可以高效地分块读写。  </p>
<p>虽然可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口，可以简化存储Series和DataFrame对象。HDFStore类可以像字典一样，处理低级的细节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: np.random.randn(<span class="number">100</span>)&#125;)</div><div class="line">frame.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.863684</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.743116</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-0.656781</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.349087</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>-0.772184</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store = pd.HDFStore(<span class="string">'data/examples/mydata.h5'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 存储数据</span></div><div class="line">store[<span class="string">'obj1'</span>] = frame</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store[<span class="string">'obj1_col'</span>] = frame[<span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store</div></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;pandas.io.pytables.HDFStore&apos;&gt;
File path: data/examples/mydata.h5
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store1 = pd.HDFStore(<span class="string">'data/examples/mydata.h5'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取数据</span></div><div class="line">store1[<span class="string">'obj1'</span>].head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.863684</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.743116</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>-0.656781</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.349087</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>-0.772184</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="读取Microsoft-Excel文件"><a href="#读取Microsoft-Excel文件" class="headerlink" title="读取Microsoft Excel文件"></a>读取Microsoft Excel文件</h3><p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件。你可以用pip或conda安装它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xlsx = pd.ExcelFile(<span class="string">'data/examples/ex1.xlsx'</span>)</div><div class="line">pd.read_excel(xlsx, <span class="string">'Sheet1'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Unnamed: 0</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果要读取一个文件中的多个表单，创建ExcelFile会更快，但你也可以将文件名传递到pandas.read_excel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame = pd.read_excel(<span class="string">'data/examples/ex1.xlsx'</span>, <span class="string">'Sheet1'</span>)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Unnamed: 0</th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>message</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>      <td>4</td><br>      <td>hello</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>      <td>world</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>      <td>12</td><br>      <td>foo</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果要将pandas数据写入为Excel格式，你必须首先创建一个ExcelWriter，然后使用pandas对象的to_excel方法将数据写入到其中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">writer = pd.ExcelWriter(<span class="string">'data/examples/ex2.xlsx'</span>)</div><div class="line">frame.to_excel(writer, <span class="string">'Sheet1'</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<p>你还可以不使用ExcelWriter，而是传递文件的路径到to_excel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.to_excel(<span class="string">'data/examples/ex2.xlsx'</span>)</div></pre></td></tr></table></figure>
<h3 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h3><p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。<br>例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sqlite3</div><div class="line"></div><div class="line"><span class="comment"># 创建表</span></div><div class="line">query = <span class="string">"""</span></div><div class="line">CREATE TABLE test</div><div class="line">(a VARCHAR(20), b VARCHAR(20),</div><div class="line"> c REAL,        d INTEGER</div><div class="line">);"""</div><div class="line">con = sqlite3.connect(<span class="string">'mydata.sqlite'</span>)</div><div class="line">con.execute(query)</div><div class="line">con.commit()</div><div class="line"></div><div class="line"><span class="comment"># 写入数据  批量写入</span></div><div class="line">data = [(<span class="string">'Atlanta'</span>, <span class="string">'Georgia'</span>, <span class="number">1.25</span>, <span class="number">6</span>),</div><div class="line">(<span class="string">'Tallahassee'</span>, <span class="string">'Florida'</span>, <span class="number">2.6</span>, <span class="number">3</span>),</div><div class="line">(<span class="string">'Sacramento'</span>, <span class="string">'California'</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</div><div class="line">stmt = <span class="string">"INSERT INTO test VALUES(?, ?, ?, ?)"</span></div><div class="line">con.executemany(stmt, data)</div><div class="line">con.commit()</div><div class="line"></div><div class="line"><span class="comment"># 查询数据</span></div><div class="line">cursor = con.execute(<span class="string">'select * from test'</span>)</div><div class="line">rows = cursor.fetchall()</div><div class="line">rows</div></pre></td></tr></table></figure>
<pre><code>[(&apos;Atlanta&apos;, &apos;Georgia&apos;, 1.25, 6),
 (&apos;Tallahassee&apos;, &apos;Florida&apos;, 2.6, 3),
 (&apos;Sacramento&apos;, &apos;California&apos;, 1.7, 5)]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取列名(字段名称)</span></div><div class="line">cursor.description</div></pre></td></tr></table></figure>
<pre><code>((&apos;a&apos;, None, None, None, None, None, None),
 (&apos;b&apos;, None, None, None, None, None, None),
 (&apos;c&apos;, None, None, None, None, None, None),
 (&apos;d&apos;, None, None, None, None, None, None))
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建 dataframe</span></div><div class="line">pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Atlanta</td><br>      <td>Georgia</td><br>      <td>1.25</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Tallahassee</td><br>      <td>Florida</td><br>      <td>2.60</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Sacramento</td><br>      <td>California</td><br>      <td>1.70</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pandas 有一个 read_sql 函数，可以直接通过 sql 进行读取数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db = sqlite3.connect(<span class="string">'mydata.sqlite'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.read_sql(<span class="string">'select * from test'</span>, db)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Atlanta</td><br>      <td>Georgia</td><br>      <td>1.25</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Tallahassee</td><br>      <td>Florida</td><br>      <td>2.60</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Sacramento</td><br>      <td>California</td><br>      <td>1.70</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<h1 id="数据清洗和准备"><a href="#数据清洗和准备" class="headerlink" title="数据清洗和准备"></a>数据清洗和准备</h1><h2 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h2><p>缺失数据在pandas中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string_data = pd.Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="string">'avocado'</span>])</div><div class="line">string_data</div></pre></td></tr></table></figure>
<pre><code>0     aardvark
1    artichoke
2          NaN
3      avocado
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 判断是否是空值</span></div><div class="line">string_data.isnull()</div></pre></td></tr></table></figure>
<pre><code>0    False
1    False
2     True
3    False
dtype: bool
</code></pre><p>Python内置的None值在对象数组中也可以作为NA</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string_data[<span class="number">0</span>] = <span class="keyword">None</span></div><div class="line">string_data</div></pre></td></tr></table></figure>
<pre><code>0         None
1    artichoke
2          NaN
3      avocado
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string_data.isnull()</div></pre></td></tr></table></figure>
<pre><code>0     True
1    False
2     True
3    False
dtype: bool
</code></pre><p>一些关于缺失数据处理的函数。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="滤除缺失数据"><a href="#滤除缺失数据" class="headerlink" title="滤除缺失数据"></a>滤除缺失数据</h3><p>对于一个Series，dropna返回一个仅含非空数据和索引值的Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.Series([<span class="number">1</span>, np.nan, <span class="number">3.5</span>, np.nan, <span class="number">7</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    NaN
2    3.5
3    NaN
4    7.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.dropna()</div></pre></td></tr></table></figure>
<pre><code>0    1.0
2    3.5
4    7.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 等价于</span></div><div class="line">data[data.notnull()]</div></pre></td></tr></table></figure>
<pre><code>0    1.0
2    3.5
4    7.0
dtype: float64
</code></pre><p>而对于DataFrame对象，事情就有点复杂了。你可能希望丢弃全NA或含有NA的行或列。dropna默认丢弃任何含有缺失值的行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.dropna()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>传入 <code>how=&#39;all&#39;</code> 将只丢弃全为NA的那些行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.dropna(how=<span class="string">'all'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>丢弃列，只需传入axis=1即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data[<span class="number">4</span>] = NA</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>4</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p><code>thresh</code> 参数 删除 行、列 空值超过指定数字的 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>4</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除 行 方向 nan 大于 2 的行</span></div><div class="line">data.dropna(thresh=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>4</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.5</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h3><p>对于大多数情况而言，fillna方法是最主要的函数。通过一个常数调用fillna就会将缺失值替换为那个常数值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</div><div class="line">df.iloc[:<span class="number">4</span>, <span class="number">1</span>] = NA</div><div class="line">df.iloc[:<span class="number">2</span>, <span class="number">2</span>] = NA</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.187550</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.903578</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.142988</td><br>      <td>NaN</td><br>      <td>-1.629844</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.346151</td><br>      <td>NaN</td><br>      <td>-0.806237</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.125914</td><br>      <td>-0.188009</td><br>      <td>-1.067930</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-1.181948</td><br>      <td>0.289074</td><br>      <td>-0.852676</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>0.568097</td><br>      <td>-0.950069</td><br>      <td>-2.165337</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 填充成 0 </span></div><div class="line">df.fillna(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.187550</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.903578</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.142988</td><br>      <td>0.000000</td><br>      <td>-1.629844</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.346151</td><br>      <td>0.000000</td><br>      <td>-0.806237</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.125914</td><br>      <td>-0.188009</td><br>      <td>-1.067930</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-1.181948</td><br>      <td>0.289074</td><br>      <td>-0.852676</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>0.568097</td><br>      <td>-0.950069</td><br>      <td>-2.165337</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>若是通过一个字典调用fillna，就可以实现对不同的列填充不同的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1 列填充 0.5 ；2 列填充 0</span></div><div class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.187550</td><br>      <td>0.500000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.903578</td><br>      <td>0.500000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.142988</td><br>      <td>0.500000</td><br>      <td>-1.629844</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.346151</td><br>      <td>0.500000</td><br>      <td>-0.806237</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.125914</td><br>      <td>-0.188009</td><br>      <td>-1.067930</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-1.181948</td><br>      <td>0.289074</td><br>      <td>-0.852676</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>0.568097</td><br>      <td>-0.950069</td><br>      <td>-2.165337</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>fillna默认会返回新对象，但也可以对现有对象进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.fillna(<span class="number">0</span>, inplace=<span class="keyword">True</span>)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.187550</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.903578</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.142988</td><br>      <td>0.000000</td><br>      <td>-1.629844</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.346151</td><br>      <td>0.000000</td><br>      <td>-0.806237</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.125914</td><br>      <td>-0.188009</td><br>      <td>-1.067930</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-1.181948</td><br>      <td>0.289074</td><br>      <td>-0.852676</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>0.568097</td><br>      <td>-0.950069</td><br>      <td>-2.165337</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对 reindex 有效的那些插值方法也可用于fillna：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">3</span>))</div><div class="line">df.iloc[<span class="number">2</span>:, <span class="number">1</span>] = NA</div><div class="line">df.iloc[<span class="number">4</span>:, <span class="number">2</span>] = NA</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-2.190504</td><br>      <td>-1.963825</td><br>      <td>-1.545763</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.306294</td><br>      <td>-1.290580</td><br>      <td>-1.274680</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.535840</td><br>      <td>NaN</td><br>      <td>0.219375</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.938590</td><br>      <td>NaN</td><br>      <td>-1.277384</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.747602</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-0.113758</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ffill 使用 前值填充</span></div><div class="line">df.fillna(method=<span class="string">'ffill'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-2.190504</td><br>      <td>-1.963825</td><br>      <td>-1.545763</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.306294</td><br>      <td>-1.290580</td><br>      <td>-1.274680</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.535840</td><br>      <td>-1.290580</td><br>      <td>0.219375</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.938590</td><br>      <td>-1.290580</td><br>      <td>-1.277384</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.747602</td><br>      <td>-1.290580</td><br>      <td>-1.277384</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-0.113758</td><br>      <td>-1.290580</td><br>      <td>-1.277384</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># limit 限制填充的条数</span></div><div class="line">df.fillna(method=<span class="string">'ffill'</span>, limit=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-2.190504</td><br>      <td>-1.963825</td><br>      <td>-1.545763</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.306294</td><br>      <td>-1.290580</td><br>      <td>-1.274680</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.535840</td><br>      <td>-1.290580</td><br>      <td>0.219375</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.938590</td><br>      <td>-1.290580</td><br>      <td>-1.277384</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.747602</td><br>      <td>NaN</td><br>      <td>-1.277384</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-0.113758</td><br>      <td>NaN</td><br>      <td>-1.277384</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>可以传入Series的平均值或中位数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.Series([<span class="number">1.</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    NaN
2    3.5
3    NaN
4    7.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.fillna(data.mean())</div></pre></td></tr></table></figure>
<pre><code>0    1.000000
1    3.833333
2    3.500000
3    3.833333
4    7.000000
dtype: float64
</code></pre><p>fillna函数参数<br><img src="http://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(&#123;<span class="string">'k1'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>] * <span class="number">3</span> + [<span class="string">'two'</span>], <span class="string">'k2'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>k1</th><br>      <th>k2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>one</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>two</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>one</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>two</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>two</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>duplicated 方法返回一个布尔型 Series，表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.duplicated()</div></pre></td></tr></table></figure>
<pre><code>0    False
1    False
2    False
3    False
4    False
5    False
6     True
dtype: bool
</code></pre><p>drop_duplicates 方法，它会返回一个DataFrame，重复的数据会被删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.drop_duplicates()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>k1</th><br>      <th>k2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>one</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>two</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>one</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>two</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这两个方法默认会判断全部列，你也可以指定部分列进行重复项判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.drop_duplicates([<span class="string">'k1'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>k1</th><br>      <th>k2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>duplicated 和 drop_duplicates 默认保留的是第一个出现的值组合。传入 <code>keep=&#39;last&#39;</code> 则保留最后一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.drop_duplicates([<span class="string">'k1'</span>, <span class="string">'k2'</span>], keep=<span class="string">'last'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>k1</th><br>      <th>k2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>one</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>two</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>one</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>two</td><br>      <td>4</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>利用函数或映射进行数据转换</p>
<h3 id="利用函数或映射进行数据转换"><a href="#利用函数或映射进行数据转换" class="headerlink" title="利用函数或映射进行数据转换"></a>利用函数或映射进行数据转换</h3><p>我们来看看下面这组有关肉类的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>, <span class="string">'Pastrami'</span>, <span class="string">'corned beef'</span>, <span class="string">'Bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>, <span class="string">'nova lox'</span>],</div><div class="line">        <span class="string">'ounces'</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>food</th><br>      <th>ounces</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>bacon</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>pulled pork</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>bacon</td><br>      <td>12.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Pastrami</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>corned beef</td><br>      <td>7.5</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>Bacon</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>pastrami</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>honey ham</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>nova lox</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设你想要添加一列表示该肉类食物来源的动物类型。我们先编写一个不同肉类到动物的映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">meat_to_animal = &#123;</div><div class="line">  <span class="string">'bacon'</span>: <span class="string">'pig'</span>,</div><div class="line">  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,</div><div class="line">  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,</div><div class="line">  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</div><div class="line">  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,</div><div class="line">  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>列字符转换成小写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lowercased = data[<span class="string">'food'</span>].str.lower()</div><div class="line">lowercased</div></pre></td></tr></table></figure>
<pre><code>0          bacon
1    pulled pork
2          bacon
3       pastrami
4    corned beef
5          bacon
6       pastrami
7      honey ham
8       nova lox
Name: food, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lowercased.map(meat_to_animal)</div></pre></td></tr></table></figure>
<pre><code>0       pig
1       pig
2       pig
3       cow
4       cow
5       pig
6       cow
7       pig
8    salmon
Name: food, dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'animal'</span>] = lowercased.map(meat_to_animal)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>food</th><br>      <th>ounces</th><br>      <th>animal</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>bacon</td><br>      <td>4.0</td><br>      <td>pig</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>pulled pork</td><br>      <td>3.0</td><br>      <td>pig</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>bacon</td><br>      <td>12.0</td><br>      <td>pig</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Pastrami</td><br>      <td>6.0</td><br>      <td>cow</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>corned beef</td><br>      <td>7.5</td><br>      <td>cow</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>Bacon</td><br>      <td>8.0</td><br>      <td>pig</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>pastrami</td><br>      <td>3.0</td><br>      <td>cow</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>honey ham</td><br>      <td>5.0</td><br>      <td>pig</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>nova lox</td><br>      <td>6.0</td><br>      <td>salmon</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>我们也可以使用下面的这种方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'food'</span>].map(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</div></pre></td></tr></table></figure>
<pre><code>0       pig
1       pig
2       pig
3       cow
4       cow
5       pig
6       cow
7       pig
8    salmon
Name: food, dtype: object
</code></pre><h3 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a>替换值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.Series([<span class="number">1.</span>, <span class="number">-999.</span>, <span class="number">2.</span>, <span class="number">-999.</span>, <span class="number">-1000.</span>, <span class="number">3.</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>0       1.0
1    -999.0
2       2.0
3    -999.0
4   -1000.0
5       3.0
dtype: float64
</code></pre><p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为pandas能够理解的NA值，我们可以利用replace来产生一个新的Series（除非传入inplace=True）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.replace(<span class="number">-999</span>, np.nan)</div></pre></td></tr></table></figure>
<pre><code>0       1.0
1       NaN
2       2.0
3       NaN
4   -1000.0
5       3.0
dtype: float64
</code></pre><p>如果你希望一次性替换多个值，可以传入一个由待替换值组成的列表以及一个替换值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], np.nan)</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    NaN
2    2.0
3    NaN
4    NaN
5    3.0
dtype: float64
</code></pre><p>要让每个值有不同的替换值，可以传递一个替换列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], [np.nan, <span class="number">0</span>])</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    NaN
2    2.0
3    NaN
4    0.0
5    3.0
dtype: float64
</code></pre><p>传入的参数也可以是字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.replace(&#123;<span class="number">-999</span>: np.nan, <span class="number">-1000</span>: <span class="number">0</span>&#125;)</div></pre></td></tr></table></figure>
<pre><code>0    1.0
1    NaN
2    2.0
3    NaN
4    0.0
5    3.0
dtype: float64
</code></pre><h3 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>New York</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>跟Series一样，轴索引也有一个map方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</div><div class="line">data.index.map(transform)</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;OHIO&apos;, &apos;COLO&apos;, &apos;NEW &apos;], dtype=&apos;object&apos;)
</code></pre><p>将其赋值给index，这样就可以对DataFrame进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data.index = data.index.map(transform)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>OHIO</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>COLO</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>NEW</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果想要创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.rename(index=str.title, columns=str.upper)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>ONE</th><br>      <th>TWO</th><br>      <th>THREE</th><br>      <th>FOUR</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Colo</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>New</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>rename可以结合字典型对象实现对部分轴标签的更新：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;, columns=&#123;<span class="string">'three'</span>: <span class="string">'peekaboo'</span>&#125;)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>peekaboo</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>INDIANA</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>COLO</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>NEW</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>rename可以实现复制DataFrame并对其索引和列标签进行赋值。如果希望就地修改某个数据集，传入 <code>inplace=True</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;, inplace=<span class="keyword">True</span>)</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>INDIANA</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>COLO</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>NEW</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h3><p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。假设有一组人员数据，而你希望将它们划分为不同的年龄组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</div></pre></td></tr></table></figure>
<p>接下来将这些数据划分为“18到25”、“26到35”、“35到60”以及“60以上”几个面元。要实现该功能，你需要使用pandas的cut函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</div><div class="line">cats = pd.cut(ages, bins)</div><div class="line">cats</div></pre></td></tr></table></figure>
<pre><code>[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35, 60], (35, 60], (25, 35]]
Length: 12
Categories (4, interval[int64]): [(18, 25] &lt; (25, 35] &lt; (35, 60] &lt; (60, 100]]
</code></pre><p>pandas返回的是一个特殊的Categorical对象。结果展示了pandas.cut划分的面元。你可以将其看做一组表示面元名称的字符串。它的底层含有一个表示不同分类名称的类型数组，以及一个codes属性中的年龄数据的标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 统计值所在的元面</span></div><div class="line">cats.codes</div></pre></td></tr></table></figure>
<pre><code>array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获得分组</span></div><div class="line">cats.categories</div></pre></td></tr></table></figure>
<pre><code>IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]]
              closed=&apos;right&apos;,
              dtype=&apos;interval[int64]&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># pd.value_counts(cats)是pandas.cut结果的面元计数。</span></div><div class="line">pd.value_counts(cats)</div></pre></td></tr></table></figure>
<pre><code>(18, 25]     5
(35, 60]     3
(25, 35]     3
(60, 100]    1
dtype: int64
</code></pre><p>跟“区间”的数学符号一样，圆括号表示开端，而方括号则表示闭端（包括）。哪边是闭端可以通过right=False进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<pre><code>[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]
Length: 12
Categories (4, interval[int64]): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]
</code></pre><p>通过传递一个列表或数组到labels，设置自己的面元名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group_names = [<span class="string">'Youth'</span>, <span class="string">'YoungAdult'</span>, <span class="string">'MiddleAged'</span>, <span class="string">'Senior'</span>]</div><div class="line">pd.cut(ages, bins, labels=group_names)</div></pre></td></tr></table></figure>
<pre><code>[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]
Length: 12
Categories (4, object): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]
</code></pre><p>如果向cut传入的是面元的数量而不是确切的面元边界，则它会根据数据的最小值和最大值计算等长面元。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = np.random.rand(<span class="number">20</span>)</div><div class="line"><span class="comment"># 等分成 4 份， 选项precision=2，限定小数只有两位。</span></div><div class="line">pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<pre><code>[(0.49, 0.72], (0.015, 0.25], (0.49, 0.72], (0.49, 0.72], (0.25, 0.49], ..., (0.25, 0.49], (0.25, 0.49], (0.72, 0.96], (0.015, 0.25], (0.25, 0.49]]
Length: 20
Categories (4, interval[float64]): [(0.015, 0.25] &lt; (0.25, 0.49] &lt; (0.49, 0.72] &lt; (0.72, 0.96]]
</code></pre><p>qcut是一个非常类似于cut的函数，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = np.random.randn(<span class="number">1000</span>)</div><div class="line">cats = pd.qcut(data, <span class="number">4</span>)</div><div class="line">cats</div></pre></td></tr></table></figure>
<pre><code>[(-0.694, -0.0168], (-3.589, -0.694], (0.638, 3.369], (-0.0168, 0.638], (-3.589, -0.694], ..., (-0.694, -0.0168], (-3.589, -0.694], (-0.694, -0.0168], (-3.589, -0.694], (-0.0168, 0.638]]
Length: 1000
Categories (4, interval[float64]): [(-3.589, -0.694] &lt; (-0.694, -0.0168] &lt; (-0.0168, 0.638] &lt; (0.638, 3.369]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.value_counts(cats)</div></pre></td></tr></table></figure>
<pre><code>(0.638, 3.369]       250
(-0.0168, 0.638]     250
(-0.694, -0.0168]    250
(-3.589, -0.694]     250
dtype: int64
</code></pre><h3 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h3><p>过滤或变换异常值在很大程度上就是运用数组运算。来看一个含有正态分布数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</div><div class="line">data.describe()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>count</th><br>      <td>1000.000000</td><br>      <td>1000.000000</td><br>      <td>1000.000000</td><br>      <td>1000.000000</td><br>    </tr><br>    <tr><br>      <th>mean</th><br>      <td>-0.064053</td><br>      <td>-0.005447</td><br>      <td>0.038026</td><br>      <td>0.024811</td><br>    </tr><br>    <tr><br>      <th>std</th><br>      <td>0.999489</td><br>      <td>0.948043</td><br>      <td>0.953395</td><br>      <td>1.021102</td><br>    </tr><br>    <tr><br>      <th>min</th><br>      <td>-3.105504</td><br>      <td>-2.844008</td><br>      <td>-2.760611</td><br>      <td>-4.492430</td><br>    </tr><br>    <tr><br>      <th>25%</th><br>      <td>-0.718899</td><br>      <td>-0.656214</td><br>      <td>-0.597055</td><br>      <td>-0.646600</td><br>    </tr><br>    <tr><br>      <th>50%</th><br>      <td>-0.020346</td><br>      <td>-0.019434</td><br>      <td>0.058547</td><br>      <td>-0.003166</td><br>    </tr><br>    <tr><br>      <th>75%</th><br>      <td>0.578055</td><br>      <td>0.649719</td><br>      <td>0.661221</td><br>      <td>0.690373</td><br>    </tr><br>    <tr><br>      <th>max</th><br>      <td>3.106261</td><br>      <td>2.717680</td><br>      <td>3.289203</td><br>      <td>3.243883</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设你想要找出某列中绝对值大小超过3的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">col = data[<span class="number">2</span>]</div><div class="line">col[np.abs(col) &gt; <span class="number">3</span>]</div></pre></td></tr></table></figure>
<pre><code>308    3.289203
Name: 2, dtype: float64
</code></pre><p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型DataFrame中使用any方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[(np.abs(data) &gt; <span class="number">3</span>).any(<span class="number">1</span>)]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>8</th><br>      <td>-3.105504</td><br>      <td>-0.094313</td><br>      <td>-0.186817</td><br>      <td>0.461499</td><br>    </tr><br>    <tr><br>      <th>96</th><br>      <td>0.522268</td><br>      <td>-0.201284</td><br>      <td>0.145961</td><br>      <td>3.151065</td><br>    </tr><br>    <tr><br>      <th>121</th><br>      <td>3.106261</td><br>      <td>-2.029135</td><br>      <td>-0.179609</td><br>      <td>-0.478008</td><br>    </tr><br>    <tr><br>      <th>148</th><br>      <td>0.019824</td><br>      <td>0.115120</td><br>      <td>1.005103</td><br>      <td>-4.492430</td><br>    </tr><br>    <tr><br>      <th>308</th><br>      <td>0.770344</td><br>      <td>-0.635648</td><br>      <td>3.289203</td><br>      <td>-0.151866</td><br>    </tr><br>    <tr><br>      <th>434</th><br>      <td>-0.594539</td><br>      <td>-0.124445</td><br>      <td>0.535540</td><br>      <td>3.243883</td><br>    </tr><br>    <tr><br>      <th>454</th><br>      <td>0.196540</td><br>      <td>0.002230</td><br>      <td>1.150842</td><br>      <td>-3.098229</td><br>    </tr><br>    <tr><br>      <th>475</th><br>      <td>1.327124</td><br>      <td>0.532669</td><br>      <td>-0.285367</td><br>      <td>3.095290</td><br>    </tr><br>    <tr><br>      <th>604</th><br>      <td>1.154687</td><br>      <td>0.336886</td><br>      <td>-0.767514</td><br>      <td>3.229107</td><br>    </tr><br>    <tr><br>      <th>659</th><br>      <td>-3.076200</td><br>      <td>-0.979556</td><br>      <td>0.653771</td><br>      <td>0.559905</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h3><p>利用 <code>numpy.random.permutation</code> 函数可以轻松实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。通过需要排列的轴的长度调用 permutation，可产生一个表示新顺序的整数数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>16</td><br>      <td>17</td><br>      <td>18</td><br>      <td>19</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sampler = np.random.permutation(<span class="number">5</span>)</div><div class="line">sampler</div></pre></td></tr></table></figure>
<pre><code>array([2, 1, 4, 3, 0])
</code></pre><p>然后就可以在基于iloc的索引操作或take函数中使用该数组了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.take(sampler)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>16</td><br>      <td>17</td><br>      <td>18</td><br>      <td>19</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>选取随机子集（不重复的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.sample(n=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>3</th><br>      <td>12</td><br>      <td>13</td><br>      <td>14</td><br>      <td>15</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>5</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>8</td><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>选取随机子集（允许重复）,不能操作 DateFrame</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">4</span>])</div><div class="line">choices.sample(n=<span class="number">10</span>, replace=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>0    5
4    4
0    5
0    5
2   -1
3    6
3    6
3    6
3    6
0    5
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">choices</div></pre></td></tr></table></figure>
<pre><code>0    5
1    7
2   -1
3    6
4    4
dtype: int64
</code></pre><h3 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h3><p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。  </p>
<p>如果DataFrame的某一列中含有k个不同的值，则可以派生出一个k列矩阵或DataFrame（其值全为1和0）。pandas有一个get_dummies函数可以实现该功能（其实自己动手做一个也不难）。使用之前的一个DataFrame例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data1</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>c</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>b</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.get_dummies(df[<span class="string">'key'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>有时候，你可能想给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并。get_dummies的prefix参数可以实现该功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dummies = pd.get_dummies(df[<span class="string">'key'</span>], prefix=<span class="string">'key'</span>)</div><div class="line">dummies</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key_a</th><br>      <th>key_b</th><br>      <th>key_c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拼接</span></div><div class="line">df_with_dummy = df[[<span class="string">'data1'</span>]].join(dummies)</div><div class="line">df_with_dummy</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>data1</th><br>      <th>key_a</th><br>      <th>key_b</th><br>      <th>key_c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3</td><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>4</td><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>5</td><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果DataFrame中的某行同属于多个分类，则事情就会有点复杂。看一下MovieLens 1M数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mnames = [<span class="string">'movie_id'</span>, <span class="string">'title'</span>, <span class="string">'genres'</span>]</div><div class="line">movies = pd.read_table(<span class="string">'data/movielens/movies.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=mnames)</div><div class="line">movies.head()</div></pre></td></tr></table></figure>
<pre><code>C:\ProgramData\Anaconda3\lib\site-packages\ipykernel_launcher.py:2: ParserWarning: Falling back to the &apos;python&apos; engine because the &apos;c&apos; engine does not support regex separators (separators &gt; 1 char and different from &apos;\s+&apos; are interpreted as regex); you can avoid this warning by specifying engine=&apos;python&apos;.
</code></pre><div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>movie_id</th><br>      <th>title</th><br>      <th>genres</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>Toy Story (1995)</td><br>      <td>Animation|Children’s|Comedy</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2</td><br>      <td>Jumanji (1995)</td><br>      <td>Adventure|Children’s|Fantasy</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>Grumpier Old Men (1995)</td><br>      <td>Comedy|Romance</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>4</td><br>      <td>Waiting to Exhale (1995)</td><br>      <td>Comedy|Drama</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>5</td><br>      <td>Father of the Bride Part II (1995)</td><br>      <td>Comedy</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>要为每个genre添加指标变量就需要做一些数据规整操作。首先，我们从数据集中抽取出不同的genre值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">all_genres = []</div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</div><div class="line">    all_genres.extend(x.split(<span class="string">'|'</span>))</div><div class="line"></div><div class="line">genres = pd.unique(all_genres)</div><div class="line">genres</div></pre></td></tr></table></figure>
<pre><code>array([&apos;Animation&apos;, &quot;Children&apos;s&quot;, &apos;Comedy&apos;, &apos;Adventure&apos;, &apos;Fantasy&apos;,
       &apos;Romance&apos;, &apos;Drama&apos;, &apos;Action&apos;, &apos;Crime&apos;, &apos;Thriller&apos;, &apos;Horror&apos;,
       &apos;Sci-Fi&apos;, &apos;Documentary&apos;, &apos;War&apos;, &apos;Musical&apos;, &apos;Mystery&apos;, &apos;Film-Noir&apos;,
       &apos;Western&apos;], dtype=object)
</code></pre><p>构建指标DataFrame的方法之一是从一个全零DataFrame开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zero_matrix = np.zeros((len(movies), len(genres)))</div><div class="line">zero_matrix</div></pre></td></tr></table></figure>
<pre><code>array([[0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       ...,
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dummies = pd.DataFrame(zero_matrix, columns=genres)</div><div class="line">dummies.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Animation</th><br>      <th>Children’s</th><br>      <th>Comedy</th><br>      <th>Adventure</th><br>      <th>Fantasy</th><br>      <th>Romance</th><br>      <th>Drama</th><br>      <th>Action</th><br>      <th>Crime</th><br>      <th>Thriller</th><br>      <th>Horror</th><br>      <th>Sci-Fi</th><br>      <th>Documentary</th><br>      <th>War</th><br>      <th>Musical</th><br>      <th>Mystery</th><br>      <th>Film-Noir</th><br>      <th>Western</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>现在，迭代每一部电影，并将dummies各行的条目设为1。要这么做，我们使用dummies.columns来计算每个类型的列索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gen = movies.genres[<span class="number">0</span>]</div><div class="line">gen</div></pre></td></tr></table></figure>
<pre><code>&quot;Animation|Children&apos;s|Comedy&quot;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gen.split(<span class="string">'|'</span>)</div></pre></td></tr></table></figure>
<pre><code>[&apos;Animation&apos;, &quot;Children&apos;s&quot;, &apos;Comedy&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取值对应的下标</span></div><div class="line">dummies.columns.get_indexer(gen.split(<span class="string">'|'</span>))</div></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2], dtype=int64)
</code></pre><p>根据索引，使用.iloc设定值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i, gen <span class="keyword">in</span> enumerate(movies.genres):</div><div class="line">    indices = dummies.columns.get_indexer(gen.split(<span class="string">'|'</span>))</div><div class="line">    dummies.iloc[i, indices] = <span class="number">1</span></div></pre></td></tr></table></figure>
<p>将其与movies合并起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movies_windic = movies.join(dummies.add_prefix(<span class="string">'Genre_'</span>))</div><div class="line">movies_windic.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>movie_id</th><br>      <th>title</th><br>      <th>genres</th><br>      <th>Genre_Animation</th><br>      <th>Genre_Children’s</th><br>      <th>Genre_Comedy</th><br>      <th>Genre_Adventure</th><br>      <th>Genre_Fantasy</th><br>      <th>Genre_Romance</th><br>      <th>Genre_Drama</th><br>      <th>…</th><br>      <th>Genre_Crime</th><br>      <th>Genre_Thriller</th><br>      <th>Genre_Horror</th><br>      <th>Genre_Sci-Fi</th><br>      <th>Genre_Documentary</th><br>      <th>Genre_War</th><br>      <th>Genre_Musical</th><br>      <th>Genre_Mystery</th><br>      <th>Genre_Film-Noir</th><br>      <th>Genre_Western</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>Toy Story (1995)</td><br>      <td>Animation|Children’s|Comedy</td><br>      <td>1.0</td><br>      <td>1.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>…</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2</td><br>      <td>Jumanji (1995)</td><br>      <td>Adventure|Children’s|Fantasy</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>…</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>Grumpier Old Men (1995)</td><br>      <td>Comedy|Romance</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>…</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>4</td><br>      <td>Waiting to Exhale (1995)</td><br>      <td>Comedy|Drama</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>…</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>5</td><br>      <td>Father of the Bride Part II (1995)</td><br>      <td>Comedy</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>…</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>  </tbody><br></table><br><p>5 rows × 21 columns</p><br></div>



<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="pandas-的矢量化字符串函数"><a href="#pandas-的矢量化字符串函数" class="headerlink" title="pandas 的矢量化字符串函数"></a>pandas 的矢量化字符串函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = &#123;<span class="string">'Dave'</span>: <span class="string">'dave@google.com'</span>, <span class="string">'Steve'</span>: <span class="string">'steve@gmail.com'</span>, <span class="string">'Rob'</span>: <span class="string">'rob@gmail.com'</span>, <span class="string">'Wes'</span>: np.nan&#125;</div><div class="line">data = pd.Series(data)</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>Dave     dave@google.com
Steve    steve@gmail.com
Rob        rob@gmail.com
Wes                  NaN
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.isnull()</div></pre></td></tr></table></figure>
<pre><code>Dave     False
Steve    False
Rob      False
Wes       True
dtype: bool
</code></pre><p>通过 <code>data.map</code>，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在 <code>NA（null）</code> 就会报错。为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的 <code>str</code> 属性即可访问这些方法。例如，我们可以通过 <code>str.contains</code> 检查各个电子邮件地址是否含有”gmail”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.str.contains(<span class="string">'gmail'</span>)</div></pre></td></tr></table></figure>
<pre><code>Dave     False
Steve     True
Rob       True
Wes        NaN
dtype: object
</code></pre><p>也可以使用正则表达式，还可以加上任意re选项（如IGNORECASE）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pattern = <span class="string">'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]&#123;2,4&#125;)'</span></div><div class="line">temp = data.str.findall(pattern, flags=re.IGNORECASE)</div><div class="line">temp</div></pre></td></tr></table></figure>
<pre><code>Dave     [(dave, google, com)]
Steve    [(steve, gmail, com)]
Rob        [(rob, gmail, com)]
Wes                        NaN
dtype: object
</code></pre><p>对字符串进行截取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.str[:<span class="number">5</span>]</div></pre></td></tr></table></figure>
<pre><code>Dave     dave@
Steve    steve
Rob      rob@g
Wes        NaN
dtype: object
</code></pre><p>更多的pandas字符串方法<br><img src="http://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h1 id="数据规整：聚合、合并和重塑"><a href="#数据规整：聚合、合并和重塑" class="headerlink" title="数据规整：聚合、合并和重塑"></a>数据规整：聚合、合并和重塑</h1><h2 id="层次化索引"><a href="#层次化索引" class="headerlink" title="层次化索引"></a>层次化索引</h2><p>层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.Series(np.random.randn(<span class="number">9</span>), index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>a  1    1.280879
   2   -0.233278
   3    0.700301
b  1    0.115678
   3    0.390445
c  1   -0.816532
   2   -0.972933
d  2    2.053691
   3    1.166844
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.index</div></pre></td></tr></table></figure>
<pre><code>MultiIndex(levels=[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], [1, 2, 3]],
           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1, 1, 2]])
</code></pre><p>对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'b'</span>]</div></pre></td></tr></table></figure>
<pre><code>1    0.115678
3    0.390445
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[<span class="string">'b'</span>:<span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<pre><code>b  1    0.115678
   3    0.390445
c  1   -0.816532
   2   -0.972933
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[[<span class="string">'b'</span>,<span class="string">'c'</span>]]</div></pre></td></tr></table></figure>
<pre><code>b  1    0.115678
   3    0.390445
c  1   -0.816532
   2   -0.972933
dtype: float64
</code></pre><p>在“内层”中进行选取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.loc[:, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<pre><code>a   -0.233278
c   -0.972933
d    2.053691
dtype: float64
</code></pre><p>unstack方法将这段数据重新安排到一个DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>1</th><br>      <th>2</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.280879</td><br>      <td>-0.233278</td><br>      <td>0.700301</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>0.115678</td><br>      <td>NaN</td><br>      <td>0.390445</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>-0.816532</td><br>      <td>-0.972933</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>2.053691</td><br>      <td>1.166844</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>unstack的逆运算是stack：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.unstack().stack()</div></pre></td></tr></table></figure>
<pre><code>a  1    1.280879
   2   -0.233278
   3    0.700301
b  1    0.115678
   3    0.390445
c  1   -0.816532
   2   -0.972933
d  2    2.053691
   3    1.166844
dtype: float64
</code></pre><p>对于一个DataFrame，每条轴都可以有分层索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]], </div><div class="line">        columns=[[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>], [<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]])</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th></th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>各层都可以有名字（可以是字符串，也可以是别的Python对象）。如果指定了名称，它们就会显示在控制台输出中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</div><div class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>有了部分列索引，因此可以轻松选取列分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame[<span class="string">'Ohio'</span>]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.index</div></pre></td></tr></table></figure>
<pre><code>MultiIndex(levels=[[&apos;a&apos;, &apos;b&apos;], [1, 2]],
           codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
           names=[&apos;key1&apos;, &apos;key2&apos;])
</code></pre><h3 id="重排与分级排序"><a href="#重排与分级排序" class="headerlink" title="重排与分级排序"></a>重排与分级排序</h3><p>重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序。</p>
<p>swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 交换 key1 和 key2 位置</span></div><div class="line">frame.swaplevel(<span class="string">'key1'</span>, <span class="string">'key2'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key2</th><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1</th><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <th>a</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <th>b</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <th>b</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>sort_index则根据单个级别中的值对数据进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里 level = 1 指的是 key2 列</span></div><div class="line">frame.sort_index(level=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>a</th><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.sort_index(level=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key2</th><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">1</th><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">2</th><br>      <th>a</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="根据级别汇总统计"><a href="#根据级别汇总统计" class="headerlink" title="根据级别汇总统计"></a>根据级别汇总统计</h3><p>许多对DataFrame和Series的描述和汇总统计都有一个level选项，它用于指定在某条轴上求和的级别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>6</td><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>9</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列方向 根据 level = key2 求和</span></div><div class="line">frame.sum(level=<span class="string">'key2'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th>state</th><br>      <th colspan="2" halign="left">Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>      <th>Green</th><br>    </tr><br>    <tr><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1</th><br>      <td>6</td><br>      <td>8</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>12</td><br>      <td>14</td><br>      <td>16</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 行方向 更具 level = color 求和</span></div><div class="line">frame.sum(level=<span class="string">'color'</span>, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>color</th><br>      <th>Green</th><br>      <th>Red</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>1</th><br>      <td>2</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>8</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>1</th><br>      <td>14</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>20</td><br>      <td>10</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h3><p>人们经常想要将DataFrame的一个或多个列当做行索引来用，或者可能希望将行索引变成DataFrame的列。<br>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>), </div><div class="line">                      <span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>],</div><div class="line">                      <span class="string">'d'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</div><div class="line">frame</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>7</td><br>      <td>one</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>6</td><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>5</td><br>      <td>one</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3</td><br>      <td>4</td><br>      <td>two</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>4</td><br>      <td>3</td><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>5</td><br>      <td>2</td><br>      <td>two</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>6</td><br>      <td>1</td><br>      <td>two</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">frame2 = frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">frame2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>    <tr><br>      <th>c</th><br>      <th>d</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="3" valign="top">one</th><br>      <th>0</th><br>      <td>0</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="4" valign="top">two</th><br>      <th>0</th><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>5</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>6</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>], drop=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>    <tr><br>      <th>c</th><br>      <th>d</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="3" valign="top">one</th><br>      <th>0</th><br>      <td>0</td><br>      <td>7</td><br>      <td>one</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>6</td><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>5</td><br>      <td>one</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th rowspan="4" valign="top">two</th><br>      <th>0</th><br>      <td>3</td><br>      <td>4</td><br>      <td>two</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4</td><br>      <td>3</td><br>      <td>two</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>5</td><br>      <td>2</td><br>      <td>two</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>6</td><br>      <td>1</td><br>      <td>two</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame2.reset_index()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>c</th><br>      <th>d</th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>one</td><br>      <td>0</td><br>      <td>0</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>one</td><br>      <td>1</td><br>      <td>1</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>one</td><br>      <td>2</td><br>      <td>2</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>two</td><br>      <td>0</td><br>      <td>3</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>two</td><br>      <td>1</td><br>      <td>4</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>two</td><br>      <td>2</td><br>      <td>5</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>two</td><br>      <td>3</td><br>      <td>6</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<h2 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h2><p>pandas对象中的数据可以通过一些方式进行合并：  </p>
<ol>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。SQL或其他关系型数据库的用户对此应该会比较熟悉，因为它实现的就是数据库的join操作。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ol>
<h3 id="数据库风格的DataFrame合并"><a href="#数据库风格的DataFrame合并" class="headerlink" title="数据库风格的DataFrame合并"></a>数据库风格的DataFrame合并</h3><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。pandas的merge函数是对数据应用这些算法的主要切入点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</div><div class="line"></div><div class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>], <span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</div><div class="line"></div><div class="line">df1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data1</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>c</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>a</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>b</td><br>      <td>6</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>d</td><br>      <td>2</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果没有指定关联的列，merge就会将重叠列的列名当做键。默认情况下，merge做的是“内连接”；结果中的键是交集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(df1, df2)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>6</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>2</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>a</td><br>      <td>5</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>指明要用哪个列进行连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>6</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>2</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>a</td><br>      <td>5</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果两个对象的列名不同，也可以分别进行指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df3 = pd.DataFrame(&#123;<span class="string">'lkey'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</div><div class="line"></div><div class="line">df4 = pd.DataFrame(&#123;<span class="string">'rkey'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>], <span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</div><div class="line"></div><div class="line">pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>lkey</th><br>      <th>data1</th><br>      <th>rkey</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0</td><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>6</td><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>2</td><br>      <td>a</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4</td><br>      <td>a</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>a</td><br>      <td>5</td><br>      <td>a</td><br>      <td>0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>指定连接方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(df1, df2, how=<span class="string">'outer'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>b</td><br>      <td>0.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>6.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>2.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>4.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>a</td><br>      <td>5.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>c</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>d</td><br>      <td>NaN</td><br>      <td>2.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p><img src="http://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="不同的连接类型"></p>
<p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>], </div><div class="line">                     <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>], </div><div class="line">                     <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</div><div class="line"></div><div class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],</div><div class="line">                               <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</div><div class="line">                               <span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</div><div class="line">left</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>lval</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">right</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>rval</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>bar</td><br>      <td>two</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>lval</th><br>      <th>rval</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1.0</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1.0</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>bar</td><br>      <td>two</td><br>      <td>NaN</td><br>      <td>7.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对于合并运算需要考虑的最后一个问题是对重复列名的处理。虽然你可以手工处理列名重叠的问题（查看前面介绍的重命名轴标签），但merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(left, right, on=<span class="string">'key1'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2_x</th><br>      <th>lval</th><br>      <th>key2_y</th><br>      <th>rval</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1</td><br>      <td>one</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1</td><br>      <td>one</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2</td><br>      <td>one</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2</td><br>      <td>one</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3</td><br>      <td>one</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3</td><br>      <td>two</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(left, right, on=<span class="string">'key1'</span>, suffixes=(<span class="string">'_left'</span>, <span class="string">'_right'</span>))</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2_left</th><br>      <th>lval</th><br>      <th>key2_right</th><br>      <th>rval</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1</td><br>      <td>one</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>foo</td><br>      <td>one</td><br>      <td>1</td><br>      <td>one</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2</td><br>      <td>one</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>foo</td><br>      <td>two</td><br>      <td>2</td><br>      <td>one</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3</td><br>      <td>one</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>bar</td><br>      <td>one</td><br>      <td>3</td><br>      <td>two</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>merge函数的参数  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="1">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="2"></p>
<h3 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h3><p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入 <code>left_index=True</code> 或 <code>right_index=True</code>（或两个都传）以说明索引应该被用作连接键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">left1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="string">'value'</span>: range(<span class="number">6</span>)&#125;)</div><div class="line">left1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>b</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>c</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">right1 = pd.DataFrame(&#123;<span class="string">'group_val'</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line">right1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>group_val</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>7.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(left1, right1, left_on=<span class="string">'key'</span>, right_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>value</th><br>      <th>group_val</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>0</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>2</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>3</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>b</td><br>      <td>4</td><br>      <td>7.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对于层次化索引的数据，事情就有点复杂了，因为索引的合并默认是多键合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lefth = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</div><div class="line">                      <span class="string">'key2'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</div><div class="line">                      <span class="string">'data'</span>: np.arange(<span class="number">5.</span>)&#125;)</div><div class="line">lefth</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Ohio</td><br>      <td>2000</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Ohio</td><br>      <td>2001</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Ohio</td><br>      <td>2002</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Nevada</td><br>      <td>2001</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>Nevada</td><br>      <td>2002</td><br>      <td>4.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),</div><div class="line">                      index=[[<span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>],</div><div class="line">                             [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],</div><div class="line">                      columns=[<span class="string">'event1'</span>, <span class="string">'event2'</span>])</div><div class="line">righth</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>event1</th><br>      <th>event2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Nevada</th><br>      <th>2001</th><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2000</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th rowspan="4" valign="top">Ohio</th><br>      <th>2000</th><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2000</th><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>2001</th><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>2002</th><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这种情况下，你必须以列表的形式指明用作合并键的多个列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data</th><br>      <th>event1</th><br>      <th>event2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Ohio</td><br>      <td>2000</td><br>      <td>0.0</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>Ohio</td><br>      <td>2000</td><br>      <td>0.0</td><br>      <td>6</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Ohio</td><br>      <td>2001</td><br>      <td>1.0</td><br>      <td>8</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Ohio</td><br>      <td>2002</td><br>      <td>2.0</td><br>      <td>10</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Nevada</td><br>      <td>2001</td><br>      <td>3.0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>同时使用合并双方的索引也没问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">left2 = pd.DataFrame([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>], [<span class="number">5.</span>, <span class="number">6.</span>]],</div><div class="line">                     index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>],</div><div class="line">                     columns=[<span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>])</div><div class="line">left2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Nevada</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.0</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">right2 = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">13</span>, <span class="number">14</span>]],</div><div class="line">                      index=[<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</div><div class="line">                      columns=[<span class="string">'Missouri'</span>, <span class="string">'Alabama'</span>])</div><div class="line">right2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Missouri</th><br>      <th>Alabama</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>b</th><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>9.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>11.0</td><br>      <td>12.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>13.0</td><br>      <td>14.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.merge(left2, right2, how=<span class="string">'outer'</span>, left_index=<span class="keyword">True</span>, right_index=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Nevada</th><br>      <th>Missouri</th><br>      <th>Alabama</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>11.0</td><br>      <td>12.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>5.0</td><br>      <td>6.0</td><br>      <td>13.0</td><br>      <td>14.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">left2.join(right2, how=<span class="string">'outer'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Nevada</th><br>      <th>Missouri</th><br>      <th>Alabama</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>11.0</td><br>      <td>12.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>5.0</td><br>      <td>6.0</td><br>      <td>13.0</td><br>      <td>14.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>DataFrame的join方法默认使用的是左连接，保留左边表的行索引。它还支持在调用的DataFrame的列上，连接传递的DataFrame索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">left1.join(right1, on=<span class="string">'key'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>value</th><br>      <th>group_val</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>0</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>2</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>3</td><br>      <td>3.5</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>b</td><br>      <td>4</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>c</td><br>      <td>5</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对于简单的索引合并，你还可以向join传入一组DataFrame </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">another = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">16.</span>, <span class="number">17.</span>]],</div><div class="line">                       index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</div><div class="line">                       columns=[<span class="string">'New York'</span>, <span class="string">'Oregon'</span>])</div><div class="line">another</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>New York</th><br>      <th>Oregon</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>9.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>11.0</td><br>      <td>12.0</td><br>    </tr><br>    <tr><br>      <th>f</th><br>      <td>16.0</td><br>      <td>17.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">left2.join([right2, another])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>Ohio</th><br>      <th>Nevada</th><br>      <th>Missouri</th><br>      <th>Alabama</th><br>      <th>New York</th><br>      <th>Oregon</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>3.0</td><br>      <td>4.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>      <td>9.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>5.0</td><br>      <td>6.0</td><br>      <td>13.0</td><br>      <td>14.0</td><br>      <td>11.0</td><br>      <td>12.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h3><p>另一种数据合并运算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenate函数可以用NumPy数组来做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">arr</div></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3,  0,  1,  2,  3],
       [ 4,  5,  6,  7,  4,  5,  6,  7],
       [ 8,  9, 10, 11,  8,  9, 10, 11]])
</code></pre><p>对于pandas对象（如Series和DataFrame），带有标签的轴使你能够进一步推广数组的连接运算。<br>pandas的concat函数提供了一种能够解决这些问题的可靠方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"></div><div class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line"></div><div class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'f'</span>, <span class="string">'g'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 把三个 series 连接在一起</span></div><div class="line">pd.concat([s1, s2, s3])</div></pre></td></tr></table></figure>
<pre><code>a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64
</code></pre><p>默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>/usr/local/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &apos;sort=False&apos;.

To retain the current behavior and silence the warning, pass &apos;sort=True&apos;.

  &quot;&quot;&quot;Entry point for launching an IPython kernel.
</code></pre><div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>      <th>2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>2.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>NaN</td><br>      <td>4.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>f</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>g</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这种情况下，另外的轴上没有重叠，从索引的有序并集（外连接）上就可以看出来。传入join=’inner’即可得到它们的交集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s4 = pd.concat([s1, s3])</div><div class="line">s4</div></pre></td></tr></table></figure>
<pre><code>a    0
b    1
f    5
g    6
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>/usr/local/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &apos;sort=False&apos;.

To retain the current behavior and silence the warning, pass &apos;sort=True&apos;.

  &quot;&quot;&quot;Entry point for launching an IPython kernel.
</code></pre><div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1.0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>f</th><br>      <td>NaN</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>g</th><br>      <td>NaN</td><br>      <td>6</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>通过 join_axes 指定要在其它轴上使用的索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>0</th><br>      <th>1</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1.0</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>不过有个问题，参与连接的片段在结果中区分不开。假设你想要在连接轴上创建一个层次化索引。使用keys参数即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</div><div class="line">result</div></pre></td></tr></table></figure>
<pre><code>one    a    0
       b    1
two    a    0
       b    1
three  f    5
       g    6
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>f</th><br>      <th>g</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果沿着 <code>axis=1</code> 对Series进行合并，则keys就会成为DataFrame的列头：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>], sort=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>NaN</td><br>      <td>2.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>d</th><br>      <td>NaN</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>e</th><br>      <td>NaN</td><br>      <td>4.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>f</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>g</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>同样的逻辑也适用于DataFrame对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</div><div class="line">df1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">'a'</span>, <span class="string">'c'</span>], columns=[<span class="string">'three'</span>, <span class="string">'four'</span>])</div><div class="line">df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>5</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>7</td><br>      <td>8</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">'level1'</span>, <span class="string">'level2'</span>], sort = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="2" halign="left">level1</th><br>      <th colspan="2" halign="left">level2</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2</td><br>      <td>3</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>5</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat(&#123;<span class="string">'level1'</span>: df1, <span class="string">'level2'</span>: df2&#125;, axis=<span class="number">1</span>, sort = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="2" halign="left">level1</th><br>      <th colspan="2" halign="left">level2</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2</td><br>      <td>3</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>5</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>我们可以用names参数命名创建的轴级别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">'level1'</span>, <span class="string">'level2'</span>], names=[<span class="string">'upper'</span>, <span class="string">'lower'</span>], sort = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th>upper</th><br>      <th colspan="2" halign="left">level1</th><br>      <th colspan="2" halign="left">level2</th><br>    </tr><br>    <tr><br>      <th>lower</th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>      <th>four</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0</td><br>      <td>1</td><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2</td><br>      <td>3</td><br>      <td>NaN</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>c</th><br>      <td>4</td><br>      <td>5</td><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>DataFrame 在连接的时候会使用原来的索引，可以通过 <code>ignore_index=True</code> 来放弃使用  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line">df1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-1.044321</td><br>      <td>-0.049004</td><br>      <td>0.026555</td><br>      <td>-0.315565</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.085761</td><br>      <td>0.873464</td><br>      <td>-1.368797</td><br>      <td>0.302554</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.277496</td><br>      <td>-0.570469</td><br>      <td>-0.606294</td><br>      <td>1.253497</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>])</div><div class="line">df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>b</th><br>      <th>d</th><br>      <th>a</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0.343570</td><br>      <td>-0.310123</td><br>      <td>-0.379563</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-1.083807</td><br>      <td>-1.480836</td><br>      <td>-1.255112</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([df1, df2], sort = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-1.044321</td><br>      <td>-0.049004</td><br>      <td>0.026555</td><br>      <td>-0.315565</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.085761</td><br>      <td>0.873464</td><br>      <td>-1.368797</td><br>      <td>0.302554</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.277496</td><br>      <td>-0.570469</td><br>      <td>-0.606294</td><br>      <td>1.253497</td><br>    </tr><br>    <tr><br>      <th>0</th><br>      <td>-0.379563</td><br>      <td>0.343570</td><br>      <td>NaN</td><br>      <td>-0.310123</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-1.255112</td><br>      <td>-1.083807</td><br>      <td>NaN</td><br>      <td>-1.480836</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.concat([df1, df2], ignore_index=<span class="keyword">True</span>, sort = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-1.044321</td><br>      <td>-0.049004</td><br>      <td>0.026555</td><br>      <td>-0.315565</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-0.085761</td><br>      <td>0.873464</td><br>      <td>-1.368797</td><br>      <td>0.302554</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.277496</td><br>      <td>-0.570469</td><br>      <td>-0.606294</td><br>      <td>1.253497</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>-0.379563</td><br>      <td>0.343570</td><br>      <td>NaN</td><br>      <td>-0.310123</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>-1.255112</td><br>      <td>-1.083807</td><br>      <td>NaN</td><br>      <td>-1.480836</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>concat函数的参数<br><img src="http://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="concat函数的参数"></p>
<h3 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h3><p>还有一种数据组合问题不能用简单的合并（merge）或连接（concatenation）运算来处理。比如说，你可能有索引全部或部分重叠的两个数据集。举个有启发性的例子，我们使用NumPy的where函数，它表示一种等价于面向数组的if-else：</p>
<p>就是用一个数据组合来填充另一个数据组合的空值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan], index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</div><div class="line"></div><div class="line">b = pd.Series(np.arange(len(a), dtype=np.float64), index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</div><div class="line">b[<span class="number">-1</span>] = np.nan</div><div class="line"></div><div class="line">a</div></pre></td></tr></table></figure>
<pre><code>f    NaN
e    2.5
d    NaN
c    3.5
b    4.5
a    NaN
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b</div></pre></td></tr></table></figure>
<pre><code>f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    NaN
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">np.where(pd.isnull(a), b, a)</div></pre></td></tr></table></figure>
<pre><code>array([0. , 2.5, 2. , 3.5, 4.5, nan])
</code></pre><p>Series 和 DataFrame 有一个 combine_first 方法，实现的也是一样的功能，还带有pandas的数据对齐：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[:<span class="number">-2</span>].combine_first(a[<span class="number">2</span>:])</div></pre></td></tr></table></figure>
<pre><code>a    NaN
b    4.5
c    3.0
d    2.0
e    1.0
f    0.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df1 = pd.DataFrame(&#123;<span class="string">'a'</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],</div><div class="line">                    <span class="string">'b'</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],</div><div class="line">                    <span class="string">'c'</span>: range(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</div><div class="line">df1</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>NaN</td><br>      <td>2.0</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>5.0</td><br>      <td>NaN</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>NaN</td><br>      <td>6.0</td><br>      <td>14</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(&#123;<span class="string">'a'</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],</div><div class="line">                    <span class="string">'b'</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</div><div class="line">df2</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>5.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4.0</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>NaN</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>7.0</td><br>      <td>8.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df1.combine_first(df2)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>4.0</td><br>      <td>2.0</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>5.0</td><br>      <td>4.0</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3.0</td><br>      <td>6.0</td><br>      <td>14.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>7.0</td><br>      <td>8.0</td><br>      <td>NaN</td><br>    </tr><br>  </tbody><br></table><br></div>



<h2 id="重塑和轴向旋转"><a href="#重塑和轴向旋转" class="headerlink" title="重塑和轴向旋转"></a>重塑和轴向旋转</h2><p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。</p>
<h3 id="重塑层次化索引"><a href="#重塑层次化索引" class="headerlink" title="重塑层次化索引"></a>重塑层次化索引</h3><p>层次化索引为DataFrame数据的重排任务提供了一种具有良好一致性的方式。主要功能有二：</p>
<ol>
<li>stack：将数据的列“旋转”为行。</li>
<li>unstack：将数据的行“旋转”为列。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</div><div class="line">                    index=pd.Index([<span class="string">'Ohio'</span>,<span class="string">'Colorado'</span>], name=<span class="string">'state'</span>),</div><div class="line">                    columns=pd.Index([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], name=<span class="string">'number'</span>))</div><div class="line">data</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>number</th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>    </tr><br>    <tr><br>      <th>state</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对该数据使用stack方法即可将列转换为行，得到一个Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = data.stack()</div><div class="line">result</div></pre></td></tr></table></figure>
<pre><code>state     number
Ohio      one       0
          two       1
          three     2
Colorado  one       3
          two       4
          three     5
dtype: int64
</code></pre><p>对于一个层次化索引的Series，你可以用unstack将其重排为一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>number</th><br>      <th>one</th><br>      <th>two</th><br>      <th>three</th><br>    </tr><br>    <tr><br>      <th>state</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Ohio</th><br>      <td>0</td><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>Colorado</th><br>      <td>3</td><br>      <td>4</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>默认情况下，unstack操作的是最内层（stack也是如此）。传入分层级别的编号或名称即可对其它级别进行unstack操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>state</th><br>      <th>Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th>number</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>0</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>1</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack(<span class="string">'state'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>state</th><br>      <th>Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th>number</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>0</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>1</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2</td><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果不是所有的级别值都能在各分组中找到的话，则unstack操作可能会引入缺失数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</div><div class="line"></div><div class="line">s2 = pd.Series([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</div><div class="line"></div><div class="line">data2 = pd.concat([s1, s2], keys=[<span class="string">'one'</span>, <span class="string">'two'</span>])</div><div class="line">data2</div></pre></td></tr></table></figure>
<pre><code>one  a    0
     b    1
     c    2
     d    3
two  c    4
     d    5
     e    6
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data2.unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>0.0</td><br>      <td>1.0</td><br>      <td>2.0</td><br>      <td>3.0</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>4.0</td><br>      <td>5.0</td><br>      <td>6.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data2.unstack().stack()</div></pre></td></tr></table></figure>
<pre><code>one  a    0.0
     b    1.0
     c    2.0
     d    3.0
two  c    4.0
     d    5.0
     e    6.0
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 保留 nan 数据</span></div><div class="line">data2.unstack().stack(dropna=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<pre><code>one  a    0.0
     b    1.0
     c    2.0
     d    3.0
     e    NaN
two  a    NaN
     b    NaN
     c    4.0
     d    5.0
     e    6.0
dtype: float64
</code></pre><p>在对DataFrame进行unstack操作时，作为旋转轴的级别将会成为结果中的最低级别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'left'</span>: result, <span class="string">'right'</span>: result + <span class="number">5</span>&#125;,</div><div class="line">                  columns=pd.Index([<span class="string">'left'</span>, <span class="string">'right'</span>], name=<span class="string">'side'</span>))</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>side</th><br>      <th>left</th><br>      <th>right</th><br>    </tr><br>    <tr><br>      <th>state</th><br>      <th>number</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="3" valign="top">Ohio</th><br>      <th>one</th><br>      <td>0</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>1</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th rowspan="3" valign="top">Colorado</th><br>      <th>one</th><br>      <td>3</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>4</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>5</td><br>      <td>10</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># state 列转换成行的时候，行的级别是最低的(在 side 下面)</span></div><div class="line">df.unstack(<span class="string">'state'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th>side</th><br>      <th colspan="2" halign="left">left</th><br>      <th colspan="2" halign="left">right</th><br>    </tr><br>    <tr><br>      <th>state</th><br>      <th>Ohio</th><br>      <th>Colorado</th><br>      <th>Ohio</th><br>      <th>Colorado</th><br>    </tr><br>    <tr><br>      <th>number</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>one</th><br>      <td>0</td><br>      <td>3</td><br>      <td>5</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>1</td><br>      <td>4</td><br>      <td>6</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>three</th><br>      <td>2</td><br>      <td>5</td><br>      <td>7</td><br>      <td>10</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>当调用stack，我们可以指明轴的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.unstack(<span class="string">'state'</span>).stack(<span class="string">'side'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>state</th><br>      <th>Colorado</th><br>      <th>Ohio</th><br>    </tr><br>    <tr><br>      <th>number</th><br>      <th>side</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">one</th><br>      <th>left</th><br>      <td>3</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>right</th><br>      <td>8</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">two</th><br>      <th>left</th><br>      <td>4</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>right</th><br>      <td>9</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">three</th><br>      <th>left</th><br>      <td>5</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>right</th><br>      <td>10</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="将“长格式”旋转为“宽格式”"><a href="#将“长格式”旋转为“宽格式”" class="headerlink" title="将“长格式”旋转为“宽格式”"></a>将“长格式”旋转为“宽格式”</h3><p>多个时间序列数据通常是以所谓的“长格式”（long）或“堆叠格式”（stacked）存储在数据库和CSV中的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_csv(<span class="string">'data/examples/macrodata.csv'</span>)</div><div class="line">data.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>year</th><br>      <th>quarter</th><br>      <th>realgdp</th><br>      <th>realcons</th><br>      <th>realinv</th><br>      <th>realgovt</th><br>      <th>realdpi</th><br>      <th>cpi</th><br>      <th>m1</th><br>      <th>tbilrate</th><br>      <th>unemp</th><br>      <th>pop</th><br>      <th>infl</th><br>      <th>realint</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1959.0</td><br>      <td>1.0</td><br>      <td>2710.349</td><br>      <td>1707.4</td><br>      <td>286.898</td><br>      <td>470.045</td><br>      <td>1886.9</td><br>      <td>28.98</td><br>      <td>139.7</td><br>      <td>2.82</td><br>      <td>5.8</td><br>      <td>177.146</td><br>      <td>0.00</td><br>      <td>0.00</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1959.0</td><br>      <td>2.0</td><br>      <td>2778.801</td><br>      <td>1733.7</td><br>      <td>310.859</td><br>      <td>481.301</td><br>      <td>1919.7</td><br>      <td>29.15</td><br>      <td>141.7</td><br>      <td>3.08</td><br>      <td>5.1</td><br>      <td>177.830</td><br>      <td>2.34</td><br>      <td>0.74</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1959.0</td><br>      <td>3.0</td><br>      <td>2775.488</td><br>      <td>1751.8</td><br>      <td>289.226</td><br>      <td>491.260</td><br>      <td>1916.4</td><br>      <td>29.35</td><br>      <td>140.5</td><br>      <td>3.82</td><br>      <td>5.3</td><br>      <td>178.657</td><br>      <td>2.74</td><br>      <td>1.09</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1959.0</td><br>      <td>4.0</td><br>      <td>2785.204</td><br>      <td>1753.7</td><br>      <td>299.356</td><br>      <td>484.052</td><br>      <td>1931.3</td><br>      <td>29.37</td><br>      <td>140.0</td><br>      <td>4.33</td><br>      <td>5.6</td><br>      <td>179.386</td><br>      <td>0.27</td><br>      <td>4.06</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1960.0</td><br>      <td>1.0</td><br>      <td>2847.699</td><br>      <td>1770.5</td><br>      <td>331.722</td><br>      <td>462.199</td><br>      <td>1955.5</td><br>      <td>29.54</td><br>      <td>139.6</td><br>      <td>3.50</td><br>      <td>5.2</td><br>      <td>180.007</td><br>      <td>2.31</td><br>      <td>1.19</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用几个时间列拼接成一个时间索引</span></div><div class="line">periods = pd.PeriodIndex(year=data.year, quarter=data.quarter, name=<span class="string">'date'</span>)</div><div class="line">periods</div></pre></td></tr></table></figure>
<pre><code>PeriodIndex([&apos;1959Q1&apos;, &apos;1959Q2&apos;, &apos;1959Q3&apos;, &apos;1959Q4&apos;, &apos;1960Q1&apos;, &apos;1960Q2&apos;,
             &apos;1960Q3&apos;, &apos;1960Q4&apos;, &apos;1961Q1&apos;, &apos;1961Q2&apos;,
             ...
             &apos;2007Q2&apos;, &apos;2007Q3&apos;, &apos;2007Q4&apos;, &apos;2008Q1&apos;, &apos;2008Q2&apos;, &apos;2008Q3&apos;,
             &apos;2008Q4&apos;, &apos;2009Q1&apos;, &apos;2009Q2&apos;, &apos;2009Q3&apos;],
            dtype=&apos;period[Q-DEC]&apos;, name=&apos;date&apos;, length=203, freq=&apos;Q-DEC&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建索引</span></div><div class="line">columns = pd.Index([<span class="string">'realgdp'</span>, <span class="string">'infl'</span>, <span class="string">'unemp'</span>], name=<span class="string">'item'</span>)</div><div class="line">columns</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;realgdp&apos;, &apos;infl&apos;, &apos;unemp&apos;], dtype=&apos;object&apos;, name=&apos;item&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 选取索引中的那几列</span></div><div class="line">data = data.reindex(columns=columns)</div><div class="line">data.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>item</th><br>      <th>realgdp</th><br>      <th>infl</th><br>      <th>unemp</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2710.349</td><br>      <td>0.00</td><br>      <td>5.8</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2778.801</td><br>      <td>2.34</td><br>      <td>5.1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2775.488</td><br>      <td>2.74</td><br>      <td>5.3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2785.204</td><br>      <td>0.27</td><br>      <td>5.6</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>2847.699</td><br>      <td>2.31</td><br>      <td>5.2</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 把索引赋值成时间索引</span></div><div class="line">data.index = periods.to_timestamp(<span class="string">'D'</span>, <span class="string">'end'</span>)</div><div class="line">data.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>item</th><br>      <th>realgdp</th><br>      <th>infl</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>2710.349</td><br>      <td>0.00</td><br>      <td>5.8</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2778.801</td><br>      <td>2.34</td><br>      <td>5.1</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2775.488</td><br>      <td>2.74</td><br>      <td>5.3</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>2785.204</td><br>      <td>0.27</td><br>      <td>5.6</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2847.699</td><br>      <td>2.31</td><br>      <td>5.2</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是date和item）的长格式。表中的每行代表一次观察。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ldata = data.stack().reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">'value'</span>&#125;)</div><div class="line">ldata.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>date</th><br>      <th>item</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2710.349</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>0.000</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>unemp</td><br>      <td>5.800</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2778.801</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>2.340</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.stack().head()</div></pre></td></tr></table></figure>
<pre><code>date                           item   
1959-03-31 23:59:59.999999999  realgdp    2710.349
                               infl          0.000
                               unemp         5.800
1959-06-30 23:59:59.999999999  realgdp    2778.801
                               infl          2.340
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.stack().reset_index().head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>date</th><br>      <th>item</th><br>      <th>0</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2710.349</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>0.000</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>unemp</td><br>      <td>5.800</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2778.801</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>2.340</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>关系型数据库（如MySQL）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，item列中的值的种类能够增加。在前面的例子中，date和item通常就是主键（用关系型数据库的说法），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢DataFrame，不同的item值分别形成一列，date列中的时间戳则用作索引。DataFrame的pivot方法完全可以实现这个转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pivoted = ldata.pivot(<span class="string">'date'</span>, <span class="string">'item'</span>, <span class="string">'value'</span>)</div><div class="line">pivoted.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>item</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>0.00</td><br>      <td>2710.349</td><br>      <td>5.8</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2.34</td><br>      <td>2778.801</td><br>      <td>5.1</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2.74</td><br>      <td>2775.488</td><br>      <td>5.3</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>0.27</td><br>      <td>2785.204</td><br>      <td>5.6</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2.31</td><br>      <td>2847.699</td><br>      <td>5.2</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>前两个传递的值分别用作行和列索引，最后一个可选值则是用于填充DataFrame的数据列。假设有两个需要同时重塑的数据列：</p>
<p>如果忽略最后一个参数，得到的DataFrame就会带有层次化的列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ldata.pivot(<span class="string">'date'</span>, <span class="string">'item'</span>).head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="3" halign="left">value</th><br>    </tr><br>    <tr><br>      <th>item</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>0.00</td><br>      <td>2710.349</td><br>      <td>5.8</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2.34</td><br>      <td>2778.801</td><br>      <td>5.1</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2.74</td><br>      <td>2775.488</td><br>      <td>5.3</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>0.27</td><br>      <td>2785.204</td><br>      <td>5.6</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2.31</td><br>      <td>2847.699</td><br>      <td>5.2</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ldata[<span class="string">'value2'</span>] = np.random.randn(len(ldata))</div><div class="line">ldata.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>date</th><br>      <th>item</th><br>      <th>value</th><br>      <th>value2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2710.349</td><br>      <td>0.363946</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>0.000</td><br>      <td>-0.287075</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>1959-03-31 23:59:59.999999999</td><br>      <td>unemp</td><br>      <td>5.800</td><br>      <td>0.144127</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>realgdp</td><br>      <td>2778.801</td><br>      <td>-0.491877</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1959-06-30 23:59:59.999999999</td><br>      <td>infl</td><br>      <td>2.340</td><br>      <td>0.725936</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ldata.pivot(<span class="string">'date'</span>, <span class="string">'item'</span>).head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="3" halign="left">value</th><br>      <th colspan="3" halign="left">value2</th><br>    </tr><br>    <tr><br>      <th>item</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>0.00</td><br>      <td>2710.349</td><br>      <td>5.8</td><br>      <td>-0.287075</td><br>      <td>0.363946</td><br>      <td>0.144127</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2.34</td><br>      <td>2778.801</td><br>      <td>5.1</td><br>      <td>0.725936</td><br>      <td>-0.491877</td><br>      <td>0.026073</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2.74</td><br>      <td>2775.488</td><br>      <td>5.3</td><br>      <td>1.025040</td><br>      <td>0.144513</td><br>      <td>-1.524801</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>0.27</td><br>      <td>2785.204</td><br>      <td>5.6</td><br>      <td>0.530287</td><br>      <td>-1.027258</td><br>      <td>-0.158004</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2.31</td><br>      <td>2847.699</td><br>      <td>5.2</td><br>      <td>-0.476289</td><br>      <td>0.037717</td><br>      <td>1.186384</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ldata.pivot(<span class="string">'date'</span>, <span class="string">'item'</span>, [<span class="string">'value'</span>, <span class="string">'value2'</span>]).head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="3" halign="left">value</th><br>      <th colspan="3" halign="left">value2</th><br>    </tr><br>    <tr><br>      <th>item</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>0.00</td><br>      <td>2710.349</td><br>      <td>5.8</td><br>      <td>-0.287075</td><br>      <td>0.363946</td><br>      <td>0.144127</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2.34</td><br>      <td>2778.801</td><br>      <td>5.1</td><br>      <td>0.725936</td><br>      <td>-0.491877</td><br>      <td>0.026073</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2.74</td><br>      <td>2775.488</td><br>      <td>5.3</td><br>      <td>1.025040</td><br>      <td>0.144513</td><br>      <td>-1.524801</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>0.27</td><br>      <td>2785.204</td><br>      <td>5.6</td><br>      <td>0.530287</td><br>      <td>-1.027258</td><br>      <td>-0.158004</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2.31</td><br>      <td>2847.699</td><br>      <td>5.2</td><br>      <td>-0.476289</td><br>      <td>0.037717</td><br>      <td>1.186384</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pivot其实就是用set_index创建层次化索引，再用unstack重塑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unstacked = ldata.set_index([<span class="string">'date'</span>, <span class="string">'item'</span>]).unstack(<span class="string">'item'</span>)</div><div class="line">unstacked.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="3" halign="left">value</th><br>      <th colspan="3" halign="left">value2</th><br>    </tr><br>    <tr><br>      <th>item</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>      <th>infl</th><br>      <th>realgdp</th><br>      <th>unemp</th><br>    </tr><br>    <tr><br>      <th>date</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1959-03-31 23:59:59.999999999</th><br>      <td>0.00</td><br>      <td>2710.349</td><br>      <td>5.8</td><br>      <td>-0.287075</td><br>      <td>0.363946</td><br>      <td>0.144127</td><br>    </tr><br>    <tr><br>      <th>1959-06-30 23:59:59.999999999</th><br>      <td>2.34</td><br>      <td>2778.801</td><br>      <td>5.1</td><br>      <td>0.725936</td><br>      <td>-0.491877</td><br>      <td>0.026073</td><br>    </tr><br>    <tr><br>      <th>1959-09-30 23:59:59.999999999</th><br>      <td>2.74</td><br>      <td>2775.488</td><br>      <td>5.3</td><br>      <td>1.025040</td><br>      <td>0.144513</td><br>      <td>-1.524801</td><br>    </tr><br>    <tr><br>      <th>1959-12-31 23:59:59.999999999</th><br>      <td>0.27</td><br>      <td>2785.204</td><br>      <td>5.6</td><br>      <td>0.530287</td><br>      <td>-1.027258</td><br>      <td>-0.158004</td><br>    </tr><br>    <tr><br>      <th>1960-03-31 23:59:59.999999999</th><br>      <td>2.31</td><br>      <td>2847.699</td><br>      <td>5.2</td><br>      <td>-0.476289</td><br>      <td>0.037717</td><br>      <td>1.186384</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="将“宽格式”旋转为“长格式”"><a href="#将“宽格式”旋转为“长格式”" class="headerlink" title="将“宽格式”旋转为“长格式”"></a>将“宽格式”旋转为“长格式”</h3><p>旋转DataFrame的逆运算是pandas.melt。它不是将一列转换到多个新的DataFrame，而是合并多个列成为一个，产生一个比输入长的DataFrame。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>],</div><div class="line">                   <span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">                   <span class="string">'B'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</div><div class="line">                   <span class="string">'C'</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>A</th><br>      <th>B</th><br>      <th>C</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>1</td><br>      <td>4</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>bar</td><br>      <td>2</td><br>      <td>5</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>baz</td><br>      <td>3</td><br>      <td>6</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>key列可能是分组指标，其它的列是数据值。当使用pandas.melt，我们必须指明哪些列是分组指标。下面使用key作为唯一的分组指标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">melted = pd.melt(df, [<span class="string">'key'</span>])</div><div class="line">melted</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>variable</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>A</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>bar</td><br>      <td>A</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>baz</td><br>      <td>A</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>foo</td><br>      <td>B</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>bar</td><br>      <td>B</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>baz</td><br>      <td>B</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>foo</td><br>      <td>C</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>bar</td><br>      <td>C</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>baz</td><br>      <td>C</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>使用pivot，可以重塑回原来的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reshaped = melted.pivot(<span class="string">'key'</span>, <span class="string">'variable'</span>, <span class="string">'value'</span>)</div><div class="line">reshaped</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>variable</th><br>      <th>A</th><br>      <th>B</th><br>      <th>C</th><br>    </tr><br>    <tr><br>      <th>key</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>bar</th><br>      <td>2</td><br>      <td>5</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>baz</th><br>      <td>3</td><br>      <td>6</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>foo</th><br>      <td>1</td><br>      <td>4</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>因为pivot的结果从列创建了一个索引，用作行标签，我们可以使用reset_index将数据移回列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reshaped.reset_index()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>variable</th><br>      <th>key</th><br>      <th>A</th><br>      <th>B</th><br>      <th>C</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>bar</td><br>      <td>2</td><br>      <td>5</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>baz</td><br>      <td>3</td><br>      <td>6</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>foo</td><br>      <td>1</td><br>      <td>4</td><br>      <td>7</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>还可以指定列的子集，作为值的列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.melt(df, id_vars=[<span class="string">'key'</span>], value_vars=[<span class="string">'A'</span>, <span class="string">'B'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>variable</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>foo</td><br>      <td>A</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>bar</td><br>      <td>A</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>baz</td><br>      <td>A</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>foo</td><br>      <td>B</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>bar</td><br>      <td>B</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>baz</td><br>      <td>B</td><br>      <td>6</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pandas.melt也可以不用分组指标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.melt(df, value_vars=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>variable</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>A</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>A</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>A</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>B</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>B</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>B</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>C</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>C</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>C</td><br>      <td>9</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.melt(df, value_vars=[<span class="string">'key'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>variable</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>key</td><br>      <td>foo</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>key</td><br>      <td>bar</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>key</td><br>      <td>baz</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>A</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>A</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>A</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>B</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>B</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>B</td><br>      <td>6</td><br>    </tr><br>  </tbody><br></table><br></div>



<h1 id="数据聚合与分组运算"><a href="#数据聚合与分组运算" class="headerlink" title="数据聚合与分组运算"></a>数据聚合与分组运算</h1><p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。</p>
<h2 id="GroupBy机制"><a href="#GroupBy机制" class="headerlink" title="GroupBy机制"></a>GroupBy机制</h2><p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语”split-apply-combine”（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-e5c671e09ecf94be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="图10-1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</div><div class="line">                   <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</div><div class="line">                  <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</div><div class="line">                  <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>one</td><br>      <td>1.192962</td><br>      <td>-1.675544</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>a</td><br>      <td>two</td><br>      <td>1.295617</td><br>      <td>-0.621154</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>one</td><br>      <td>2.506938</td><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>b</td><br>      <td>two</td><br>      <td>-0.503276</td><br>      <td>-0.698834</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>one</td><br>      <td>-0.204452</td><br>      <td>0.767441</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div></pre></td></tr></table></figure>
<pre><code>&lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x00000000080736D8&gt;
</code></pre><p>变量 <code>grouped</code> 是一个 <code>GroupBy</code> 对象。它实际上还没有进行任何计算，只是含有一些有关分组键 <code>df[&#39;key1&#39;]</code> 的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用 <code>GroupBy</code> 的 <code>mean</code> 方法来计算分组平均值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.mean()</div></pre></td></tr></table></figure>
<pre><code>key1
a    0.761376
b    1.001831
Name: data1, dtype: float64
</code></pre><p>数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df[‘key1’]就叫这个名字。</p>
<p>使用多个分组字段  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">means = df[<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>], df[<span class="string">'key2'</span>]]).mean()</div><div class="line">means</div></pre></td></tr></table></figure>
<pre><code>key1  key2
a     one     0.494255
      two     1.295617
b     one     2.506938
      two    -0.503276
Name: data1, dtype: float64
</code></pre><p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">means.unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>key2</th><br>      <th>one</th><br>      <th>two</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.494255</td><br>      <td>1.295617</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2.506938</td><br>      <td>-0.503276</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>分组键可以是任何长度适当 （等于要分组数据的长度）的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">states = np.array([<span class="string">'Ohio'</span>, <span class="string">'California'</span>, <span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>])</div><div class="line"></div><div class="line">years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</div><div class="line"></div><div class="line">df[<span class="string">'data1'</span>].groupby([states, years]).mean()</div></pre></td></tr></table></figure>
<pre><code>California  2005    1.295617
            2006    2.506938
Ohio        2005    0.344843
            2006   -0.204452
Name: data1, dtype: float64
</code></pre><p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).mean()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>0.761376</td><br>      <td>-0.509753</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>1.001831</td><br>      <td>-0.826561</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).mean()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>one</th><br>      <td>0.494255</td><br>      <td>-0.454052</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>1.295617</td><br>      <td>-0.621154</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>one</th><br>      <td>2.506938</td><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>-0.503276</td><br>      <td>-0.698834</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>你可能已经注意到了，第一个例子在执行df.groupby(‘key1’).mean()时，结果中没有key2列。这是因为df[‘key2’]不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿 groupby 做什么，都有可能会用到 GroupBy 的 size 方法，它可以返回一个含有分组大小的 Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).size()</div></pre></td></tr></table></figure>
<pre><code>key1  key2
a     one     2
      two     1
b     one     1
      two     1
dtype: int64
</code></pre><p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h3 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h3><p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>one</td><br>      <td>1.192962</td><br>      <td>-1.675544</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>a</td><br>      <td>two</td><br>      <td>1.295617</td><br>      <td>-0.621154</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>one</td><br>      <td>2.506938</td><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>b</td><br>      <td>two</td><br>      <td>-0.503276</td><br>      <td>-0.698834</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>one</td><br>      <td>-0.204452</td><br>      <td>0.767441</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">'key1'</span>):</div><div class="line">    print(name)</div><div class="line">    print(group)</div></pre></td></tr></table></figure>
<pre><code>a
  key1 key2     data1     data2
0    a  one  1.192962 -1.675544
1    a  two  1.295617 -0.621154
4    a  one -0.204452  0.767441
b
  key1 key2     data1     data2
2    b  one  2.506938 -0.954289
3    b  two -0.503276 -0.698834
</code></pre><p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]):</div><div class="line">    print((k1, k2))</div><div class="line">    print(group)</div></pre></td></tr></table></figure>
<pre><code>(&apos;a&apos;, &apos;one&apos;)
  key1 key2     data1     data2
0    a  one  1.192962 -1.675544
4    a  one -0.204452  0.767441
(&apos;a&apos;, &apos;two&apos;)
  key1 key2     data1     data2
1    a  two  1.295617 -0.621154
(&apos;b&apos;, &apos;one&apos;)
  key1 key2     data1     data2
2    b  one  2.506938 -0.954289
(&apos;b&apos;, &apos;two&apos;)
  key1 key2     data1     data2
3    b  two -0.503276 -0.698834
</code></pre><p>你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pieces = dict(list(df.groupby(<span class="string">'key1'</span>)))</div><div class="line">pieces[<span class="string">'b'</span>]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>one</td><br>      <td>2.506938</td><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>b</td><br>      <td>two</td><br>      <td>-0.503276</td><br>      <td>-0.698834</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>groupby默认是在 <code>axis=0</code> 上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.dtypes</div></pre></td></tr></table></figure>
<pre><code>key1      object
key2      object
data1    float64
data2    float64
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 按照数据类型分组</span></div><div class="line">grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> dtype, group <span class="keyword">in</span> grouped:</div><div class="line">    print(dtype)</div><div class="line">    print(group)</div></pre></td></tr></table></figure>
<pre><code>float64
      data1     data2
0  1.192962 -1.675544
1  1.295617 -0.621154
2  2.506938 -0.954289
3 -0.503276 -0.698834
4 -0.204452  0.767441
object
  key1 key2
0    a  one
1    a  two
2    b  one
3    b  two
4    a  one
</code></pre><h3 id="选取一列或列的子集"><a href="#选取一列或列的子集" class="headerlink" title="选取一列或列的子集"></a>选取一列或列的子集</h3><p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.groupby(&apos;key1&apos;)[&apos;data1&apos;]</div><div class="line">df.groupby(&apos;key1&apos;)[[&apos;data2&apos;]]</div></pre></td></tr></table></figure></p>
<p>是以下代码的语法糖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[&apos;data1&apos;].groupby(df[&apos;key1&apos;])</div><div class="line">df[[&apos;data2&apos;]].groupby(df[&apos;key1&apos;])</div></pre></td></tr></table></figure></p>
<p>尤其对于大数据集，很可能只需要对部分列进行聚合。<br>例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 双 [[]] 要生成 dataframe </span></div><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[[<span class="string">'data2'</span>]].mean()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>data2</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th>key2</th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">a</th><br>      <th>one</th><br>      <td>-0.454052</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>-0.621154</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">b</th><br>      <th>one</th><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>-0.698834</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 单 [] 要生成 series</span></div><div class="line">df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[<span class="string">'data2'</span>].mean()</div></pre></td></tr></table></figure>
<pre><code>key1  key2
a     one    -0.454052
      two    -0.621154
b     one    -0.954289
      two    -0.698834
Name: data2, dtype: float64
</code></pre><h3 id="通过字典或Series进行分组"><a href="#通过字典或Series进行分组" class="headerlink" title="通过字典或Series进行分组"></a>通过字典或Series进行分组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</div><div class="line">                      columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</div><div class="line">                      index=[<span class="string">'Joe'</span>, <span class="string">'Steve'</span>, <span class="string">'Wes'</span>, <span class="string">'Jim'</span>, <span class="string">'Travis'</span>])</div><div class="line">people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan</div><div class="line">people</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Joe</th><br>      <td>1.259713</td><br>      <td>-0.377088</td><br>      <td>0.520075</td><br>      <td>-0.881195</td><br>      <td>0.158433</td><br>    </tr><br>    <tr><br>      <th>Steve</th><br>      <td>-1.226603</td><br>      <td>0.648477</td><br>      <td>-0.317307</td><br>      <td>0.012993</td><br>      <td>0.584107</td><br>    </tr><br>    <tr><br>      <th>Wes</th><br>      <td>-1.811950</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>-0.576653</td><br>      <td>0.362209</td><br>    </tr><br>    <tr><br>      <th>Jim</th><br>      <td>0.951494</td><br>      <td>0.253198</td><br>      <td>-0.386507</td><br>      <td>1.172929</td><br>      <td>-1.755465</td><br>    </tr><br>    <tr><br>      <th>Travis</th><br>      <td>1.107800</td><br>      <td>0.297369</td><br>      <td>-0.279916</td><br>      <td>1.512150</td><br>      <td>0.755150</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapping = &#123;<span class="string">'a'</span>: <span class="string">'red'</span>, <span class="string">'b'</span>: <span class="string">'red'</span>, <span class="string">'c'</span>: <span class="string">'blue'</span>,  <span class="string">'d'</span>: <span class="string">'blue'</span>, <span class="string">'e'</span>: <span class="string">'red'</span>, <span class="string">'f'</span> : <span class="string">'orange'</span>&#125;</div></pre></td></tr></table></figure>
<p>将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">by_column = people.groupby(mapping, axis=<span class="number">1</span>)</div><div class="line">by_column.sum()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>blue</th><br>      <th>red</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Joe</th><br>      <td>-0.361120</td><br>      <td>1.041059</td><br>    </tr><br>    <tr><br>      <th>Steve</th><br>      <td>-0.304314</td><br>      <td>0.005981</td><br>    </tr><br>    <tr><br>      <th>Wes</th><br>      <td>-0.576653</td><br>      <td>-1.449741</td><br>    </tr><br>    <tr><br>      <th>Jim</th><br>      <td>0.786422</td><br>      <td>-0.550774</td><br>    </tr><br>    <tr><br>      <th>Travis</th><br>      <td>1.232234</td><br>      <td>2.160319</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">map_series = pd.Series(mapping)</div><div class="line">map_series</div></pre></td></tr></table></figure>
<pre><code>a       red
b       red
c      blue
d      blue
e       red
f    orange
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(map_series, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>blue</th><br>      <th>red</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Joe</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Steve</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Wes</th><br>      <td>1</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>Jim</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>Travis</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="通过函数进行分组"><a href="#通过函数进行分组" class="headerlink" title="通过函数进行分组"></a>通过函数进行分组</h3><p>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个<strong>索引值</strong>上被调用一次，其返回值就会被用作分组名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>Joe</th><br>      <td>1.259713</td><br>      <td>-0.377088</td><br>      <td>0.520075</td><br>      <td>-0.881195</td><br>      <td>0.158433</td><br>    </tr><br>    <tr><br>      <th>Steve</th><br>      <td>-1.226603</td><br>      <td>0.648477</td><br>      <td>-0.317307</td><br>      <td>0.012993</td><br>      <td>0.584107</td><br>    </tr><br>    <tr><br>      <th>Wes</th><br>      <td>-1.811950</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>-0.576653</td><br>      <td>0.362209</td><br>    </tr><br>    <tr><br>      <th>Jim</th><br>      <td>0.951494</td><br>      <td>0.253198</td><br>      <td>-0.386507</td><br>      <td>1.172929</td><br>      <td>-1.755465</td><br>    </tr><br>    <tr><br>      <th>Travis</th><br>      <td>1.107800</td><br>      <td>0.297369</td><br>      <td>-0.279916</td><br>      <td>1.512150</td><br>      <td>0.755150</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入 len 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(len).sum()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>3</th><br>      <td>0.399257</td><br>      <td>-0.123890</td><br>      <td>0.133568</td><br>      <td>-0.284919</td><br>      <td>-1.234823</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-1.226603</td><br>      <td>0.648477</td><br>      <td>-0.317307</td><br>      <td>0.012993</td><br>      <td>0.584107</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>1.107800</td><br>      <td>0.297369</td><br>      <td>-0.279916</td><br>      <td>1.512150</td><br>      <td>0.755150</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key_list = [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>]</div><div class="line">people.groupby([len, key_list]).min()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>      <th>e</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">3</th><br>      <th>one</th><br>      <td>-1.811950</td><br>      <td>-0.377088</td><br>      <td>0.520075</td><br>      <td>-0.881195</td><br>      <td>0.158433</td><br>    </tr><br>    <tr><br>      <th>two</th><br>      <td>0.951494</td><br>      <td>0.253198</td><br>      <td>-0.386507</td><br>      <td>1.172929</td><br>      <td>-1.755465</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <th>one</th><br>      <td>-1.226603</td><br>      <td>0.648477</td><br>      <td>-0.317307</td><br>      <td>0.012993</td><br>      <td>0.584107</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <th>two</th><br>      <td>1.107800</td><br>      <td>0.297369</td><br>      <td>-0.279916</td><br>      <td>1.512150</td><br>      <td>0.755150</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h3><p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">columns = pd.MultiIndex.from_arrays([[<span class="string">'US'</span>, <span class="string">'US'</span>, <span class="string">'US'</span>, <span class="string">'JP'</span>, <span class="string">'JP'</span>],</div><div class="line">                                    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]],</div><div class="line">                                    names=[<span class="string">'cty'</span>, <span class="string">'tenor'</span>])</div><div class="line">hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</div><div class="line">hier_df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th>cty</th><br>      <th colspan="3" halign="left">US</th><br>      <th colspan="2" halign="left">JP</th><br>    </tr><br>    <tr><br>      <th>tenor</th><br>      <th>1</th><br>      <th>3</th><br>      <th>5</th><br>      <th>1</th><br>      <th>3</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>-0.676690</td><br>      <td>-0.294463</td><br>      <td>0.275278</td><br>      <td>-0.315009</td><br>      <td>-0.454633</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>-1.509024</td><br>      <td>0.474617</td><br>      <td>-0.969700</td><br>      <td>-0.043906</td><br>      <td>-1.237097</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.379676</td><br>      <td>-0.577742</td><br>      <td>1.084988</td><br>      <td>0.499930</td><br>      <td>0.373462</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>1.097124</td><br>      <td>-0.437426</td><br>      <td>0.725242</td><br>      <td>-1.646882</td><br>      <td>0.571528</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>要根据级别分组，使用 level 关键字传递级别序号或名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hier_df.groupby(level=<span class="string">'cty'</span>, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th>cty</th><br>      <th>JP</th><br>      <th>US</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2</td><br>      <td>3</td><br>    </tr><br>  </tbody><br></table><br></div>



<h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。<br>常见的聚合运算<br><img src="http://upload-images.jianshu.io/upload_images/7178691-ba8de524e08b1b6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="常用的聚合运算方法"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key1</th><br>      <th>key2</th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>one</td><br>      <td>1.192962</td><br>      <td>-1.675544</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>a</td><br>      <td>two</td><br>      <td>1.295617</td><br>      <td>-0.621154</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>b</td><br>      <td>one</td><br>      <td>2.506938</td><br>      <td>-0.954289</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>b</td><br>      <td>two</td><br>      <td>-0.503276</td><br>      <td>-0.698834</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>a</td><br>      <td>one</td><br>      <td>-0.204452</td><br>      <td>0.767441</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped = df.groupby(<span class="string">'key1'</span>)</div></pre></td></tr></table></figure>
<p>如果要使用你自己的聚合函数，只需将其传入 aggregate 或 agg 方法即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">return</span> arr.max() - arr.min()</div><div class="line">grouped.agg(peak_to_peak)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>data1</th><br>      <th>data2</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>1.500069</td><br>      <td>2.442985</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>3.010214</td><br>      <td>0.255455</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>获取分组后的描述信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.describe()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th colspan="8" halign="left">data1</th><br>      <th colspan="8" halign="left">data2</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>count</th><br>      <th>mean</th><br>      <th>std</th><br>      <th>min</th><br>      <th>25%</th><br>      <th>50%</th><br>      <th>75%</th><br>      <th>max</th><br>      <th>count</th><br>      <th>mean</th><br>      <th>std</th><br>      <th>min</th><br>      <th>25%</th><br>      <th>50%</th><br>      <th>75%</th><br>      <th>max</th><br>    </tr><br>    <tr><br>      <th>key1</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>a</th><br>      <td>3.0</td><br>      <td>0.761376</td><br>      <td>0.838004</td><br>      <td>-0.204452</td><br>      <td>0.494255</td><br>      <td>1.192962</td><br>      <td>1.244290</td><br>      <td>1.295617</td><br>      <td>3.0</td><br>      <td>-0.509753</td><br>      <td>1.225297</td><br>      <td>-1.675544</td><br>      <td>-1.148349</td><br>      <td>-0.621154</td><br>      <td>0.073143</td><br>      <td>0.767441</td><br>    </tr><br>    <tr><br>      <th>b</th><br>      <td>2.0</td><br>      <td>1.001831</td><br>      <td>2.128543</td><br>      <td>-0.503276</td><br>      <td>0.249277</td><br>      <td>1.001831</td><br>      <td>1.754384</td><br>      <td>2.506938</td><br>      <td>2.0</td><br>      <td>-0.826561</td><br>      <td>0.180634</td><br>      <td>-0.954289</td><br>      <td>-0.890425</td><br>      <td>-0.826561</td><br>      <td>-0.762697</td><br>      <td>-0.698834</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>自定义聚合函数要比图中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
<h3 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h3><p>你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tips = pd.read_csv(<span class="string">'data/examples/tips.csv'</span>)</div><div class="line">tips[<span class="string">'tip_pct'</span>] = tips[<span class="string">'tip'</span>] / tips[<span class="string">'total_bill'</span>]</div><div class="line">tips.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>16.99</td><br>      <td>1.01</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.059447</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>10.34</td><br>      <td>1.66</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.160542</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>21.01</td><br>      <td>3.50</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.166587</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>23.68</td><br>      <td>3.31</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.139780</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>24.59</td><br>      <td>3.61</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.146808</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>首先，我根据天和smoker对tips进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped = tips.groupby([<span class="string">'day'</span>, <span class="string">'smoker'</span>])</div></pre></td></tr></table></figure>
<p>获取分组后的一列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped_pct = grouped[<span class="string">'tip_pct'</span>]</div></pre></td></tr></table></figure>
<p>按照指定的方式对这一列分组进行结算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped_pct.agg(<span class="string">'mean'</span>)</div></pre></td></tr></table></figure>
<pre><code>day   smoker
Fri   No        0.151650
      Yes       0.174783
Sat   No        0.158048
      Yes       0.147906
Sun   No        0.160113
      Yes       0.187250
Thur  No        0.160298
      Yes       0.163863
Name: tip_pct, dtype: float64
</code></pre><p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># peak_to_peak 是上面自定义的一个方法</span></div><div class="line">grouped_pct.agg([<span class="string">'mean'</span>, <span class="string">'std'</span>, peak_to_peak])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>mean</th><br>      <th>std</th><br>      <th>peak_to_peak</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>0.151650</td><br>      <td>0.028123</td><br>      <td>0.067349</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.174783</td><br>      <td>0.051293</td><br>      <td>0.159925</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>0.158048</td><br>      <td>0.039767</td><br>      <td>0.235193</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.147906</td><br>      <td>0.061375</td><br>      <td>0.290095</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>0.160113</td><br>      <td>0.042347</td><br>      <td>0.193226</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.187250</td><br>      <td>0.154134</td><br>      <td>0.644685</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>0.160298</td><br>      <td>0.038774</td><br>      <td>0.193350</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.163863</td><br>      <td>0.039389</td><br>      <td>0.151240</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是’’，这样的辨识度就很低了（通过函数的name属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</p>
<p>设置方法的字段别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped_pct.agg([(<span class="string">'foo'</span>, <span class="string">'mean'</span>), (<span class="string">'bar'</span>, np.std)])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>foo</th><br>      <th>bar</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>0.151650</td><br>      <td>0.028123</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.174783</td><br>      <td>0.051293</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>0.158048</td><br>      <td>0.039767</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.147906</td><br>      <td>0.061375</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>0.160113</td><br>      <td>0.042347</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.187250</td><br>      <td>0.154134</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>0.160298</td><br>      <td>0.038774</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.163863</td><br>      <td>0.039389</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">functions = [<span class="string">'count'</span>, <span class="string">'mean'</span>, <span class="string">'max'</span>]</div><div class="line"></div><div class="line">result = grouped[<span class="string">'tip_pct'</span>, <span class="string">'total_bill'</span>].agg(functions)</div><div class="line"></div><div class="line">result</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="3" halign="left">tip_pct</th><br>      <th colspan="3" halign="left">total_bill</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th></th><br>      <th>count</th><br>      <th>mean</th><br>      <th>max</th><br>      <th>count</th><br>      <th>mean</th><br>      <th>max</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>4</td><br>      <td>0.151650</td><br>      <td>0.187735</td><br>      <td>4</td><br>      <td>18.420000</td><br>      <td>22.75</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>15</td><br>      <td>0.174783</td><br>      <td>0.263480</td><br>      <td>15</td><br>      <td>16.813333</td><br>      <td>40.17</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>45</td><br>      <td>0.158048</td><br>      <td>0.291990</td><br>      <td>45</td><br>      <td>19.661778</td><br>      <td>48.33</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>42</td><br>      <td>0.147906</td><br>      <td>0.325733</td><br>      <td>42</td><br>      <td>21.276667</td><br>      <td>50.81</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>57</td><br>      <td>0.160113</td><br>      <td>0.252672</td><br>      <td>57</td><br>      <td>20.506667</td><br>      <td>48.17</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>19</td><br>      <td>0.187250</td><br>      <td>0.710345</td><br>      <td>19</td><br>      <td>24.120000</td><br>      <td>45.35</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>45</td><br>      <td>0.160298</td><br>      <td>0.266312</td><br>      <td>45</td><br>      <td>17.113111</td><br>      <td>41.19</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>17</td><br>      <td>0.163863</td><br>      <td>0.241255</td><br>      <td>17</td><br>      <td>19.190588</td><br>      <td>43.11</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result[<span class="string">'tip_pct'</span>]</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>count</th><br>      <th>mean</th><br>      <th>max</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>4</td><br>      <td>0.151650</td><br>      <td>0.187735</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>15</td><br>      <td>0.174783</td><br>      <td>0.263480</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>45</td><br>      <td>0.158048</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>42</td><br>      <td>0.147906</td><br>      <td>0.325733</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>57</td><br>      <td>0.160113</td><br>      <td>0.252672</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>19</td><br>      <td>0.187250</td><br>      <td>0.710345</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>45</td><br>      <td>0.160298</td><br>      <td>0.266312</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>17</td><br>      <td>0.163863</td><br>      <td>0.241255</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ftuples = [(<span class="string">'Durchschnitt'</span>, <span class="string">'mean'</span>),(<span class="string">'Abweichung'</span>, np.var)]</div><div class="line"></div><div class="line">grouped[<span class="string">'tip_pct'</span>, <span class="string">'total_bill'</span>].agg(ftuples)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="2" halign="left">tip_pct</th><br>      <th colspan="2" halign="left">total_bill</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th></th><br>      <th>Durchschnitt</th><br>      <th>Abweichung</th><br>      <th>Durchschnitt</th><br>      <th>Abweichung</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>0.151650</td><br>      <td>0.000791</td><br>      <td>18.420000</td><br>      <td>25.596333</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.174783</td><br>      <td>0.002631</td><br>      <td>16.813333</td><br>      <td>82.562438</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>0.158048</td><br>      <td>0.001581</td><br>      <td>19.661778</td><br>      <td>79.908965</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.147906</td><br>      <td>0.003767</td><br>      <td>21.276667</td><br>      <td>101.387535</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>0.160113</td><br>      <td>0.001793</td><br>      <td>20.506667</td><br>      <td>66.099980</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.187250</td><br>      <td>0.023757</td><br>      <td>24.120000</td><br>      <td>109.046044</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>0.160298</td><br>      <td>0.001503</td><br>      <td>17.113111</td><br>      <td>59.625081</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.163863</td><br>      <td>0.001551</td><br>      <td>19.190588</td><br>      <td>69.808518</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 分组后，对 tip 列进行 np.max 运算； size 列进行 sum 运算</span></div><div class="line">grouped.agg(&#123;<span class="string">'tip'</span> : np.max, <span class="string">'size'</span> : <span class="string">'sum'</span>&#125;)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>tip</th><br>      <th>size</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>3.50</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>4.73</td><br>      <td>31</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>9.00</td><br>      <td>115</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>10.00</td><br>      <td>104</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>6.00</td><br>      <td>167</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>6.50</td><br>      <td>49</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>6.70</td><br>      <td>112</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>5.00</td><br>      <td>40</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 分组后，对 tip_pct 列分别进行 多种 运算； size 列进行 sum 运算</span></div><div class="line">grouped.agg(&#123;<span class="string">'tip_pct'</span> : [<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'std'</span>],  <span class="string">'size'</span> : <span class="string">'sum'</span>&#125;)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="4" halign="left">tip_pct</th><br>      <th>size</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th></th><br>      <th>min</th><br>      <th>max</th><br>      <th>mean</th><br>      <th>std</th><br>      <th>sum</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>0.120385</td><br>      <td>0.187735</td><br>      <td>0.151650</td><br>      <td>0.028123</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.103555</td><br>      <td>0.263480</td><br>      <td>0.174783</td><br>      <td>0.051293</td><br>      <td>31</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>0.056797</td><br>      <td>0.291990</td><br>      <td>0.158048</td><br>      <td>0.039767</td><br>      <td>115</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.035638</td><br>      <td>0.325733</td><br>      <td>0.147906</td><br>      <td>0.061375</td><br>      <td>104</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>0.059447</td><br>      <td>0.252672</td><br>      <td>0.160113</td><br>      <td>0.042347</td><br>      <td>167</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.065660</td><br>      <td>0.710345</td><br>      <td>0.187250</td><br>      <td>0.154134</td><br>      <td>49</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>0.072961</td><br>      <td>0.266312</td><br>      <td>0.160298</td><br>      <td>0.038774</td><br>      <td>112</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.090014</td><br>      <td>0.241255</td><br>      <td>0.163863</td><br>      <td>0.039389</td><br>      <td>40</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p>
<h3 id="以“没有行索引”的形式返回聚合数据"><a href="#以“没有行索引”的形式返回聚合数据" class="headerlink" title="以“没有行索引”的形式返回聚合数据"></a>以“没有行索引”的形式返回聚合数据</h3><p>默认返回的数据是带分组索引的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'day'</span>, <span class="string">'smoker'</span>]).mean()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>18.420000</td><br>      <td>2.812500</td><br>      <td>2.250000</td><br>      <td>0.151650</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>16.813333</td><br>      <td>2.714000</td><br>      <td>2.066667</td><br>      <td>0.174783</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>19.661778</td><br>      <td>3.102889</td><br>      <td>2.555556</td><br>      <td>0.158048</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>21.276667</td><br>      <td>2.875476</td><br>      <td>2.476190</td><br>      <td>0.147906</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>20.506667</td><br>      <td>3.167895</td><br>      <td>2.929825</td><br>      <td>0.160113</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>24.120000</td><br>      <td>3.516842</td><br>      <td>2.578947</td><br>      <td>0.187250</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>17.113111</td><br>      <td>2.673778</td><br>      <td>2.488889</td><br>      <td>0.160298</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>19.190588</td><br>      <td>3.030000</td><br>      <td>2.352941</td><br>      <td>0.163863</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>可以向 groupby 传入 <code>as_index=False</code> 以禁用该功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'day'</span>, <span class="string">'smoker'</span>], as_index=<span class="keyword">False</span>).mean()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>day</th><br>      <th>smoker</th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Fri</td><br>      <td>No</td><br>      <td>18.420000</td><br>      <td>2.812500</td><br>      <td>2.250000</td><br>      <td>0.151650</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Fri</td><br>      <td>Yes</td><br>      <td>16.813333</td><br>      <td>2.714000</td><br>      <td>2.066667</td><br>      <td>0.174783</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Sat</td><br>      <td>No</td><br>      <td>19.661778</td><br>      <td>3.102889</td><br>      <td>2.555556</td><br>      <td>0.158048</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Sat</td><br>      <td>Yes</td><br>      <td>21.276667</td><br>      <td>2.875476</td><br>      <td>2.476190</td><br>      <td>0.147906</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>Sun</td><br>      <td>No</td><br>      <td>20.506667</td><br>      <td>3.167895</td><br>      <td>2.929825</td><br>      <td>0.160113</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>Sun</td><br>      <td>Yes</td><br>      <td>24.120000</td><br>      <td>3.516842</td><br>      <td>2.578947</td><br>      <td>0.187250</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>Thur</td><br>      <td>No</td><br>      <td>17.113111</td><br>      <td>2.673778</td><br>      <td>2.488889</td><br>      <td>0.160298</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>Thur</td><br>      <td>Yes</td><br>      <td>19.190588</td><br>      <td>3.030000</td><br>      <td>2.352941</td><br>      <td>0.163863</td><br>    </tr><br>  </tbody><br></table><br></div>



<h2 id="apply：一般性的“拆分－应用－合并”"><a href="#apply：一般性的“拆分－应用－合并”" class="headerlink" title="apply：一般性的“拆分－应用－合并”"></a>apply：一般性的“拆分－应用－合并”</h2><p>apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。<br><img src="http://upload-images.jianshu.io/upload_images/7178691-7e8bb217f599b4ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>16.99</td><br>      <td>1.01</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.059447</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>10.34</td><br>      <td>1.66</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.160542</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>21.01</td><br>      <td>3.50</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.166587</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>23.68</td><br>      <td>3.31</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.139780</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>24.59</td><br>      <td>3.61</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.146808</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(df, n=<span class="number">5</span>, column=<span class="string">'tip_pct'</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> df.sort_values(by=column)[-n:]</div><div class="line">top(tips, n = <span class="number">6</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>109</th><br>      <td>14.31</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.279525</td><br>    </tr><br>    <tr><br>      <th>183</th><br>      <td>23.17</td><br>      <td>6.50</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.280535</td><br>    </tr><br>    <tr><br>      <th>232</th><br>      <td>11.61</td><br>      <td>3.39</td><br>      <td>No</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th>67</th><br>      <td>3.07</td><br>      <td>1.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>1</td><br>      <td>0.325733</td><br>    </tr><br>    <tr><br>      <th>178</th><br>      <td>9.60</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.416667</td><br>    </tr><br>    <tr><br>      <th>172</th><br>      <td>7.25</td><br>      <td>5.15</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.710345</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果对smoker分组并用该函数调用apply，就会得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>).apply(top)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>    <tr><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="5" valign="top">No</th><br>      <th>88</th><br>      <td>24.71</td><br>      <td>5.85</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.236746</td><br>    </tr><br>    <tr><br>      <th>185</th><br>      <td>20.69</td><br>      <td>5.00</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>5</td><br>      <td>0.241663</td><br>    </tr><br>    <tr><br>      <th>51</th><br>      <td>10.29</td><br>      <td>2.60</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.252672</td><br>    </tr><br>    <tr><br>      <th>149</th><br>      <td>7.51</td><br>      <td>2.00</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.266312</td><br>    </tr><br>    <tr><br>      <th>232</th><br>      <td>11.61</td><br>      <td>3.39</td><br>      <td>No</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th rowspan="5" valign="top">Yes</th><br>      <th>109</th><br>      <td>14.31</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.279525</td><br>    </tr><br>    <tr><br>      <th>183</th><br>      <td>23.17</td><br>      <td>6.50</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.280535</td><br>    </tr><br>    <tr><br>      <th>67</th><br>      <td>3.07</td><br>      <td>1.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>1</td><br>      <td>0.325733</td><br>    </tr><br>    <tr><br>      <th>178</th><br>      <td>9.60</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.416667</td><br>    </tr><br>    <tr><br>      <th>172</th><br>      <td>7.25</td><br>      <td>5.15</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.710345</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p>
<p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby([<span class="string">'smoker'</span>, <span class="string">'day'</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">'total_bill'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>    <tr><br>      <th>smoker</th><br>      <th>day</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="4" valign="top">No</th><br>      <th>Fri</th><br>      <th>94</th><br>      <td>22.75</td><br>      <td>3.25</td><br>      <td>No</td><br>      <td>Fri</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.142857</td><br>    </tr><br>    <tr><br>      <th>Sat</th><br>      <th>212</th><br>      <td>48.33</td><br>      <td>9.00</td><br>      <td>No</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.186220</td><br>    </tr><br>    <tr><br>      <th>Sun</th><br>      <th>156</th><br>      <td>48.17</td><br>      <td>5.00</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>6</td><br>      <td>0.103799</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <th>142</th><br>      <td>41.19</td><br>      <td>5.00</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>5</td><br>      <td>0.121389</td><br>    </tr><br>    <tr><br>      <th rowspan="4" valign="top">Yes</th><br>      <th>Fri</th><br>      <th>95</th><br>      <td>40.17</td><br>      <td>4.73</td><br>      <td>Yes</td><br>      <td>Fri</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.117750</td><br>    </tr><br>    <tr><br>      <th>Sat</th><br>      <th>170</th><br>      <td>50.81</td><br>      <td>10.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.196812</td><br>    </tr><br>    <tr><br>      <th>Sun</th><br>      <th>182</th><br>      <td>45.35</td><br>      <td>3.50</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.077178</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <th>197</th><br>      <td>43.11</td><br>      <td>5.00</td><br>      <td>Yes</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>4</td><br>      <td>0.115982</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = tips.groupby(<span class="string">'smoker'</span>)[<span class="string">'tip_pct'</span>].describe()</div><div class="line">result</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>count</th><br>      <th>mean</th><br>      <th>std</th><br>      <th>min</th><br>      <th>25%</th><br>      <th>50%</th><br>      <th>75%</th><br>      <th>max</th><br>    </tr><br>    <tr><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>No</th><br>      <td>151.0</td><br>      <td>0.159328</td><br>      <td>0.039910</td><br>      <td>0.056797</td><br>      <td>0.136906</td><br>      <td>0.155625</td><br>      <td>0.185014</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>93.0</td><br>      <td>0.163196</td><br>      <td>0.085119</td><br>      <td>0.035638</td><br>      <td>0.106771</td><br>      <td>0.153846</td><br>      <td>0.195059</td><br>      <td>0.710345</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack(<span class="string">'smoker'</span>)</div></pre></td></tr></table></figure>
<pre><code>       smoker
count  No        151.000000
       Yes        93.000000
mean   No          0.159328
       Yes         0.163196
std    No          0.039910
       Yes         0.085119
min    No          0.056797
       Yes         0.035638
25%    No          0.136906
       Yes         0.106771
50%    No          0.155625
       Yes         0.153846
75%    No          0.185014
       Yes         0.195059
max    No          0.291990
       Yes         0.710345
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.unstack(<span class="string">'smoker'</span>).swaplevel(<span class="number">0</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<pre><code>smoker       
No      count    151.000000
Yes     count     93.000000
No      mean       0.159328
Yes     mean       0.163196
No      std        0.039910
Yes     std        0.085119
No      min        0.056797
Yes     min        0.035638
No      25%        0.136906
Yes     25%        0.106771
No      50%        0.155625
Yes     50%        0.153846
No      75%        0.185014
Yes     75%        0.195059
No      max        0.291990
Yes     max        0.710345
dtype: float64
</code></pre><p>applay 的实现方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = <span class="keyword">lambda</span> x: x.describe()</div><div class="line">tips.groupby(<span class="string">'smoker'</span>)[<span class="string">'tip_pct'</span>].apply(f)</div></pre></td></tr></table></figure>
<pre><code>smoker       
No      count    151.000000
        mean       0.159328
        std        0.039910
        min        0.056797
        25%        0.136906
        50%        0.155625
        75%        0.185014
        max        0.291990
Yes     count     93.000000
        mean       0.163196
        std        0.085119
        min        0.035638
        25%        0.106771
        50%        0.153846
        75%        0.195059
        max        0.710345
Name: tip_pct, dtype: float64
</code></pre><h3 id="禁止分组键"><a href="#禁止分组键" class="headerlink" title="禁止分组键"></a>禁止分组键</h3><p>分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将 <code>group_keys=False</code> 传入 groupby 即可禁止该效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>).apply(top)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>    <tr><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="5" valign="top">No</th><br>      <th>88</th><br>      <td>24.71</td><br>      <td>5.85</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.236746</td><br>    </tr><br>    <tr><br>      <th>185</th><br>      <td>20.69</td><br>      <td>5.00</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>5</td><br>      <td>0.241663</td><br>    </tr><br>    <tr><br>      <th>51</th><br>      <td>10.29</td><br>      <td>2.60</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.252672</td><br>    </tr><br>    <tr><br>      <th>149</th><br>      <td>7.51</td><br>      <td>2.00</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.266312</td><br>    </tr><br>    <tr><br>      <th>232</th><br>      <td>11.61</td><br>      <td>3.39</td><br>      <td>No</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th rowspan="5" valign="top">Yes</th><br>      <th>109</th><br>      <td>14.31</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.279525</td><br>    </tr><br>    <tr><br>      <th>183</th><br>      <td>23.17</td><br>      <td>6.50</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.280535</td><br>    </tr><br>    <tr><br>      <th>67</th><br>      <td>3.07</td><br>      <td>1.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>1</td><br>      <td>0.325733</td><br>    </tr><br>    <tr><br>      <th>178</th><br>      <td>9.60</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.416667</td><br>    </tr><br>    <tr><br>      <th>172</th><br>      <td>7.25</td><br>      <td>5.15</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.710345</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.groupby(<span class="string">'smoker'</span>, group_keys=<span class="keyword">False</span>).apply(top)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>88</th><br>      <td>24.71</td><br>      <td>5.85</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.236746</td><br>    </tr><br>    <tr><br>      <th>185</th><br>      <td>20.69</td><br>      <td>5.00</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>5</td><br>      <td>0.241663</td><br>    </tr><br>    <tr><br>      <th>51</th><br>      <td>10.29</td><br>      <td>2.60</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.252672</td><br>    </tr><br>    <tr><br>      <th>149</th><br>      <td>7.51</td><br>      <td>2.00</td><br>      <td>No</td><br>      <td>Thur</td><br>      <td>Lunch</td><br>      <td>2</td><br>      <td>0.266312</td><br>    </tr><br>    <tr><br>      <th>232</th><br>      <td>11.61</td><br>      <td>3.39</td><br>      <td>No</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.291990</td><br>    </tr><br>    <tr><br>      <th>109</th><br>      <td>14.31</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.279525</td><br>    </tr><br>    <tr><br>      <th>183</th><br>      <td>23.17</td><br>      <td>6.50</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.280535</td><br>    </tr><br>    <tr><br>      <th>67</th><br>      <td>3.07</td><br>      <td>1.00</td><br>      <td>Yes</td><br>      <td>Sat</td><br>      <td>Dinner</td><br>      <td>1</td><br>      <td>0.325733</td><br>    </tr><br>    <tr><br>      <th>178</th><br>      <td>9.60</td><br>      <td>4.00</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.416667</td><br>    </tr><br>    <tr><br>      <th>172</th><br>      <td>7.25</td><br>      <td>5.15</td><br>      <td>Yes</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.710345</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="分位数和桶分析"><a href="#分位数和桶分析" class="headerlink" title="分位数和桶分析"></a>分位数和桶分析</h3><p>pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(&#123;<span class="string">'data1'</span>: np.random.randn(<span class="number">1000</span>),</div><div class="line">                      <span class="string">'data2'</span>: np.random.randn(<span class="number">1000</span>)&#125;)</div><div class="line">quartiles = pd.cut(frame.data1, <span class="number">4</span>)</div><div class="line">quartiles.head()</div></pre></td></tr></table></figure>
<pre><code>0    (-1.698, 0.0798]
1     (0.0798, 1.857]
2    (-1.698, 0.0798]
3     (0.0798, 1.857]
4    (-1.698, 0.0798]
Name: data1, dtype: category
Categories (4, interval[float64]): [(-3.482, -1.698] &lt; (-1.698, 0.0798] &lt; (0.0798, 1.857] &lt; (1.857, 3.635]]
</code></pre><p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stats</span><span class="params">(group)</span>:</span></div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">'min'</span>: group.min(), <span class="string">'max'</span>: group.max(), <span class="string">'count'</span>: group.count(), <span class="string">'mean'</span>: group.mean()&#125;</div><div class="line"></div><div class="line">grouped = frame.data2.groupby(quartiles)</div><div class="line">grouped.apply(get_stats).unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>count</th><br>      <th>max</th><br>      <th>mean</th><br>      <th>min</th><br>    </tr><br>    <tr><br>      <th>data1</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>(-3.482, -1.698]</th><br>      <td>38.0</td><br>      <td>2.161012</td><br>      <td>0.286213</td><br>      <td>-1.820655</td><br>    </tr><br>    <tr><br>      <th>(-1.698, 0.0798]</th><br>      <td>472.0</td><br>      <td>3.762126</td><br>      <td>-0.044402</td><br>      <td>-3.260810</td><br>    </tr><br>    <tr><br>      <th>(0.0798, 1.857]</th><br>      <td>452.0</td><br>      <td>3.026034</td><br>      <td>-0.040110</td><br>      <td>-3.122991</td><br>    </tr><br>    <tr><br>      <th>(1.857, 3.635]</th><br>      <td>38.0</td><br>      <td>1.482856</td><br>      <td>-0.191989</td><br>      <td>-1.969943</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入 <code>labels=False</code> 即可只获取分位数的编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="keyword">False</span>)</div><div class="line">grouping.head()</div></pre></td></tr></table></figure>
<pre><code>0    1
1    5
2    3
3    5
4    3
Name: data1, dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temp = pd.qcut(frame.data1, <span class="number">10</span>)</div><div class="line">temp.head()</div></pre></td></tr></table></figure>
<pre><code>0    (-1.261, -0.827]
1     (0.0684, 0.326]
2    (-0.476, -0.193]
3     (0.0684, 0.326]
4    (-0.476, -0.193]
Name: data1, dtype: category
Categories (10, interval[float64]): [(-3.476, -1.261] &lt; (-1.261, -0.827] &lt; (-0.827, -0.476] &lt; (-0.476, -0.193] ... (0.326, 0.596] &lt; (0.596, 0.925] &lt; (0.925, 1.368] &lt; (1.368, 3.635]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grouped = frame.data2.groupby(grouping)</div><div class="line">grouped.apply(get_stats).unstack()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>count</th><br>      <th>max</th><br>      <th>mean</th><br>      <th>min</th><br>    </tr><br>    <tr><br>      <th>data1</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>100.0</td><br>      <td>2.621324</td><br>      <td>0.070152</td><br>      <td>-2.179777</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>100.0</td><br>      <td>2.462273</td><br>      <td>-0.049077</td><br>      <td>-2.289337</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>100.0</td><br>      <td>3.762126</td><br>      <td>-0.077355</td><br>      <td>-3.260810</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>100.0</td><br>      <td>2.707121</td><br>      <td>0.016885</td><br>      <td>-2.551321</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>100.0</td><br>      <td>1.805644</td><br>      <td>-0.043425</td><br>      <td>-2.499053</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>100.0</td><br>      <td>2.079105</td><br>      <td>-0.021532</td><br>      <td>-2.564312</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>100.0</td><br>      <td>3.026034</td><br>      <td>-0.123689</td><br>      <td>-3.122991</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>100.0</td><br>      <td>2.220393</td><br>      <td>-0.105029</td><br>      <td>-2.630459</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>100.0</td><br>      <td>2.454573</td><br>      <td>-0.046064</td><br>      <td>-2.195948</td><br>    </tr><br>    <tr><br>      <th>9</th><br>      <td>100.0</td><br>      <td>2.476637</td><br>      <td>0.024066</td><br>      <td>-2.050193</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="示例：用特定于分组的值填充缺失值"><a href="#示例：用特定于分组的值填充缺失值" class="headerlink" title="示例：用特定于分组的值填充缺失值"></a>示例：用特定于分组的值填充缺失值</h3><p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = pd.Series(np.random.randn(<span class="number">6</span>))</div><div class="line">s[::<span class="number">2</span>] = np.nan</div><div class="line">s</div></pre></td></tr></table></figure>
<pre><code>0         NaN
1   -1.698228
2         NaN
3    0.250362
4         NaN
5   -0.981594
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.fillna(s.mean())</div></pre></td></tr></table></figure>
<pre><code>0   -0.809820
1   -1.698228
2   -0.809820
3    0.250362
4   -0.809820
5   -0.981594
dtype: float64
</code></pre><p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">states = [<span class="string">'Ohio'</span>, <span class="string">'New York'</span>, <span class="string">'Vermont'</span>, <span class="string">'Florida'</span>,  <span class="string">'Oregon'</span>, <span class="string">'Nevada'</span>, <span class="string">'California'</span>, <span class="string">'Idaho'</span>]</div><div class="line"></div><div class="line">group_key = [<span class="string">'East'</span>] * <span class="number">4</span> + [<span class="string">'West'</span>] * <span class="number">4</span></div><div class="line"></div><div class="line">group_key</div></pre></td></tr></table></figure>
<pre><code>[&apos;East&apos;, &apos;East&apos;, &apos;East&apos;, &apos;East&apos;, &apos;West&apos;, &apos;West&apos;, &apos;West&apos;, &apos;West&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.Series(np.random.randn(<span class="number">8</span>), index=states)</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>Ohio         -0.343101
New York      1.024389
Vermont       1.311144
Florida      -0.423204
Oregon        0.114283
Nevada       -1.089131
California   -1.727345
Idaho        -0.830830
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data[[<span class="string">'Vermont'</span>, <span class="string">'Nevada'</span>, <span class="string">'Idaho'</span>]] = np.nan</div><div class="line">data</div></pre></td></tr></table></figure>
<pre><code>Ohio         -0.343101
New York      1.024389
Vermont            NaN
Florida      -0.423204
Oregon        0.114283
Nevada             NaN
California   -1.727345
Idaho              NaN
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.groupby(group_key).mean()</div></pre></td></tr></table></figure>
<pre><code>East    0.086028
West   -0.806531
dtype: float64
</code></pre><p>我们可以用分组平均值去填充NA值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</div><div class="line"></div><div class="line">data.groupby(group_key).apply(fill_mean)</div></pre></td></tr></table></figure>
<pre><code>Ohio         -0.343101
New York      1.024389
Vermont       0.086028
Florida      -0.423204
Oregon        0.114283
Nevada       -0.806531
California   -1.727345
Idaho        -0.806531
dtype: float64
</code></pre><p>也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fill_values = &#123;<span class="string">'East'</span>: <span class="number">0.5</span>, <span class="string">'West'</span>: <span class="number">-1</span>&#125;</div><div class="line"></div><div class="line">fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</div><div class="line"></div><div class="line">data.groupby(group_key).apply(fill_func)</div></pre></td></tr></table></figure>
<pre><code>Ohio         -0.343101
New York      1.024389
Vermont       0.500000
Florida      -0.423204
Oregon        0.114283
Nevada       -1.000000
California   -1.727345
Idaho        -1.000000
dtype: float64
</code></pre><h3 id="示例：分组加权平均数和相关系数"><a href="#示例：分组加权平均数和相关系数" class="headerlink" title="示例：分组加权平均数和相关系数"></a>示例：分组加权平均数和相关系数</h3><p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'category'</span>: [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>],</div><div class="line">                   <span class="string">'data'</span>: np.random.randn(<span class="number">8</span>),</div><div class="line">                   <span class="string">'weights'</span>: np.random.rand(<span class="number">8</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>category</th><br>      <th>data</th><br>      <th>weights</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>-0.980463</td><br>      <td>0.247153</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>a</td><br>      <td>0.148452</td><br>      <td>0.912352</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>a</td><br>      <td>-1.067199</td><br>      <td>0.719493</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>1.837065</td><br>      <td>0.883523</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>b</td><br>      <td>-1.030439</td><br>      <td>0.907246</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>b</td><br>      <td>0.120672</td><br>      <td>0.538387</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>b</td><br>      <td>-0.306529</td><br>      <td>0.423223</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>b</td><br>      <td>0.709020</td><br>      <td>0.552725</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>利用 category 计算分组加权平均数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">grouped = df.groupby(<span class="string">'category'</span>)</div><div class="line"></div><div class="line">get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">'data'</span>], weights=g[<span class="string">'weights'</span>])</div><div class="line"></div><div class="line">grouped.apply(get_wavg)</div></pre></td></tr></table></figure>
<pre><code>category
a    0.270898
b   -0.250964
dtype: float64
</code></pre><p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px = pd.read_csv(<span class="string">'data/examples/stock_px_2.csv'</span>, parse_dates=<span class="keyword">True</span>, index_col=<span class="number">0</span>)</div><div class="line">close_px.info()</div></pre></td></tr></table></figure>
<pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;
DatetimeIndex: 2214 entries, 2003-01-02 to 2011-10-14
Data columns (total 4 columns):
AAPL    2214 non-null float64
MSFT    2214 non-null float64
XOM     2214 non-null float64
SPX     2214 non-null float64
dtypes: float64(4)
memory usage: 86.5 KB
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>MSFT</th><br>      <th>XOM</th><br>      <th>SPX</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2003-01-02</th><br>      <td>7.40</td><br>      <td>21.11</td><br>      <td>29.22</td><br>      <td>909.03</td><br>    </tr><br>    <tr><br>      <th>2003-01-03</th><br>      <td>7.45</td><br>      <td>21.14</td><br>      <td>29.24</td><br>      <td>908.59</td><br>    </tr><br>    <tr><br>      <th>2003-01-06</th><br>      <td>7.45</td><br>      <td>21.52</td><br>      <td>29.96</td><br>      <td>929.01</td><br>    </tr><br>    <tr><br>      <th>2003-01-07</th><br>      <td>7.43</td><br>      <td>21.93</td><br>      <td>28.95</td><br>      <td>922.93</td><br>    </tr><br>    <tr><br>      <th>2003-01-08</th><br>      <td>7.28</td><br>      <td>21.31</td><br>      <td>28.83</td><br>      <td>909.93</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">'SPX'</span>])</div><div class="line"><span class="comment"># 我们使用pct_change计算close_px的百分比变化</span></div><div class="line">rets = close_px.pct_change().dropna()</div><div class="line">rets.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>MSFT</th><br>      <th>XOM</th><br>      <th>SPX</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2003-01-03</th><br>      <td>0.006757</td><br>      <td>0.001421</td><br>      <td>0.000684</td><br>      <td>-0.000484</td><br>    </tr><br>    <tr><br>      <th>2003-01-06</th><br>      <td>0.000000</td><br>      <td>0.017975</td><br>      <td>0.024624</td><br>      <td>0.022474</td><br>    </tr><br>    <tr><br>      <th>2003-01-07</th><br>      <td>-0.002685</td><br>      <td>0.019052</td><br>      <td>-0.033712</td><br>      <td>-0.006545</td><br>    </tr><br>    <tr><br>      <th>2003-01-08</th><br>      <td>-0.020188</td><br>      <td>-0.028272</td><br>      <td>-0.004145</td><br>      <td>-0.014086</td><br>    </tr><br>    <tr><br>      <th>2003-01-09</th><br>      <td>0.008242</td><br>      <td>0.029094</td><br>      <td>0.021159</td><br>      <td>0.019386</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">get_year = <span class="keyword">lambda</span> x: x.year</div><div class="line"></div><div class="line">by_year = rets.groupby(get_year)</div><div class="line"></div><div class="line">by_year.apply(spx_corr)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>AAPL</th><br>      <th>MSFT</th><br>      <th>XOM</th><br>      <th>SPX</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2003</th><br>      <td>0.541124</td><br>      <td>0.745174</td><br>      <td>0.661265</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2004</th><br>      <td>0.374283</td><br>      <td>0.588531</td><br>      <td>0.557742</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2005</th><br>      <td>0.467540</td><br>      <td>0.562374</td><br>      <td>0.631010</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2006</th><br>      <td>0.428267</td><br>      <td>0.406126</td><br>      <td>0.518514</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2007</th><br>      <td>0.508118</td><br>      <td>0.658770</td><br>      <td>0.786264</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2008</th><br>      <td>0.681434</td><br>      <td>0.804626</td><br>      <td>0.828303</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2009</th><br>      <td>0.707103</td><br>      <td>0.654902</td><br>      <td>0.797921</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2010</th><br>      <td>0.710105</td><br>      <td>0.730118</td><br>      <td>0.839057</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2011</th><br>      <td>0.691931</td><br>      <td>0.800996</td><br>      <td>0.859975</td><br>      <td>1.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">'AAPL'</span>].corr(g[<span class="string">'MSFT'</span>]))</div></pre></td></tr></table></figure>
<pre><code>2003    0.480868
2004    0.259024
2005    0.300093
2006    0.161735
2007    0.417738
2008    0.611901
2009    0.432738
2010    0.571946
2011    0.581987
dtype: float64
</code></pre><h3 id="示例：组级别的线性回归"><a href="#示例：组级别的线性回归" class="headerlink" title="示例：组级别的线性回归"></a>示例：组级别的线性回归</h3><p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">regress</span><span class="params">(data, yvar, xvars)</span>:</span></div><div class="line">    Y = data[yvar]</div><div class="line">    X = data[xvars]</div><div class="line">    X[<span class="string">'intercept'</span>] = <span class="number">1.</span></div><div class="line">    result = sm.OLS(Y, X).fit()</div><div class="line">    <span class="keyword">return</span> result.params</div></pre></td></tr></table></figure>
<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">by_year.apply(regress, <span class="string">'AAPL'</span>, [<span class="string">'SPX'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>SPX</th><br>      <th>intercept</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2003</th><br>      <td>1.195406</td><br>      <td>0.000710</td><br>    </tr><br>    <tr><br>      <th>2004</th><br>      <td>1.363463</td><br>      <td>0.004201</td><br>    </tr><br>    <tr><br>      <th>2005</th><br>      <td>1.766415</td><br>      <td>0.003246</td><br>    </tr><br>    <tr><br>      <th>2006</th><br>      <td>1.645496</td><br>      <td>0.000080</td><br>    </tr><br>    <tr><br>      <th>2007</th><br>      <td>1.198761</td><br>      <td>0.003438</td><br>    </tr><br>    <tr><br>      <th>2008</th><br>      <td>0.968016</td><br>      <td>-0.001110</td><br>    </tr><br>    <tr><br>      <th>2009</th><br>      <td>0.879103</td><br>      <td>0.002954</td><br>    </tr><br>    <tr><br>      <th>2010</th><br>      <td>1.052608</td><br>      <td>0.001261</td><br>    </tr><br>    <tr><br>      <th>2011</th><br>      <td>0.806605</td><br>      <td>0.001514</td><br>    </tr><br>  </tbody><br></table><br></div>



<h2 id="透视表和交叉表"><a href="#透视表和交叉表" class="headerlink" title="透视表和交叉表"></a>透视表和交叉表</h2><p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>total_bill</th><br>      <th>tip</th><br>      <th>smoker</th><br>      <th>day</th><br>      <th>time</th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>16.99</td><br>      <td>1.01</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.059447</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>10.34</td><br>      <td>1.66</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.160542</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>21.01</td><br>      <td>3.50</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>3</td><br>      <td>0.166587</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>23.68</td><br>      <td>3.31</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>2</td><br>      <td>0.139780</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>24.59</td><br>      <td>3.61</td><br>      <td>No</td><br>      <td>Sun</td><br>      <td>Dinner</td><br>      <td>4</td><br>      <td>0.146808</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(index=[<span class="string">'day'</span>, <span class="string">'smoker'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>size</th><br>      <th>tip</th><br>      <th>tip_pct</th><br>      <th>total_bill</th><br>    </tr><br>    <tr><br>      <th>day</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Fri</th><br>      <th>No</th><br>      <td>2.250000</td><br>      <td>2.812500</td><br>      <td>0.151650</td><br>      <td>18.420000</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>2.066667</td><br>      <td>2.714000</td><br>      <td>0.174783</td><br>      <td>16.813333</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sat</th><br>      <th>No</th><br>      <td>2.555556</td><br>      <td>3.102889</td><br>      <td>0.158048</td><br>      <td>19.661778</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>2.476190</td><br>      <td>2.875476</td><br>      <td>0.147906</td><br>      <td>21.276667</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Sun</th><br>      <th>No</th><br>      <td>2.929825</td><br>      <td>3.167895</td><br>      <td>0.160113</td><br>      <td>20.506667</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>2.578947</td><br>      <td>3.516842</td><br>      <td>0.187250</td><br>      <td>24.120000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Thur</th><br>      <th>No</th><br>      <td>2.488889</td><br>      <td>2.673778</td><br>      <td>0.160298</td><br>      <td>17.113111</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>2.352941</td><br>      <td>3.030000</td><br>      <td>0.163863</td><br>      <td>19.190588</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size'</span>], index=[<span class="string">'time'</span>, <span class="string">'day'</span>], columns=<span class="string">'smoker'</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="2" halign="left">size</th><br>      <th colspan="2" halign="left">tip_pct</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>smoker</th><br>      <th>No</th><br>      <th>Yes</th><br>      <th>No</th><br>      <th>Yes</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th>day</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="4" valign="top">Dinner</th><br>      <th>Fri</th><br>      <td>2.000000</td><br>      <td>2.222222</td><br>      <td>0.139622</td><br>      <td>0.165347</td><br>    </tr><br>    <tr><br>      <th>Sat</th><br>      <td>2.555556</td><br>      <td>2.476190</td><br>      <td>0.158048</td><br>      <td>0.147906</td><br>    </tr><br>    <tr><br>      <th>Sun</th><br>      <td>2.929825</td><br>      <td>2.578947</td><br>      <td>0.160113</td><br>      <td>0.187250</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.000000</td><br>      <td>NaN</td><br>      <td>0.159744</td><br>      <td>NaN</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Lunch</th><br>      <th>Fri</th><br>      <td>3.000000</td><br>      <td>1.833333</td><br>      <td>0.187735</td><br>      <td>0.188937</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.500000</td><br>      <td>2.352941</td><br>      <td>0.160311</td><br>      <td>0.163863</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size'</span>], index=[<span class="string">'time'</span>, <span class="string">'day'</span>])</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>size</th><br>      <th>tip_pct</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th>day</th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="4" valign="top">Dinner</th><br>      <th>Fri</th><br>      <td>2.166667</td><br>      <td>0.158916</td><br>    </tr><br>    <tr><br>      <th>Sat</th><br>      <td>2.517241</td><br>      <td>0.153152</td><br>    </tr><br>    <tr><br>      <th>Sun</th><br>      <td>2.842105</td><br>      <td>0.166897</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.000000</td><br>      <td>0.159744</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Lunch</th><br>      <th>Fri</th><br>      <td>2.000000</td><br>      <td>0.188765</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.459016</td><br>      <td>0.161301</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>还可以对这个表作进一步的处理，传入 <code>margins=True</code> 添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size'</span>], index=[<span class="string">'time'</span>, <span class="string">'day'</span>], columns=<span class="string">'smoker'</span>, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead tr th {<br>        text-align: left;<br>    }<br><br>    .dataframe thead tr:last-of-type th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr><br>      <th></th><br>      <th></th><br>      <th colspan="3" halign="left">size</th><br>      <th colspan="3" halign="left">tip_pct</th><br>    </tr><br>    <tr><br>      <th></th><br>      <th>smoker</th><br>      <th>No</th><br>      <th>Yes</th><br>      <th>All</th><br>      <th>No</th><br>      <th>Yes</th><br>      <th>All</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th>day</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="4" valign="top">Dinner</th><br>      <th>Fri</th><br>      <td>2.000000</td><br>      <td>2.222222</td><br>      <td>2.166667</td><br>      <td>0.139622</td><br>      <td>0.165347</td><br>      <td>0.158916</td><br>    </tr><br>    <tr><br>      <th>Sat</th><br>      <td>2.555556</td><br>      <td>2.476190</td><br>      <td>2.517241</td><br>      <td>0.158048</td><br>      <td>0.147906</td><br>      <td>0.153152</td><br>    </tr><br>    <tr><br>      <th>Sun</th><br>      <td>2.929825</td><br>      <td>2.578947</td><br>      <td>2.842105</td><br>      <td>0.160113</td><br>      <td>0.187250</td><br>      <td>0.166897</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.000000</td><br>      <td>NaN</td><br>      <td>2.000000</td><br>      <td>0.159744</td><br>      <td>NaN</td><br>      <td>0.159744</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Lunch</th><br>      <th>Fri</th><br>      <td>3.000000</td><br>      <td>1.833333</td><br>      <td>2.000000</td><br>      <td>0.187735</td><br>      <td>0.188937</td><br>      <td>0.188765</td><br>    </tr><br>    <tr><br>      <th>Thur</th><br>      <td>2.500000</td><br>      <td>2.352941</td><br>      <td>2.459016</td><br>      <td>0.160311</td><br>      <td>0.163863</td><br>      <td>0.161301</td><br>    </tr><br>    <tr><br>      <th>All</th><br>      <th></th><br>      <td>2.668874</td><br>      <td>2.408602</td><br>      <td>2.569672</td><br>      <td>0.159328</td><br>      <td>0.163196</td><br>      <td>0.160803</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(<span class="string">'tip_pct'</span>, index=[<span class="string">'time'</span>, <span class="string">'smoker'</span>], columns=<span class="string">'day'</span>, aggfunc=len, margins=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>day</th><br>      <th>Fri</th><br>      <th>Sat</th><br>      <th>Sun</th><br>      <th>Thur</th><br>      <th>All</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="2" valign="top">Dinner</th><br>      <th>No</th><br>      <td>3.0</td><br>      <td>45.0</td><br>      <td>57.0</td><br>      <td>1.0</td><br>      <td>106.0</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>9.0</td><br>      <td>42.0</td><br>      <td>19.0</td><br>      <td>NaN</td><br>      <td>70.0</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">Lunch</th><br>      <th>No</th><br>      <td>1.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>44.0</td><br>      <td>45.0</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>6.0</td><br>      <td>NaN</td><br>      <td>NaN</td><br>      <td>17.0</td><br>      <td>23.0</td><br>    </tr><br>    <tr><br>      <th>All</th><br>      <th></th><br>      <td>19.0</td><br>      <td>87.0</td><br>      <td>76.0</td><br>      <td>62.0</td><br>      <td>244.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tips.pivot_table(<span class="string">'tip_pct'</span>, index=[<span class="string">'time'</span>, <span class="string">'size'</span>, <span class="string">'smoker'</span>],</div><div class="line">                 columns=<span class="string">'day'</span>, aggfunc=<span class="string">'mean'</span>, fill_value=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th></th><br>      <th>day</th><br>      <th>Fri</th><br>      <th>Sat</th><br>      <th>Sun</th><br>      <th>Thur</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th>size</th><br>      <th>smoker</th><br>      <th></th><br>      <th></th><br>      <th></th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th rowspan="11" valign="top">Dinner</th><br>      <th rowspan="2" valign="top">1</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.137931</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.000000</td><br>      <td>0.325733</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">2</th><br>      <th>No</th><br>      <td>0.139622</td><br>      <td>0.162705</td><br>      <td>0.168859</td><br>      <td>0.159744</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.171297</td><br>      <td>0.148668</td><br>      <td>0.207893</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">3</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.154661</td><br>      <td>0.152663</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.000000</td><br>      <td>0.144995</td><br>      <td>0.152660</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">4</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.150096</td><br>      <td>0.148143</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.117750</td><br>      <td>0.124515</td><br>      <td>0.193370</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">5</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.206928</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.000000</td><br>      <td>0.106572</td><br>      <td>0.065660</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.103799</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="10" valign="top">Lunch</th><br>      <th rowspan="2" valign="top">1</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.181728</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.223776</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">2</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.166005</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.181969</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.158843</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">3</th><br>      <th>No</th><br>      <td>0.187735</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.084246</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.204952</td><br>    </tr><br>    <tr><br>      <th rowspan="2" valign="top">4</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.138919</td><br>    </tr><br>    <tr><br>      <th>Yes</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.155410</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.121389</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <th>No</th><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.000000</td><br>      <td>0.173706</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>pivot_table的参数说明请参见表<br><img src="http://upload-images.jianshu.io/upload_images/7178691-c9e01844c4803a42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h1 id="pandas高级应用"><a href="#pandas高级应用" class="headerlink" title="pandas高级应用"></a>pandas高级应用</h1><h2 id="分类数据"><a href="#分类数据" class="headerlink" title="分类数据"></a>分类数据</h2><p>通过使用它，提高性能和内存的使用率。</p>
<h3 id="背景和目的"><a href="#背景和目的" class="headerlink" title="背景和目的"></a>背景和目的</h3><p>表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">values = pd.Series([<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'apple'</span>] * <span class="number">2</span>)</div><div class="line">values</div></pre></td></tr></table></figure>
<pre><code>0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
dtype: object
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.unique(values)</div></pre></td></tr></table></figure>
<pre><code>array([&apos;apple&apos;, &apos;orange&apos;], dtype=object)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.value_counts(values)</div></pre></td></tr></table></figure>
<pre><code>apple     6
orange    2
dtype: int64
</code></pre><p>许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(Dimension Table)，将主要的参数存储为引用维表整数键：</p>
<p>就像 mysql 的分表存储</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">values = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] * <span class="number">2</span>)</div><div class="line">values</div></pre></td></tr></table></figure>
<pre><code>0    0
1    1
2    0
3    0
4    0
5    1
6    0
7    0
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dim = pd.Series([<span class="string">'apple'</span>, <span class="string">'orange'</span>])</div><div class="line">dim</div></pre></td></tr></table></figure>
<pre><code>0     apple
1    orange
dtype: object
</code></pre><p>可以使用take方法存储原始的字符串Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dim.take(values)</div></pre></td></tr></table></figure>
<pre><code>0     apple
1    orange
0     apple
0     apple
0     apple
1    orange
0     apple
0     apple
dtype: object
</code></pre><p>这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。本书中，我们使用分类的说法。表示分类的整数值称为分类编码或简单地称为编码。</p>
<h3 id="pandas的分类类型"><a href="#pandas的分类类型" class="headerlink" title="pandas的分类类型"></a>pandas的分类类型</h3><p>pandas有一个特殊的分类类型，用于保存使用整数分类表示法的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'apple'</span>] * <span class="number">2</span></div><div class="line"></div><div class="line">N = len(fruits)</div><div class="line"></div><div class="line">df = pd.DataFrame(&#123;<span class="string">'fruit'</span>: fruits,  </div><div class="line">                   <span class="string">'basket_id'</span>: np.arange(N), </div><div class="line">                   <span class="string">'count'</span>: np.random.randint(<span class="number">3</span>, <span class="number">15</span>, size=N),</div><div class="line">                   <span class="string">'weight'</span>: np.random.uniform(<span class="number">0</span>, <span class="number">4</span>, size=N)&#125;,</div><div class="line">                   columns=[<span class="string">'basket_id'</span>, <span class="string">'fruit'</span>, <span class="string">'count'</span>, <span class="string">'weight'</span>])</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>basket_id</th><br>      <th>fruit</th><br>      <th>count</th><br>      <th>weight</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>apple</td><br>      <td>11</td><br>      <td>0.661412</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>orange</td><br>      <td>6</td><br>      <td>2.661072</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>apple</td><br>      <td>10</td><br>      <td>3.956839</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3</td><br>      <td>apple</td><br>      <td>10</td><br>      <td>3.491835</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>4</td><br>      <td>apple</td><br>      <td>6</td><br>      <td>2.954149</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>5</td><br>      <td>orange</td><br>      <td>12</td><br>      <td>3.967850</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>6</td><br>      <td>apple</td><br>      <td>8</td><br>      <td>0.093289</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>7</td><br>      <td>apple</td><br>      <td>3</td><br>      <td>3.056569</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这里，<code>df[&#39;fruit&#39;]</code> 是一个Python字符串对象的数组。我们可以通过调用它，将它转变为分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fruit_cat = df[<span class="string">'fruit'</span>].astype(<span class="string">'category'</span>)</div><div class="line">fruit_cat</div></pre></td></tr></table></figure>
<pre><code>0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
Name: fruit, dtype: category
Categories (2, object): [apple, orange]
</code></pre><p>fruit_cat的值不是NumPy数组，而是一个pandas.Categorical实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = fruit_cat.values</div><div class="line">c</div></pre></td></tr></table></figure>
<pre><code>[apple, orange, apple, apple, apple, orange, apple, apple]
Categories (2, object): [apple, orange]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(c)</div></pre></td></tr></table></figure>
<pre><code>pandas.core.arrays.categorical.Categorical
</code></pre><p>分类对象有categories和codes属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.categories</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;apple&apos;, &apos;orange&apos;], dtype=&apos;object&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.codes</div></pre></td></tr></table></figure>
<pre><code>array([0, 1, 0, 0, 0, 1, 0, 0], dtype=int8)
</code></pre><p>你可将DataFrame的列通过分配转换结果，转换为分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'fruit'</span>] = df[<span class="string">'fruit'</span>].astype(<span class="string">'category'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>basket_id</th><br>      <th>fruit</th><br>      <th>count</th><br>      <th>weight</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>0</td><br>      <td>apple</td><br>      <td>11</td><br>      <td>0.661412</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>1</td><br>      <td>orange</td><br>      <td>6</td><br>      <td>2.661072</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2</td><br>      <td>apple</td><br>      <td>10</td><br>      <td>3.956839</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>3</td><br>      <td>apple</td><br>      <td>10</td><br>      <td>3.491835</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>4</td><br>      <td>apple</td><br>      <td>6</td><br>      <td>2.954149</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>5</td><br>      <td>orange</td><br>      <td>12</td><br>      <td>3.967850</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>6</td><br>      <td>apple</td><br>      <td>8</td><br>      <td>0.093289</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>7</td><br>      <td>apple</td><br>      <td>3</td><br>      <td>3.056569</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.fruit</div></pre></td></tr></table></figure>
<pre><code>0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
Name: fruit, dtype: category
Categories (2, object): [apple, orange]
</code></pre><p>你还可以从其它Python序列直接创建pandas.Categorical：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my_categories = pd.Categorical([<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>])</div><div class="line">my_categories</div></pre></td></tr></table></figure>
<pre><code>[foo, bar, baz, foo, bar]
Categories (3, object): [bar, baz, foo]
</code></pre><p>如果你已经从其它源获得了分类编码，你还可以使用from_codes构造器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">categories = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</div><div class="line"></div><div class="line">codes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line">my_cats_2 = pd.Categorical.from_codes(codes, categories)</div><div class="line"></div><div class="line">my_cats_2</div></pre></td></tr></table></figure>
<pre><code>[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo, bar, baz]
</code></pre><p>与显示指定不同，分类变换不认定指定的分类顺序。因此取决于输入数据的顺序，categories数组的顺序会不同。当使用from_codes或其它的构造器时，你可以指定分类一个有意义的顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ordered_cat = pd.Categorical.from_codes(codes, categories, ordered=<span class="keyword">True</span>)</div><div class="line">ordered_cat</div></pre></td></tr></table></figure>
<pre><code>[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo &lt; bar &lt; baz]
</code></pre><p>无序的分类实例可以通过as_ordered排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my_cats_2.as_ordered()</div></pre></td></tr></table></figure>
<pre><code>[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo &lt; bar &lt; baz]
</code></pre><h3 id="用分类进行计算"><a href="#用分类进行计算" class="headerlink" title="用分类进行计算"></a>用分类进行计算</h3><p>来看一些随机的数值数据，使用pandas.qcut面元函数。它会返回pandas.Categorical，我们之前使用过pandas.cut，但没解释分类是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">np.random.seed(<span class="number">12345</span>)</div><div class="line"></div><div class="line">draws = np.random.randn(<span class="number">1000</span>)</div><div class="line">draws[:<span class="number">5</span>]</div></pre></td></tr></table></figure>
<pre><code>array([-0.20470766,  0.47894334, -0.51943872, -0.5557303 ,  1.96578057])
</code></pre><p>计算这个数据的分位面元，提取一些统计信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bins = pd.qcut(draws, <span class="number">4</span>)</div><div class="line">bins</div></pre></td></tr></table></figure>
<pre><code>[(-0.684, -0.0101], (-0.0101, 0.63], (-0.684, -0.0101], (-0.684, -0.0101], (0.63, 3.928], ..., (-0.0101, 0.63], (-0.684, -0.0101], (-2.9499999999999997, -0.684], (-0.0101, 0.63], (0.63, 3.928]]
Length: 1000
Categories (4, interval[float64]): [(-2.9499999999999997, -0.684] &lt; (-0.684, -0.0101] &lt; (-0.0101, 0.63] &lt; (0.63, 3.928]]
</code></pre><p>虽然有用，确切的样本分位数与分位的名称相比，不利于生成汇总。我们可以使用labels参数qcut，实现目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bins = pd.qcut(draws, <span class="number">4</span>, labels=[<span class="string">'Q1'</span>, <span class="string">'Q2'</span>, <span class="string">'Q3'</span>, <span class="string">'Q4'</span>])</div><div class="line">bins</div></pre></td></tr></table></figure>
<pre><code>[Q2, Q3, Q2, Q2, Q4, ..., Q3, Q2, Q1, Q3, Q4]
Length: 1000
Categories (4, object): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bins.codes[:<span class="number">10</span>]</div></pre></td></tr></table></figure>
<pre><code>array([1, 2, 1, 1, 3, 3, 2, 2, 3, 3], dtype=int8)
</code></pre><p>加上标签的面元分类不包含数据面元边界的信息，因此可以使用groupby提取一些汇总信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bins = pd.Series(bins, name=<span class="string">'quartile'</span>)</div><div class="line">bins.head()</div></pre></td></tr></table></figure>
<pre><code>0    Q2
1    Q3
2    Q2
3    Q2
4    Q4
Name: quartile, dtype: category
Categories (4, object): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">results = (pd.Series(draws)</div><div class="line">           .groupby(bins)</div><div class="line">           .agg([<span class="string">'count'</span>, <span class="string">'min'</span>, <span class="string">'max'</span>])</div><div class="line">           .reset_index())</div><div class="line">results</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>quartile</th><br>      <th>count</th><br>      <th>min</th><br>      <th>max</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>Q1</td><br>      <td>250</td><br>      <td>-2.949343</td><br>      <td>-0.685484</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>Q2</td><br>      <td>250</td><br>      <td>-0.683066</td><br>      <td>-0.010115</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>Q3</td><br>      <td>250</td><br>      <td>-0.010032</td><br>      <td>0.628894</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>Q4</td><br>      <td>250</td><br>      <td>0.634238</td><br>      <td>3.927528</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>分位数列保存了原始的面元分类信息，包括排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">results[<span class="string">'quartile'</span>]</div></pre></td></tr></table></figure>
<pre><code>0    Q1
1    Q2
2    Q3
3    Q4
Name: quartile, dtype: category
Categories (4, object): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]
</code></pre><h3 id="用分类提高性能"><a href="#用分类提高性能" class="headerlink" title="用分类提高性能"></a>用分类提高性能</h3><p>如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。DataFrame列的分类使用的内存通常少的多。来看一些包含一千万元素的Series，和一些不同的分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N = <span class="number">10000000</span></div><div class="line">draws = pd.Series(np.random.randn(N))</div><div class="line"></div><div class="line">labels = pd.Series([<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'qux'</span>] * (N // <span class="number">4</span>))</div></pre></td></tr></table></figure>
<p>现在，将标签转换为分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">categories = labels.astype(<span class="string">'category'</span>)</div></pre></td></tr></table></figure>
<p>这时，可以看到标签使用的内存远比分类多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">labels.memory_usage()</div></pre></td></tr></table></figure>
<pre><code>80000080
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">categories.memory_usage()</div></pre></td></tr></table></figure>
<pre><code>10000272
</code></pre><p>转换为分类不是没有代价的，但这是一次性的代价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%time _ = labels.astype(<span class="string">'category'</span>)</div></pre></td></tr></table></figure>
<pre><code>Wall time: 429 ms
</code></pre><p>GroupBy使用分类操作明显更快，是因为底层的算法使用整数编码数组，而不是字符串数组。</p>
<h3 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h3><p>包含分类数据的Series有一些特殊的方法，类似于Series.str字符串方法。它还提供了方便的分类和编码的使用方法。看下面的Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s = pd.Series([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>] * <span class="number">2</span>)</div><div class="line"></div><div class="line">cat_s = s.astype(<span class="string">'category'</span>)</div><div class="line"></div><div class="line">cat_s</div></pre></td></tr></table></figure>
<pre><code>0    a
1    b
2    c
3    d
4    a
5    b
6    c
7    d
dtype: category
Categories (4, object): [a, b, c, d]
</code></pre><p>特别的cat属性提供了分类方法的入口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat_s.cat.codes</div></pre></td></tr></table></figure>
<pre><code>0    0
1    1
2    2
3    3
4    0
5    1
6    2
7    3
dtype: int8
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat_s.cat.categories</div></pre></td></tr></table></figure>
<pre><code>Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], dtype=&apos;object&apos;)
</code></pre><p>假设我们知道这个数据的实际分类集，超出了数据中的四个值。我们可以使用set_categories方法改变它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">actual_categories = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</div><div class="line">cat_s2 = cat_s.cat.set_categories(actual_categories)</div><div class="line">cat_s2</div></pre></td></tr></table></figure>
<pre><code>0    a
1    b
2    c
3    d
4    a
5    b
6    c
7    d
dtype: category
Categories (5, object): [a, b, c, d, e]
</code></pre><p>虽然数据看起来没变，新的分类将反映在它们的操作中。例如，如果有的话，value_counts表示分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat_s.value_counts()</div></pre></td></tr></table></figure>
<pre><code>d    2
c    2
b    2
a    2
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat_s2.value_counts()</div></pre></td></tr></table></figure>
<pre><code>d    2
c    2
b    2
a    2
e    0
dtype: int64
</code></pre><p>在大数据集中，分类经常作为节省内存和高性能的便捷工具。过滤完大DataFrame或Series之后，许多分类可能不会出现在数据中。我们可以使用remove_unused_categories方法删除没看到的分类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat_s3 = cat_s[cat_s.isin([<span class="string">'a'</span>, <span class="string">'b'</span>])]</div><div class="line">cat_s3</div></pre></td></tr></table></figure>
<pre><code>0    a
1    b
4    a
5    b
dtype: category
Categories (4, object): [a, b, c, d]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat_s3.cat.remove_unused_categories()</div></pre></td></tr></table></figure>
<pre><code>0    a
1    b
4    a
5    b
dtype: category
Categories (2, object): [a, b]
</code></pre><p>可用的分类方法<br><img src="http://upload-images.jianshu.io/upload_images/7178691-6c602152c2bba658.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="为建模创建虚拟变量"><a href="#为建模创建虚拟变量" class="headerlink" title="为建模创建虚拟变量"></a>为建模创建虚拟变量</h3><p>当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为one-hot编码。这包括创建一个不同类别的列的DataFrame；这些列包含给定分类的1s，其它为0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat_s = pd.Series([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>] * <span class="number">2</span>, dtype=<span class="string">'category'</span>)</div><div class="line">cat_s</div></pre></td></tr></table></figure>
<pre><code>0    a
1    b
2    c
3    d
4    a
5    b
6    c
7    d
dtype: category
Categories (4, object): [a, b, c, d]
</code></pre><p>pandas.get_dummies 函数可以转换这个分类数据为包含虚拟变量的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.get_dummies(cat_s)</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>a</th><br>      <th>b</th><br>      <th>c</th><br>      <th>d</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>0</td><br>      <td>0</td><br>      <td>0</td><br>      <td>1</td><br>    </tr><br>  </tbody><br></table><br></div>



<h3 id="GroupBy高级应用"><a href="#GroupBy高级应用" class="headerlink" title="GroupBy高级应用"></a>GroupBy高级应用</h3><h3 id="分组转换"><a href="#分组转换" class="headerlink" title="分组转换"></a>分组转换</h3><p>在分组操作中学习了apply方法，进行转换。还有另一个transform方法，它与apply很像，但是对使用的函数有一定限制：  </p>
<ol>
<li>它可以产生向分组形状广播标量值</li>
<li>它可以产生一个和输入组形状相同的对象</li>
<li>它不能修改输入</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] * <span class="number">4</span>,  <span class="string">'value'</span>: np.arange(<span class="number">12.</span>)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>key</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>a</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>b</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>c</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>a</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>b</td><br>      <td>4.0</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>c</td><br>      <td>5.0</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>a</td><br>      <td>6.0</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>b</td><br>      <td>7.0</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>c</td><br>      <td>8.0</td><br>    </tr><br>    <tr><br>      <th>9</th><br>      <td>a</td><br>      <td>9.0</td><br>    </tr><br>    <tr><br>      <th>10</th><br>      <td>b</td><br>      <td>10.0</td><br>    </tr><br>    <tr><br>      <th>11</th><br>      <td>c</td><br>      <td>11.0</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>按键进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g = df.groupby(<span class="string">'key'</span>).value</div><div class="line">g.mean()</div></pre></td></tr></table></figure>
<pre><code>key
a    4.5
b    5.5
c    6.5
Name: value, dtype: float64
</code></pre><p>假设我们想产生一个和 <code>df[&#39;value&#39;]</code> 形状相同的Series，但值替换为按键分组的平均值。我们可以传递函数 <code>lambda x: x.mean()</code> 进行转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g.transform(<span class="keyword">lambda</span> x: x.mean())</div></pre></td></tr></table></figure>
<pre><code>0     4.5
1     5.5
2     6.5
3     4.5
4     5.5
5     6.5
6     4.5
7     5.5
8     6.5
9     4.5
10    5.5
11    6.5
Name: value, dtype: float64
</code></pre><p>对于内置的聚合函数，我们可以传递一个字符串假名作为GroupBy的agg方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g.transform(<span class="string">'mean'</span>)</div></pre></td></tr></table></figure>
<pre><code>0     4.5
1     5.5
2     6.5
3     4.5
4     5.5
5     6.5
6     4.5
7     5.5
8     6.5
9     4.5
10    5.5
11    6.5
Name: value, dtype: float64
</code></pre><p>与apply类似，transform的函数会返回Series，但是结果必须与输入大小相同。举个例子，我们可以用lambda函数将每个分组乘以2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g.transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>)</div></pre></td></tr></table></figure>
<pre><code>0      0.0
1      2.0
2      4.0
3      6.0
4      8.0
5     10.0
6     12.0
7     14.0
8     16.0
9     18.0
10    20.0
11    22.0
Name: value, dtype: float64
</code></pre><p>看一个由简单聚合构造的的分组转换函数：<br>我们用transform或apply可以获得等价的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> (x - x.mean()) / x.std()</div><div class="line">g.transform(normalize)</div></pre></td></tr></table></figure>
<pre><code>0    -1.161895
1    -1.161895
2    -1.161895
3    -0.387298
4    -0.387298
5    -0.387298
6     0.387298
7     0.387298
8     0.387298
9     1.161895
10    1.161895
11    1.161895
Name: value, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g.apply(normalize)</div></pre></td></tr></table></figure>
<pre><code>0    -1.161895
1    -1.161895
2    -1.161895
3    -0.387298
4    -0.387298
5    -0.387298
6     0.387298
7     0.387298
8     0.387298
9     1.161895
10    1.161895
11    1.161895
Name: value, dtype: float64
</code></pre><h3 id="分组的时间重采样"><a href="#分组的时间重采样" class="headerlink" title="分组的时间重采样"></a>分组的时间重采样</h3><p>对于时间序列数据，resample方法从语义上是一个基于内在时间的分组操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">N = <span class="number">15</span></div><div class="line"></div><div class="line">times = pd.date_range(<span class="string">'2017-05-20 00:00'</span>, freq=<span class="string">'1min'</span>, periods=N)</div><div class="line"></div><div class="line">df = pd.DataFrame(&#123;<span class="string">'time'</span>: times, <span class="string">'value'</span>: np.arange(N)&#125;)</div><div class="line">df</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>time</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2017-05-20 00:00:00</td><br>      <td>0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2017-05-20 00:01:00</td><br>      <td>1</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2017-05-20 00:02:00</td><br>      <td>2</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2017-05-20 00:03:00</td><br>      <td>3</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>2017-05-20 00:04:00</td><br>      <td>4</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>2017-05-20 00:05:00</td><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>2017-05-20 00:06:00</td><br>      <td>6</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>2017-05-20 00:07:00</td><br>      <td>7</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>2017-05-20 00:08:00</td><br>      <td>8</td><br>    </tr><br>    <tr><br>      <th>9</th><br>      <td>2017-05-20 00:09:00</td><br>      <td>9</td><br>    </tr><br>    <tr><br>      <th>10</th><br>      <td>2017-05-20 00:10:00</td><br>      <td>10</td><br>    </tr><br>    <tr><br>      <th>11</th><br>      <td>2017-05-20 00:11:00</td><br>      <td>11</td><br>    </tr><br>    <tr><br>      <th>12</th><br>      <td>2017-05-20 00:12:00</td><br>      <td>12</td><br>    </tr><br>    <tr><br>      <th>13</th><br>      <td>2017-05-20 00:13:00</td><br>      <td>13</td><br>    </tr><br>    <tr><br>      <th>14</th><br>      <td>2017-05-20 00:14:00</td><br>      <td>14</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>这里，我们可以用time作为索引，然后重采样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.set_index(<span class="string">'time'</span>).resample(<span class="string">'5min'</span>).count()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>value</th><br>    </tr><br>    <tr><br>      <th>time</th><br>      <th></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>2017-05-20 00:00:00</th><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2017-05-20 00:05:00</th><br>      <td>5</td><br>    </tr><br>    <tr><br>      <th>2017-05-20 00:10:00</th><br>      <td>5</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>假设DataFrame包含多个时间序列，用一个额外的分组键的列进行标记：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(&#123;<span class="string">'time'</span>: times.repeat(<span class="number">3</span>),</div><div class="line">                    <span class="string">'key'</span>: np.tile([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], N),</div><div class="line">                    <span class="string">'value'</span>: np.arange(N * <span class="number">3.</span>)&#125;)</div><div class="line">df2.head()</div></pre></td></tr></table></figure>
<div><br><style scoped><br>    .dataframe tbody tr th:only-of-type {<br>        vertical-align: middle;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br><br>    .dataframe thead th {<br>        text-align: right;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>time</th><br>      <th>key</th><br>      <th>value</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>0</th><br>      <td>2017-05-20 00:00:00</td><br>      <td>a</td><br>      <td>0.0</td><br>    </tr><br>    <tr><br>      <th>1</th><br>      <td>2017-05-20 00:00:00</td><br>      <td>b</td><br>      <td>1.0</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>2017-05-20 00:00:00</td><br>      <td>c</td><br>      <td>2.0</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>2017-05-20 00:01:00</td><br>      <td>a</td><br>      <td>3.0</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>2017-05-20 00:01:00</td><br>      <td>b</td><br>      <td>4.0</td><br>    </tr><br>  </tbody><br></table><br></div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/my.jpg" alt="echo-ding wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/my.jpg" alt="echo-ding 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/my.jpg" alt="echo-ding 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pandas/" rel="tag"># pandas</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/15/数据分析/matplotlib 笔记/" rel="next" title="matplotlib 基础">
                <i class="fa fa-chevron-left"></i> matplotlib 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my.jpg"
                alt="echo-ding" />
            
              <p class="site-author-name" itemprop="name">echo-ding</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅，绝知此事要躬行。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/bunao" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:ibunao@163.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/6346736172" target="_blank" title="微博" rel="external nofollow"><i class="fa fa-fw fa-weibo"></i>微博</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎" rel="external nofollow"><i class="fa fa-fw fa-angry"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bunao.me/" title="bunao" target="_blank" rel="external nofollow">bunao</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础部分"><span class="nav-number">1.</span> <span class="nav-text">基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Series-数据结构"><span class="nav-number">1.1.1.</span> <span class="nav-text">Series 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataFrame-数据结构"><span class="nav-number">1.1.2.</span> <span class="nav-text">DataFrame 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引对象"><span class="nav-number">1.1.3.</span> <span class="nav-text">索引对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本功能"><span class="nav-number">1.2.</span> <span class="nav-text">基本功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重新索引-reindex"><span class="nav-number">1.2.1.</span> <span class="nav-text">重新索引 reindex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#丢弃指定轴上的项-drop"><span class="nav-number">1.2.2.</span> <span class="nav-text">丢弃指定轴上的项 drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引、选取和过滤"><span class="nav-number">1.2.3.</span> <span class="nav-text">索引、选取和过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-loc-和-iloc-进行选取"><span class="nav-number">1.2.4.</span> <span class="nav-text">用 loc 和 iloc 进行选取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算术运算和数据对齐、在算术方法中填充值"><span class="nav-number">1.2.5.</span> <span class="nav-text">算术运算和数据对齐、在算术方法中填充值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataFrame和Series之间的运算"><span class="nav-number">1.2.6.</span> <span class="nav-text">DataFrame和Series之间的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数应用和映射"><span class="nav-number">1.2.7.</span> <span class="nav-text">函数应用和映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序和排名"><span class="nav-number">1.2.8.</span> <span class="nav-text">排序和排名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按照索引排序-sort-index"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">按照索引排序 sort_index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按照值排序-sort-values"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">按照值排序 sort_values</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带有重复标签的轴索引"><span class="nav-number">1.2.9.</span> <span class="nav-text">带有重复标签的轴索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇总和计算描述统计"><span class="nav-number">1.3.</span> <span class="nav-text">汇总和计算描述统计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关系数与协方差"><span class="nav-number">1.3.1.</span> <span class="nav-text">相关系数与协方差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唯一值、值计数以及成员资格"><span class="nav-number">1.3.2.</span> <span class="nav-text">唯一值、值计数以及成员资格</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据加载、存储与文件格式"><span class="nav-number">2.</span> <span class="nav-text">数据加载、存储与文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读写文本格式的数据"><span class="nav-number">2.1.</span> <span class="nav-text">读写文本格式的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读取-csv-文件"><span class="nav-number">2.1.1.</span> <span class="nav-text">读取 csv 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逐块读取文本文件"><span class="nav-number">2.1.2.</span> <span class="nav-text">逐块读取文本文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将数据写出到文本格式"><span class="nav-number">2.1.3.</span> <span class="nav-text">将数据写出到文本格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON数据"><span class="nav-number">2.1.4.</span> <span class="nav-text">JSON数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制数据格式"><span class="nav-number">2.2.</span> <span class="nav-text">二进制数据格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用HDF5格式"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用HDF5格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取Microsoft-Excel文件"><span class="nav-number">2.2.2.</span> <span class="nav-text">读取Microsoft Excel文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库交互"><span class="nav-number">2.2.3.</span> <span class="nav-text">数据库交互</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据清洗和准备"><span class="nav-number">3.</span> <span class="nav-text">数据清洗和准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理缺失数据"><span class="nav-number">3.1.</span> <span class="nav-text">处理缺失数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滤除缺失数据"><span class="nav-number">3.1.1.</span> <span class="nav-text">滤除缺失数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#填充缺失数据"><span class="nav-number">3.1.2.</span> <span class="nav-text">填充缺失数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据转换"><span class="nav-number">3.2.</span> <span class="nav-text">数据转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#移除重复数据"><span class="nav-number">3.2.1.</span> <span class="nav-text">移除重复数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用函数或映射进行数据转换"><span class="nav-number">3.2.2.</span> <span class="nav-text">利用函数或映射进行数据转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#替换值"><span class="nav-number">3.2.3.</span> <span class="nav-text">替换值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重命名轴索引"><span class="nav-number">3.2.4.</span> <span class="nav-text">重命名轴索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离散化和面元划分"><span class="nav-number">3.2.5.</span> <span class="nav-text">离散化和面元划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测和过滤异常值"><span class="nav-number">3.2.6.</span> <span class="nav-text">检测和过滤异常值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排列和随机采样"><span class="nav-number">3.2.7.</span> <span class="nav-text">排列和随机采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算指标-哑变量"><span class="nav-number">3.2.8.</span> <span class="nav-text">计算指标/哑变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串操作"><span class="nav-number">3.3.</span> <span class="nav-text">字符串操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pandas-的矢量化字符串函数"><span class="nav-number">3.3.1.</span> <span class="nav-text">pandas 的矢量化字符串函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据规整：聚合、合并和重塑"><span class="nav-number">4.</span> <span class="nav-text">数据规整：聚合、合并和重塑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#层次化索引"><span class="nav-number">4.1.</span> <span class="nav-text">层次化索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重排与分级排序"><span class="nav-number">4.1.1.</span> <span class="nav-text">重排与分级排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据级别汇总统计"><span class="nav-number">4.1.2.</span> <span class="nav-text">根据级别汇总统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用DataFrame的列进行索引"><span class="nav-number">4.1.3.</span> <span class="nav-text">使用DataFrame的列进行索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并数据集"><span class="nav-number">4.2.</span> <span class="nav-text">合并数据集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库风格的DataFrame合并"><span class="nav-number">4.2.1.</span> <span class="nav-text">数据库风格的DataFrame合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引上的合并"><span class="nav-number">4.2.2.</span> <span class="nav-text">索引上的合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轴向连接"><span class="nav-number">4.2.3.</span> <span class="nav-text">轴向连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并重叠数据"><span class="nav-number">4.2.4.</span> <span class="nav-text">合并重叠数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重塑和轴向旋转"><span class="nav-number">4.3.</span> <span class="nav-text">重塑和轴向旋转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重塑层次化索引"><span class="nav-number">4.3.1.</span> <span class="nav-text">重塑层次化索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将“长格式”旋转为“宽格式”"><span class="nav-number">4.3.2.</span> <span class="nav-text">将“长格式”旋转为“宽格式”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将“宽格式”旋转为“长格式”"><span class="nav-number">4.3.3.</span> <span class="nav-text">将“宽格式”旋转为“长格式”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据聚合与分组运算"><span class="nav-number">5.</span> <span class="nav-text">数据聚合与分组运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GroupBy机制"><span class="nav-number">5.1.</span> <span class="nav-text">GroupBy机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对分组进行迭代"><span class="nav-number">5.1.1.</span> <span class="nav-text">对分组进行迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选取一列或列的子集"><span class="nav-number">5.1.2.</span> <span class="nav-text">选取一列或列的子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过字典或Series进行分组"><span class="nav-number">5.1.3.</span> <span class="nav-text">通过字典或Series进行分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过函数进行分组"><span class="nav-number">5.1.4.</span> <span class="nav-text">通过函数进行分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据索引级别分组"><span class="nav-number">5.1.5.</span> <span class="nav-text">根据索引级别分组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据聚合"><span class="nav-number">5.2.</span> <span class="nav-text">数据聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向列的多函数应用"><span class="nav-number">5.2.1.</span> <span class="nav-text">面向列的多函数应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以“没有行索引”的形式返回聚合数据"><span class="nav-number">5.2.2.</span> <span class="nav-text">以“没有行索引”的形式返回聚合数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#apply：一般性的“拆分－应用－合并”"><span class="nav-number">5.3.</span> <span class="nav-text">apply：一般性的“拆分－应用－合并”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#禁止分组键"><span class="nav-number">5.3.1.</span> <span class="nav-text">禁止分组键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分位数和桶分析"><span class="nav-number">5.3.2.</span> <span class="nav-text">分位数和桶分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：用特定于分组的值填充缺失值"><span class="nav-number">5.3.3.</span> <span class="nav-text">示例：用特定于分组的值填充缺失值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：分组加权平均数和相关系数"><span class="nav-number">5.3.4.</span> <span class="nav-text">示例：分组加权平均数和相关系数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：组级别的线性回归"><span class="nav-number">5.3.5.</span> <span class="nav-text">示例：组级别的线性回归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#透视表和交叉表"><span class="nav-number">5.4.</span> <span class="nav-text">透视表和交叉表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pandas高级应用"><span class="nav-number">6.</span> <span class="nav-text">pandas高级应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类数据"><span class="nav-number">6.1.</span> <span class="nav-text">分类数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景和目的"><span class="nav-number">6.1.1.</span> <span class="nav-text">背景和目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pandas的分类类型"><span class="nav-number">6.1.2.</span> <span class="nav-text">pandas的分类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用分类进行计算"><span class="nav-number">6.1.3.</span> <span class="nav-text">用分类进行计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用分类提高性能"><span class="nav-number">6.1.4.</span> <span class="nav-text">用分类提高性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类方法"><span class="nav-number">6.1.5.</span> <span class="nav-text">分类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为建模创建虚拟变量"><span class="nav-number">6.1.6.</span> <span class="nav-text">为建模创建虚拟变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GroupBy高级应用"><span class="nav-number">6.1.7.</span> <span class="nav-text">GroupBy高级应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组转换"><span class="nav-number">6.1.8.</span> <span class="nav-text">分组转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组的时间重采样"><span class="nav-number">6.1.9.</span> <span class="nav-text">分组的时间重采样</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">echo-ding</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io" rel="external nofollow" >Hexo</a> 强力驱动 v3.3.7</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "JoifQWva3MrLxWwEjXGYYvNw-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "JoifQWva3MrLxWwEjXGYYvNw-gzGzoHsz",
                'X-LC-Key': "IEzrlKqyuxO8jhwp2ds1P0Rf",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
