<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/bunao.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/bunao.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/bunao.ico?v=6.4.2">


  <link rel="mask-icon" href="/images/bunao.ico?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="参考引用 1234567891011import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAfrom datetime import datetimefrom datetime import timedeltafrom dateutil.parser im">
<meta name="keywords" content="pandas 时间序列">
<meta property="og:type" content="article">
<meta property="og:title" content="pandas 时间序列">
<meta property="og:url" content="http://bunao.win/2019/04/15/数据分析/pandas-时间序列/index.html">
<meta property="og:site_name" content="不孬">
<meta property="og:description" content="参考引用 1234567891011import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAfrom datetime import datetimefrom datetime import timedeltafrom dateutil.parser im">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-ff139312cd972204.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-adfa57a998c0296e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-d09e577a10d0e6eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-7a77f47844f2ee8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">
<meta property="og:image" content="http://bunao.win/images/shuju/output_303_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_304_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_308_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_310_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_312_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_317_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_322_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_324_1.png">
<meta property="og:image" content="http://bunao.win/images/shuju/output_327_1.png">
<meta property="og:updated_time" content="2019-08-26T10:44:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pandas 时间序列">
<meta name="twitter:description" content="参考引用 1234567891011import pandas as pdfrom pandas import Series, DataFrameimport numpy as npfrom numpy import nan as NAfrom datetime import datetimefrom datetime import timedeltafrom dateutil.parser im">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240">






  <link rel="canonical" href="http://bunao.win/2019/04/15/数据分析/pandas-时间序列/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>pandas 时间序列 | 不孬</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4719716f509495788172dc0058a6f11e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不孬</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">less is more</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bunao.win/2019/04/15/数据分析/pandas-时间序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="echo-ding">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不孬">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">pandas 时间序列
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 11:56:02" itemprop="dateCreated datePublished" datetime="2019-04-15T11:56:02+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-26 18:44:09" itemprop="dateModified" datetime="2019-08-26T18:44:09+08:00">2019-08-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据分析/pandas/" itemprop="url" rel="index"><span itemprop="name">pandas</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/15/数据分析/pandas-时间序列/" class="leancloud_visitors" data-flag-title="pandas 时间序列">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://seancheney.gitbook.io/python-for-data-analysis-2nd/di-11-zhang-shi-jian-xu-lie#tong-guo-shi-qi-jin-hang-zhong-cai-yang" target="_blank" rel="external">参考引用</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</div><div class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</div><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</div><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</div><div class="line"><span class="keyword">import</span> pytz</div><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</div></pre></td></tr></table></figure>
<p>pandas提供了许多内置的时间序列处理工具和数据算法。因此，你可以高效处理非常大的时间序列，轻松地进行切片/切块、聚合、对定期/不定期的时间序列进行重采样等。有些工具特别适合金融和经济应用，你当然也可以用它们来分析服务器日志数据。<br><a id="more"></a></p>
<h2 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h2><p>python 标准库提供的相关的时间库</p>
<p>Python标准库包含用于日期（date）和时间（time）数据的数据类型，而且还有日历方面的功能。我们主要会用到datetime、time以及calendar模块。datetime.datetime（也可以简写为datetime）是用得最多的数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">now = datetime.now()</div><div class="line">now</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2019, 5, 14, 9, 21, 6, 222759)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now.year, now.month, now.day</div></pre></td></tr></table></figure>
<pre><code>(2019, 5, 14)
</code></pre><p>datetime以毫秒形式存储日期和时间。timedelta表示两个datetime对象之间的时间差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>)</div><div class="line">delta</div></pre></td></tr></table></figure>
<pre><code>datetime.timedelta(days=926, seconds=56700)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delta.days, delta.seconds</div></pre></td></tr></table></figure>
<pre><code>(926, 56700)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">timedelta(<span class="number">12</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.timedelta(days=12)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</div><div class="line">start + timedelta(<span class="number">12</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 1, 19, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2010, 12, 14, 0, 0)
</code></pre><p>datetime模块中的数据类型<br><img src="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="datetime模块中的数据类型">  </p>
<h3 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h3><p>利用str或strftime方法（传入一个格式化字符串），datetime对象和pandas的Timestamp对象（稍后就会介绍）可以被格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</div><div class="line">stamp</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 1, 3, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str(stamp)</div></pre></td></tr></table></figure>
<pre><code>&apos;2011-01-03 00:00:00&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp.strftime(<span class="string">'%Y-%m-%d'</span>)</div></pre></td></tr></table></figure>
<pre><code>&apos;2011-01-03&apos;
</code></pre><p>datetime格式定义  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="">. </p>
<p>datetime.strptime可以用这些格式化编码将字符串转换为日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = <span class="string">'2011-01-03'</span></div><div class="line">datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 1, 3, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datestrs = [<span class="string">'7/6/2011'</span>, <span class="string">'8/6/2011'</span>]</div><div class="line">[datetime.strptime(x, <span class="string">'%m/%d/%Y'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</div></pre></td></tr></table></figure>
<pre><code>[datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]
</code></pre><p>datetime.strptime是通过已知格式进行日期解析的最佳方式。但是每次都要编写格式定义是很麻烦的事情，尤其是对于一些常见的日期格式。这种情况下，你可以用dateutil这个第三方包中的parser.parse方法（pandas中已经自动安装好了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">'2011-01-03'</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 1, 3, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(1997, 1, 31, 22, 45)
</code></pre><p>在国际通用的格式中，日出现在月的前面很普遍，传入dayfirst=True即可解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse(<span class="string">'6/12/2011'</span>, dayfirst=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 12, 6, 0, 0)
</code></pre><p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datestrs = [<span class="string">'2011-07-06 12:00:00'</span>, <span class="string">'2011-08-06 00:00:00'</span>]</div><div class="line">pd.to_datetime(datestrs)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2011-07-06 12:00:00&apos;, &apos;2011-08-06 00:00:00&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)
</code></pre><p>它还可以处理缺失值（None、空字符串等）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">idx = pd.to_datetime(datestrs + [<span class="keyword">None</span>])</div><div class="line">idx</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2011-07-06 12:00:00&apos;, &apos;2011-08-06 00:00:00&apos;, &apos;NaT&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">idx[<span class="number">2</span>]</div></pre></td></tr></table></figure>
<pre><code>NaT
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.isnull(idx)</div></pre></td></tr></table></figure>
<pre><code>array([False, False,  True])
</code></pre><p>NaT（Not a Time）是pandas中时间戳数据的null值。  </p>
<blockquote>
<p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如”42”会被解析为2042年的今天）。  </p>
</blockquote>
<p>datetime对象还有一些特定于当前环境（位于不同国家或使用不同语言的系统）的格式化选项。例如，德语或法语系统所用的月份简写就与英语系统所用的不同。下表进行了总结。<br>特定于当前环境的日期格式<br><a href="https://www.cnblogs.com/wenBlog/p/6023742.html" target="_blank" rel="external">Python中获取当前日期的格式</a><br><img src="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="特定于当前环境的日期格式"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>).strftime(<span class="string">"%A"</span>)</div></pre></td></tr></table></figure>
<pre><code>&apos;Monday&apos;
</code></pre><h2 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h2><p>pandas最基本的时间序列类型就是以时间戳（通常以Python字符串或datatime对象表示）为索引的Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>), </div><div class="line">         datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</div><div class="line">ts = pd.Series(np.random.randn(<span class="number">6</span>), index=dates)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2011-01-02    0.502699
2011-01-05    1.188837
2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
2011-01-12   -1.640982
dtype: float64
</code></pre><p>这些datetime对象实际上是被放在一个DatetimeIndex中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2011-01-02&apos;, &apos;2011-01-05&apos;, &apos;2011-01-07&apos;, &apos;2011-01-08&apos;,
               &apos;2011-01-10&apos;, &apos;2011-01-12&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=None)
</code></pre><p>跟其他Series一样，不同索引的时间序列之间的算术运算会自动按日期对齐：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ts[::2] 是每隔两个取一个</span></div><div class="line">ts + ts[::<span class="number">2</span>]</div></pre></td></tr></table></figure>
<pre><code>2011-01-02    1.005399
2011-01-05         NaN
2011-01-07   -3.116730
2011-01-08         NaN
2011-01-10    0.744455
2011-01-12         NaN
dtype: float64
</code></pre><p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index.dtype</div></pre></td></tr></table></figure>
<pre><code>dtype(&apos;&lt;M8[ns]&apos;)
</code></pre><p>DatetimeIndex中的各个标量值是pandas的Timestamp对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-01-02 00:00:00&apos;)
</code></pre><p>只要有需要，TimeStamp可以随时自动转换为datetime对象。此外，它还可以存储频率信息（如果有的话），且知道如何执行时区转换以及其他操作。</p>
<h3 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h3><p>当你根据标签索引选取数据时，时间序列和其它的pandas.Series很像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp = ts.index[<span class="number">2</span>]</div><div class="line">stamp</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-01-07 00:00:00&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[stamp]</div></pre></td></tr></table></figure>
<pre><code>-1.5583649551664842
</code></pre><p>还有一种更为方便的用法：传入一个可以被解释为日期的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'1/10/2011'</span>]</div></pre></td></tr></table></figure>
<pre><code>0.3722275907128481
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'20110110'</span>]</div></pre></td></tr></table></figure>
<pre><code>0.3722275907128481
</code></pre><p>对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),</div><div class="line">                      index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>))</div><div class="line">longer_ts.head()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01   -1.005154
2000-01-02   -0.025581
2000-01-03   -1.069827
2000-01-04    0.620630
2000-01-05    0.320359
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">longer_ts[<span class="string">'2001'</span>].head()</div></pre></td></tr></table></figure>
<pre><code>2001-01-01    0.904721
2001-01-02   -1.321671
2001-01-03   -0.758130
2001-01-04   -0.639765
2001-01-05   -1.898212
Freq: D, dtype: float64
</code></pre><p>这里，字符串“2001”被解释成年，并根据它选取时间区间。指定月也同样奏效：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">longer_ts[<span class="string">'2001-05'</span>].head()</div></pre></td></tr></table></figure>
<pre><code>2001-05-01    1.054962
2001-05-02   -0.788939
2001-05-03   -0.439097
2001-05-04    0.036200
2001-05-05    0.458054
Freq: D, dtype: float64
</code></pre><p>datetime对象也可以进行切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</div></pre></td></tr></table></figure>
<pre><code>2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
2011-01-12   -1.640982
dtype: float64
</code></pre><p>由于大部分时间序列数据都是按照时间先后排序的，因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2011-01-02    0.502699
2011-01-05    1.188837
2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
2011-01-12   -1.640982
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts[<span class="string">'1/6/2011'</span>:<span class="string">'1/11/2011'</span>]</div></pre></td></tr></table></figure>
<pre><code>2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2011-01-02    0.502699
2011-01-05    1.188837
2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
2011-01-12   -1.640982
dtype: float64
</code></pre><p>前面这些操作对DataFrame也有效。例如，对DataFrame的行进行索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">100</span>, freq=<span class="string">'W-WED'</span>)</div><div class="line">long_df = pd.DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),</div><div class="line">                       index=dates,</div><div class="line">                       columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">long_df.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-05</th>
      <td>1.252168</td>
      <td>-0.120885</td>
      <td>1.323235</td>
      <td>0.253597</td>
    </tr>
    <tr>
      <th>2000-01-12</th>
      <td>-1.124264</td>
      <td>1.739674</td>
      <td>0.693579</td>
      <td>1.562149</td>
    </tr>
    <tr>
      <th>2000-01-19</th>
      <td>-0.814943</td>
      <td>0.409049</td>
      <td>-0.794594</td>
      <td>-1.158813</td>
    </tr>
    <tr>
      <th>2000-01-26</th>
      <td>-1.254203</td>
      <td>-1.770200</td>
      <td>-1.693423</td>
      <td>-0.588621</td>
    </tr>
    <tr>
      <th>2000-02-02</th>
      <td>-0.724392</td>
      <td>-1.776080</td>
      <td>-0.505409</td>
      <td>0.130541</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long_df.loc[<span class="string">'5-2001'</span>]</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001-05-02</th>
      <td>-0.267807</td>
      <td>-1.382954</td>
      <td>0.904109</td>
      <td>0.219650</td>
    </tr>
    <tr>
      <th>2001-05-09</th>
      <td>0.639089</td>
      <td>-0.665502</td>
      <td>0.321638</td>
      <td>1.234549</td>
    </tr>
    <tr>
      <th>2001-05-16</th>
      <td>1.172080</td>
      <td>-1.194735</td>
      <td>0.821372</td>
      <td>1.968535</td>
    </tr>
    <tr>
      <th>2001-05-23</th>
      <td>1.491895</td>
      <td>-1.684519</td>
      <td>-1.374041</td>
      <td>0.072872</td>
    </tr>
    <tr>
      <th>2001-05-30</th>
      <td>-0.035682</td>
      <td>-0.904268</td>
      <td>-0.071059</td>
      <td>-0.641927</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long_df.loc[<span class="string">'2001-5'</span>]</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001-05-02</th>
      <td>-0.267807</td>
      <td>-1.382954</td>
      <td>0.904109</td>
      <td>0.219650</td>
    </tr>
    <tr>
      <th>2001-05-09</th>
      <td>0.639089</td>
      <td>-0.665502</td>
      <td>0.321638</td>
      <td>1.234549</td>
    </tr>
    <tr>
      <th>2001-05-16</th>
      <td>1.172080</td>
      <td>-1.194735</td>
      <td>0.821372</td>
      <td>1.968535</td>
    </tr>
    <tr>
      <th>2001-05-23</th>
      <td>1.491895</td>
      <td>-1.684519</td>
      <td>-1.374041</td>
      <td>0.072872</td>
    </tr>
    <tr>
      <th>2001-05-30</th>
      <td>-0.035682</td>
      <td>-0.904268</td>
      <td>-0.071059</td>
      <td>-0.641927</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h3><p>在某些应用场景中，可能会存在多个观测数据落在同一个时间点上的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/3/2000'</span>])</div><div class="line">dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</div><div class="line">dup_ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-01    0
2000-01-02    1
2000-01-02    2
2000-01-02    3
2000-01-03    4
dtype: int32
</code></pre><p>通过检查索引的is_unique属性，我们就可以知道它是不是唯一的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts.index.is_unique</div></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>对这个时间序列进行索引，要么产生标量值，要么产生切片，具体要看所选的时间点是否重复：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts[<span class="string">'1/3/2000'</span>]</div></pre></td></tr></table></figure>
<pre><code>4
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup_ts[<span class="string">'1/2/2000'</span>]</div></pre></td></tr></table></figure>
<pre><code>2000-01-02    1
2000-01-02    2
2000-01-02    3
dtype: int32
</code></pre><p>对具有非唯一时间戳的数据进行聚合。一个办法是使用groupby，并传入level=0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped = dup_ts.groupby(level=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped</div></pre></td></tr></table></figure>
<pre><code>&lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x0000000009A3AA90&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.count()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01    1
2000-01-02    3
2000-01-03    1
dtype: int64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grouped.mean()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01    0
2000-01-02    2
2000-01-03    4
dtype: int32
</code></pre><h2 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h2><p>pandas中的原生时间序列一般被认为是不规则的，也就是说，它们没有固定的频率。对于大部分应用程序而言，这是无所谓的。但是，它常常需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。幸运的是，pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，只需调用resample即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2011-01-02    0.502699
2011-01-05    1.188837
2011-01-07   -1.558365
2011-01-08    0.770966
2011-01-10    0.372228
2011-01-12   -1.640982
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 字符串“D”是每天的意思。</span></div><div class="line">ts.resample(<span class="string">'D'</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndexResampler [freq=&lt;Day&gt;, axis=0, closed=left, label=left, convention=start, base=0]
</code></pre><p>频率的转换（或重采样）是一个比较大的主题，稍后将专门用一节来进行讨论。</p>
<h3 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h3><p>pandas.date_range可用于根据指定的频率生成指定长度的DatetimeIndex：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index = pd.date_range(<span class="string">'2012-04-01'</span>, <span class="string">'2012-06-01'</span>)</div><div class="line">index</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-04-01&apos;, &apos;2012-04-02&apos;, &apos;2012-04-03&apos;, &apos;2012-04-04&apos;,
               &apos;2012-04-05&apos;, &apos;2012-04-06&apos;, &apos;2012-04-07&apos;, &apos;2012-04-08&apos;,
               &apos;2012-04-09&apos;, &apos;2012-04-10&apos;, &apos;2012-04-11&apos;, &apos;2012-04-12&apos;,
               &apos;2012-04-13&apos;, &apos;2012-04-14&apos;, &apos;2012-04-15&apos;, &apos;2012-04-16&apos;,
               &apos;2012-04-17&apos;, &apos;2012-04-18&apos;, &apos;2012-04-19&apos;, &apos;2012-04-20&apos;,
               &apos;2012-04-21&apos;, &apos;2012-04-22&apos;, &apos;2012-04-23&apos;, &apos;2012-04-24&apos;,
               &apos;2012-04-25&apos;, &apos;2012-04-26&apos;, &apos;2012-04-27&apos;, &apos;2012-04-28&apos;,
               &apos;2012-04-29&apos;, &apos;2012-04-30&apos;, &apos;2012-05-01&apos;, &apos;2012-05-02&apos;,
               &apos;2012-05-03&apos;, &apos;2012-05-04&apos;, &apos;2012-05-05&apos;, &apos;2012-05-06&apos;,
               &apos;2012-05-07&apos;, &apos;2012-05-08&apos;, &apos;2012-05-09&apos;, &apos;2012-05-10&apos;,
               &apos;2012-05-11&apos;, &apos;2012-05-12&apos;, &apos;2012-05-13&apos;, &apos;2012-05-14&apos;,
               &apos;2012-05-15&apos;, &apos;2012-05-16&apos;, &apos;2012-05-17&apos;, &apos;2012-05-18&apos;,
               &apos;2012-05-19&apos;, &apos;2012-05-20&apos;, &apos;2012-05-21&apos;, &apos;2012-05-22&apos;,
               &apos;2012-05-23&apos;, &apos;2012-05-24&apos;, &apos;2012-05-25&apos;, &apos;2012-05-26&apos;,
               &apos;2012-05-27&apos;, &apos;2012-05-28&apos;, &apos;2012-05-29&apos;, &apos;2012-05-30&apos;,
               &apos;2012-05-31&apos;, &apos;2012-06-01&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><p>默认情况下，date_range会产生按天计算的时间点。如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(start=<span class="string">'2012-04-01'</span>, periods=<span class="number">20</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-04-01&apos;, &apos;2012-04-02&apos;, &apos;2012-04-03&apos;, &apos;2012-04-04&apos;,
               &apos;2012-04-05&apos;, &apos;2012-04-06&apos;, &apos;2012-04-07&apos;, &apos;2012-04-08&apos;,
               &apos;2012-04-09&apos;, &apos;2012-04-10&apos;, &apos;2012-04-11&apos;, &apos;2012-04-12&apos;,
               &apos;2012-04-13&apos;, &apos;2012-04-14&apos;, &apos;2012-04-15&apos;, &apos;2012-04-16&apos;,
               &apos;2012-04-17&apos;, &apos;2012-04-18&apos;, &apos;2012-04-19&apos;, &apos;2012-04-20&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(end=<span class="string">'2012-06-01'</span>, periods=<span class="number">20</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-05-13&apos;, &apos;2012-05-14&apos;, &apos;2012-05-15&apos;, &apos;2012-05-16&apos;,
               &apos;2012-05-17&apos;, &apos;2012-05-18&apos;, &apos;2012-05-19&apos;, &apos;2012-05-20&apos;,
               &apos;2012-05-21&apos;, &apos;2012-05-22&apos;, &apos;2012-05-23&apos;, &apos;2012-05-24&apos;,
               &apos;2012-05-25&apos;, &apos;2012-05-26&apos;, &apos;2012-05-27&apos;, &apos;2012-05-28&apos;,
               &apos;2012-05-29&apos;, &apos;2012-05-30&apos;, &apos;2012-05-31&apos;, &apos;2012-06-01&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><p>起始和结束日期定义了日期索引的严格边界。<br>如果你想要生成一个由每月最后一个工作日组成的日期索引，可以传入”BM”频率（表示business end of month，下表有频率列表），这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-12-01'</span>, freq=<span class="string">'BM'</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2000-01-31&apos;, &apos;2000-02-29&apos;, &apos;2000-03-31&apos;, &apos;2000-04-28&apos;,
               &apos;2000-05-31&apos;, &apos;2000-06-30&apos;, &apos;2000-07-31&apos;, &apos;2000-08-31&apos;,
               &apos;2000-09-29&apos;, &apos;2000-10-31&apos;, &apos;2000-11-30&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;BM&apos;)
</code></pre><p>基本的时间序列频率<br><img src="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="基本的时间序列频率"></p>
<p>date_range默认会保留起始和结束时间戳的时间信息（如果有的话）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-05-02 12:56:31&apos;, &apos;2012-05-03 12:56:31&apos;,
               &apos;2012-05-04 12:56:31&apos;, &apos;2012-05-05 12:56:31&apos;,
               &apos;2012-05-06 12:56:31&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><p>有时，虽然起始和结束日期带有时间信息，但你希望产生一组被规范化（normalize）到午夜的时间戳。normalize选项即可实现该功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>, normalize=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-05-02&apos;, &apos;2012-05-03&apos;, &apos;2012-05-04&apos;, &apos;2012-05-05&apos;,
               &apos;2012-05-06&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><h3 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h3><p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如”M”表示每月，”H”表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用Hour类表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</div><div class="line">hour = Hour()</div><div class="line">hour</div></pre></td></tr></table></figure>
<pre><code>&lt;Hour&gt;
</code></pre><p>传入一个整数即可定义偏移量的倍数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">four_hours = Hour(<span class="number">4</span>)</div><div class="line">four_hours</div></pre></td></tr></table></figure>
<pre><code>&lt;4 * Hours&gt;
</code></pre><p>一般来说，无需明确创建这样的对象，只需使用诸如”H”或”4H”这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-01-03 23:59'</span>, freq=<span class="string">'4h'</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2000-01-01 00:00:00&apos;, &apos;2000-01-01 04:00:00&apos;,
               &apos;2000-01-01 08:00:00&apos;, &apos;2000-01-01 12:00:00&apos;,
               &apos;2000-01-01 16:00:00&apos;, &apos;2000-01-01 20:00:00&apos;,
               &apos;2000-01-02 00:00:00&apos;, &apos;2000-01-02 04:00:00&apos;,
               &apos;2000-01-02 08:00:00&apos;, &apos;2000-01-02 12:00:00&apos;,
               &apos;2000-01-02 16:00:00&apos;, &apos;2000-01-02 20:00:00&apos;,
               &apos;2000-01-03 00:00:00&apos;, &apos;2000-01-03 04:00:00&apos;,
               &apos;2000-01-03 08:00:00&apos;, &apos;2000-01-03 12:00:00&apos;,
               &apos;2000-01-03 16:00:00&apos;, &apos;2000-01-03 20:00:00&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;4H&apos;)
</code></pre><p>大部分偏移量对象都可通过加法进行连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</div></pre></td></tr></table></figure>
<pre><code>&lt;150 * Minutes&gt;
</code></pre><p>同理，你也可以传入频率字符串（如”2h30min”），这种字符串可以被高效地解析为等效的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1h30min'</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2000-01-01 00:00:00&apos;, &apos;2000-01-01 01:30:00&apos;,
               &apos;2000-01-01 03:00:00&apos;, &apos;2000-01-01 04:30:00&apos;,
               &apos;2000-01-01 06:00:00&apos;, &apos;2000-01-01 07:30:00&apos;,
               &apos;2000-01-01 09:00:00&apos;, &apos;2000-01-01 10:30:00&apos;,
               &apos;2000-01-01 12:00:00&apos;, &apos;2000-01-01 13:30:00&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;90T&apos;)
</code></pre><p>时间序列的基础频率<br><img src="https://upload-images.jianshu.io/upload_images/7178691-ff139312cd972204.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="时间序列的基础频率"><br><img src="https://upload-images.jianshu.io/upload_images/7178691-adfa57a998c0296e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/7178691-d09e577a10d0e6eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<h3 id="WOM日期"><a href="#WOM日期" class="headerlink" title="WOM日期"></a>WOM日期</h3><p>WOM（Week Of Month）是一种非常实用的频率类，它以WOM开头。它使你能获得诸如“每月第3个星期五”之类的日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'2012-01-01'</span>, <span class="string">'2012-09-01'</span>, freq=<span class="string">'WOM-3FRI'</span>)</div><div class="line">rng</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-01-20&apos;, &apos;2012-02-17&apos;, &apos;2012-03-16&apos;, &apos;2012-04-20&apos;,
               &apos;2012-05-18&apos;, &apos;2012-06-15&apos;, &apos;2012-07-20&apos;, &apos;2012-08-17&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;WOM-3FRI&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list(rng)</div></pre></td></tr></table></figure>
<pre><code>[Timestamp(&apos;2012-01-20 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-02-17 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-03-16 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-04-20 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-05-18 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-06-15 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-07-20 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;),
 Timestamp(&apos;2012-08-17 00:00:00&apos;, freq=&apos;WOM-3FRI&apos;)]
</code></pre><h3 id="移动（超前和滞后）数据"><a href="#移动（超前和滞后）数据" class="headerlink" title="移动（超前和滞后）数据"></a>移动（超前和滞后）数据</h3><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有一个shift方法用于执行单纯的前移或后移操作，保持索引不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ts = pd.Series(np.random.randn(<span class="number">4</span>),</div><div class="line">               index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">4</span>, freq=<span class="string">'M'</span>))</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-31   -3.150432
2000-02-29    0.426478
2000-03-31   -1.580138
2000-04-30   -0.454702
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-01-31         NaN
2000-02-29         NaN
2000-03-31   -3.150432
2000-04-30    0.426478
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.shift(<span class="number">-2</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-01-31   -1.580138
2000-02-29   -0.454702
2000-03-31         NaN
2000-04-30         NaN
Freq: M, dtype: float64
</code></pre><p>当我们这样进行移动时，就会在时间序列的前面或后面产生缺失数据。</p>
<p>shift通常用于计算一个时间序列或多个时间序列（如DataFrame的列）中的百分比变化。可以这样表达：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts / ts.shift(<span class="number">1</span>) - <span class="number">1</span></div></pre></td></tr></table></figure>
<pre><code>2000-01-31         NaN
2000-02-29   -1.135371
2000-03-31   -4.705091
2000-04-30   -0.712239
Freq: M, dtype: float64
</code></pre><p>由于单纯的移位操作不会修改索引，所以部分数据会被丢弃。因此，如果频率已知，则可以将其传给shift以便实现对时间戳进行位移而不是对数据进行简单位移：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加两个月</span></div><div class="line">ts.shift(<span class="number">2</span>, freq=<span class="string">'M'</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-03-31   -3.150432
2000-04-30    0.426478
2000-05-31   -1.580138
2000-06-30   -0.454702
Freq: M, dtype: float64
</code></pre><p>还可以使用其他频率，于是你就能非常灵活地对数据进行超前和滞后处理了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加三天</span></div><div class="line">ts.shift(<span class="number">3</span>, freq=<span class="string">'D'</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-02-03   -3.150432
2000-03-03    0.426478
2000-04-03   -1.580138
2000-05-03   -0.454702
dtype: float64
</code></pre><h3 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h3><p>pandas的日期偏移量还可以用在datetime或Timestamp对象上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</div><div class="line">now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</div><div class="line">now + <span class="number">3</span> * Day()</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-11-20 00:00:00&apos;)
</code></pre><p>如果加的是锚点偏移量（比如MonthEnd），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">now</div></pre></td></tr></table></figure>
<pre><code>datetime.datetime(2011, 11, 17, 0, 0)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 月末</span></div><div class="line">now + MonthEnd()</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-11-30 00:00:00&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 两个月末</span></div><div class="line">now + MonthEnd(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-12-31 00:00:00&apos;)
</code></pre><p>通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">offset = MonthEnd()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">offset.rollforward(now)</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-11-30 00:00:00&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">offset.rollback(now)</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-10-31 00:00:00&apos;)
</code></pre><p>日期偏移量还有一个巧妙的用法，即结合groupby使用这两个“滚动”方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ts = pd.Series(np.random.randn(<span class="number">20</span>),</div><div class="line">               index=pd.date_range(<span class="string">'1/15/2000'</span>, periods=<span class="number">20</span>, freq=<span class="string">'4d'</span>))</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-15   -0.182953
2000-01-19   -0.991147
2000-01-23   -0.014200
2000-01-27   -0.019404
2000-01-31    1.417325
2000-02-04    0.558435
2000-02-08    1.092113
2000-02-12   -0.463639
2000-02-16   -0.232902
2000-02-20    0.461556
2000-02-24   -2.170060
2000-02-28   -0.409881
2000-03-03    0.156696
2000-03-07   -0.846032
2000-03-11    0.450076
2000-03-15    0.383532
2000-03-19    0.162644
2000-03-23   -0.038723
2000-03-27    1.229935
2000-03-31    1.217698
Freq: 4D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 索引用月末的一天</span></div><div class="line">ts.groupby(offset.rollforward).mean()</div></pre></td></tr></table></figure>
<pre><code>2000-01-31    0.041924
2000-02-29   -0.166340
2000-03-31    0.339478
dtype: float64
</code></pre><p>当然，更简单、更快速地实现该功能的办法是使用resample， 后面会进行介绍</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'M'</span>).mean()</div></pre></td></tr></table></figure>
<pre><code>2000-01-31    0.041924
2000-02-29   -0.166340
2000-03-31    0.339478
Freq: M, dtype: float64
</code></pre><h2 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h2><p>时间序列处理工作中最让人不爽的就是对时区的处理。许多人都选择以协调世界时（UTC，它是格林尼治标准时间（Greenwich Mean Time）的接替者，目前已经是国际标准了）来处理时间序列。时区是以UTC偏移量的形式表示的。例如，夏令时期间，纽约比UTC慢4小时，而在全年其他时间则比UTC慢5小时。<br>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。这对历史数据非常重要，这是因为由于各地政府的各种突发奇想，夏令时转变日期（甚至UTC偏移量）已经发生过多次改变了。就拿美国来说，DST转变时间自1900年以来就改变过多次！<br>有关pytz库的更多信息，请查阅其文档。就本书而言，由于pandas包装了pytz的功能，因此你可以不用记忆其API，只要记得时区的名称即可。时区名可以在shell中看到，也可以通过文档查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytz</div><div class="line">pytz.common_timezones[<span class="number">-5</span>:]</div></pre></td></tr></table></figure>
<pre><code>[&apos;US/Eastern&apos;, &apos;US/Hawaii&apos;, &apos;US/Mountain&apos;, &apos;US/Pacific&apos;, &apos;UTC&apos;]
</code></pre><p>要从pytz中获取时区对象，使用pytz.timezone即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tz = pytz.timezone(<span class="string">'America/New_York'</span>)</div><div class="line">tz</div></pre></td></tr></table></figure>
<pre><code>&lt;DstTzInfo &apos;America/New_York&apos; LMT-1 day, 19:04:00 STD&gt;
</code></pre><p>pandas中的方法既可以接受时区名也可以接受这些对象。</p>
<h3 id="时区本地化和转换"><a href="#时区本地化和转换" class="headerlink" title="时区本地化和转换"></a>时区本地化和转换</h3><p>默认情况下，pandas中的时间序列是单纯（naive）的时区。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</div><div class="line">rng</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-03-09 09:30:00&apos;, &apos;2012-03-10 09:30:00&apos;,
               &apos;2012-03-11 09:30:00&apos;, &apos;2012-03-12 09:30:00&apos;,
               &apos;2012-03-13 09:30:00&apos;, &apos;2012-03-14 09:30:00&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2012-03-09 09:30:00    1.206028
2012-03-10 09:30:00   -1.239482
2012-03-11 09:30:00   -1.594181
2012-03-12 09:30:00    1.342129
2012-03-13 09:30:00    1.791927
2012-03-14 09:30:00    0.511703
Freq: D, dtype: float64
</code></pre><p>其时间索引的 tz 字段(时区)为 None：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(ts.index.tz)</div></pre></td></tr></table></figure>
<pre><code>None
</code></pre><p>可以用时区集生成日期范围：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temp = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'D'</span>, tz=<span class="string">'UTC'</span>)</div><div class="line">temp</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-03-09 09:30:00+00:00&apos;, &apos;2012-03-10 09:30:00+00:00&apos;,
               &apos;2012-03-11 09:30:00+00:00&apos;, &apos;2012-03-12 09:30:00+00:00&apos;,
               &apos;2012-03-13 09:30:00+00:00&apos;, &apos;2012-03-14 09:30:00+00:00&apos;,
               &apos;2012-03-15 09:30:00+00:00&apos;, &apos;2012-03-16 09:30:00+00:00&apos;,
               &apos;2012-03-17 09:30:00+00:00&apos;, &apos;2012-03-18 09:30:00+00:00&apos;],
              dtype=&apos;datetime64[ns, UTC]&apos;, freq=&apos;D&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">temp.tz</div></pre></td></tr></table></figure>
<pre><code>&lt;UTC&gt;
</code></pre><p>本地化的转换是通过 tz_localize 方法处理的：(也就是没有时区(本地时区)转换成指定时区)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2012-03-09 09:30:00    1.206028
2012-03-10 09:30:00   -1.239482
2012-03-11 09:30:00   -1.594181
2012-03-12 09:30:00    1.342129
2012-03-13 09:30:00    1.791927
2012-03-14 09:30:00    0.511703
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts_utc = ts.tz_localize(<span class="string">'UTC'</span>)</div><div class="line">ts_utc</div></pre></td></tr></table></figure>
<pre><code>2012-03-09 09:30:00+00:00    1.206028
2012-03-10 09:30:00+00:00   -1.239482
2012-03-11 09:30:00+00:00   -1.594181
2012-03-12 09:30:00+00:00    1.342129
2012-03-13 09:30:00+00:00    1.791927
2012-03-14 09:30:00+00:00    0.511703
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts_utc.index.tz</div></pre></td></tr></table></figure>
<pre><code>&lt;UTC&gt;
</code></pre><p>一旦时间序列被本地化转到某个特定时区，就可以用 tz_convert 将其转换到别的时区了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts_utc.tz_convert(<span class="string">'America/New_York'</span>)</div></pre></td></tr></table></figure>
<pre><code>2012-03-09 04:30:00-05:00    1.206028
2012-03-10 04:30:00-05:00   -1.239482
2012-03-11 05:30:00-04:00   -1.594181
2012-03-12 05:30:00-04:00    1.342129
2012-03-13 05:30:00-04:00    1.791927
2012-03-14 05:30:00-04:00    0.511703
Freq: D, dtype: float64
</code></pre><p>tz_localize 和 tz_convert 也是 DatetimeIndex 的实例方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.index.tz_localize(<span class="string">'Asia/Shanghai'</span>)</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-03-09 09:30:00+08:00&apos;, &apos;2012-03-10 09:30:00+08:00&apos;,
               &apos;2012-03-11 09:30:00+08:00&apos;, &apos;2012-03-12 09:30:00+08:00&apos;,
               &apos;2012-03-13 09:30:00+08:00&apos;, &apos;2012-03-14 09:30:00+08:00&apos;],
              dtype=&apos;datetime64[ns, Asia/Shanghai]&apos;, freq=&apos;D&apos;)
</code></pre><h3 id="Timestamp对象"><a href="#Timestamp对象" class="headerlink" title="Timestamp对象"></a>Timestamp对象</h3><p>跟时间序列和日期范围差不多，独立的 Timestamp 对象也能被从单纯型（naive）本地化转为时区意识型（time zone-aware），并从一个时区转换到另一个时区：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>)</div><div class="line">print(stamp.tz)</div></pre></td></tr></table></figure>
<pre><code>None
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp_utc = stamp.tz_localize(<span class="string">'utc'</span>)</div><div class="line">stamp_utc.tz</div></pre></td></tr></table></figure>
<pre><code>&lt;UTC&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp_utc.tz_convert(<span class="string">'America/New_York'</span>)</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-03-11 23:00:00-0500&apos;, tz=&apos;America/New_York&apos;)
</code></pre><p>在创建Timestamp时，还可以传入一个时区信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp_moscow = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>, tz=<span class="string">'Europe/Moscow'</span>)</div><div class="line">stamp_moscow</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2011-03-12 04:00:00+0300&apos;, tz=&apos;Europe/Moscow&apos;)
</code></pre><p>时区意识型Timestamp对象在内部保存了一个UTC时间戳值（自UNIX纪元（1970年1月1日）算起的纳秒数）。这个UTC值在时区转换过程中是不会发生变化的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp_utc.value</div></pre></td></tr></table></figure>
<pre><code>1299902400000000000
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp_utc.tz_convert(<span class="string">'America/New_York'</span>).value</div></pre></td></tr></table></figure>
<pre><code>1299902400000000000
</code></pre><p>当使用 pandas 的 DateOffset 对象执行时间算术运算时，运算过程会自动关注是否存在夏令时转变期。  </p>
<p>这里，我们创建了在DST转变之前的时间戳。首先，来看夏令时转变前的30分钟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</div><div class="line">stamp = pd.Timestamp(<span class="string">'2012-03-12 01:30'</span>, tz=<span class="string">'US/Eastern'</span>)</div><div class="line">stamp</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2012-03-12 01:30:00-0400&apos;, tz=&apos;US/Eastern&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp + Hour()</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2012-03-12 02:30:00-0400&apos;, tz=&apos;US/Eastern&apos;)
</code></pre><p>然后，夏令时转变前90分钟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stamp = pd.Timestamp(<span class="string">'2012-11-04 00:30'</span>, tz=<span class="string">'US/Eastern'</span>)</div><div class="line">stamp</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2012-11-04 00:30:00-0400&apos;, tz=&apos;US/Eastern&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stamp + <span class="number">2</span> * Hour()</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2012-11-04 01:30:00-0500&apos;, tz=&apos;US/Eastern&apos;)
</code></pre><h3 id="不同时区之间的运算"><a href="#不同时区之间的运算" class="headerlink" title="不同时区之间的运算"></a>不同时区之间的运算</h3><p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC。由于时间戳其实是以UTC存储的，所以这是一个很简单的运算，并不需要发生任何转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'3/7/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'B'</span>)</div><div class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2012-03-07 09:30:00   -0.204868
2012-03-08 09:30:00   -0.921229
2012-03-09 09:30:00    1.727979
2012-03-12 09:30:00    1.019146
2012-03-13 09:30:00    1.690955
2012-03-14 09:30:00   -0.156478
2012-03-15 09:30:00    0.655796
2012-03-16 09:30:00    0.229343
2012-03-19 09:30:00    2.329904
2012-03-20 09:30:00    0.600509
Freq: B, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">'Europe/London'</span>)</div><div class="line">ts1</div></pre></td></tr></table></figure>
<pre><code>2012-03-07 09:30:00+00:00   -0.204868
2012-03-08 09:30:00+00:00   -0.921229
2012-03-09 09:30:00+00:00    1.727979
2012-03-12 09:30:00+00:00    1.019146
2012-03-13 09:30:00+00:00    1.690955
2012-03-14 09:30:00+00:00   -0.156478
2012-03-15 09:30:00+00:00    0.655796
Freq: B, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">'Europe/Moscow'</span>)</div><div class="line">ts2</div></pre></td></tr></table></figure>
<pre><code>2012-03-09 13:30:00+04:00    1.727979
2012-03-12 13:30:00+04:00    1.019146
2012-03-13 13:30:00+04:00    1.690955
2012-03-14 13:30:00+04:00   -0.156478
2012-03-15 13:30:00+04:00    0.655796
Freq: B, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result = ts1 + ts2</div><div class="line">result</div></pre></td></tr></table></figure>
<pre><code>2012-03-07 09:30:00+00:00         NaN
2012-03-08 09:30:00+00:00         NaN
2012-03-09 09:30:00+00:00    3.455958
2012-03-12 09:30:00+00:00    2.038293
2012-03-13 09:30:00+00:00    3.381910
2012-03-14 09:30:00+00:00   -0.312956
2012-03-15 09:30:00+00:00    1.311593
Freq: B, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result.index</div></pre></td></tr></table></figure>
<pre><code>DatetimeIndex([&apos;2012-03-07 09:30:00+00:00&apos;, &apos;2012-03-08 09:30:00+00:00&apos;,
               &apos;2012-03-09 09:30:00+00:00&apos;, &apos;2012-03-12 09:30:00+00:00&apos;,
               &apos;2012-03-13 09:30:00+00:00&apos;, &apos;2012-03-14 09:30:00+00:00&apos;,
               &apos;2012-03-15 09:30:00+00:00&apos;],
              dtype=&apos;datetime64[ns, UTC]&apos;, freq=&apos;B&apos;)
</code></pre><h2 id="时期-Period-及其算术运算"><a href="#时期-Period-及其算术运算" class="headerlink" title="时期(Period)及其算术运算"></a>时期(Period)及其算术运算</h2><p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数和之前提到的时间频率（搜 时间序列的基础频率）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="number">2007</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">p</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2007&apos;, &apos;A-DEC&apos;)
</code></pre><p>这里，这个Period对象表示的是从2007年1月1日到2007年12月31日之间的整段时间。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p + <span class="number">5</span></div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2012&apos;, &apos;A-DEC&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p - <span class="number">2</span></div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2005&apos;, &apos;A-DEC&apos;)
</code></pre><p>如果两个Period对象拥有相同的频率，则它们的差就是它们之间的单位数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.Period(<span class="string">'2014'</span>, freq=<span class="string">'A-DEC'</span>) - p</div></pre></td></tr></table></figure>
<pre><code>7
</code></pre><p>period_range函数可用于创建规则的时期范围：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-06-30'</span>, freq=<span class="string">'M'</span>)</div><div class="line">rng</div></pre></td></tr></table></figure>
<pre><code>PeriodIndex([&apos;2000-01&apos;, &apos;2000-02&apos;, &apos;2000-03&apos;, &apos;2000-04&apos;, &apos;2000-05&apos;, &apos;2000-06&apos;], dtype=&apos;period[M]&apos;, freq=&apos;M&apos;)
</code></pre><p>PeriodIndex类保存了一组Period，它可以在任何pandas数据结构中被用作轴索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</div></pre></td></tr></table></figure>
<pre><code>2000-01   -1.975257
2000-02   -1.347283
2000-03   -0.117589
2000-04   -0.323535
2000-05    0.065720
2000-06   -1.698198
Freq: M, dtype: float64
</code></pre><p>如果你有一个字符串数组，你也可以使用PeriodIndex类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</div><div class="line">index = pd.PeriodIndex(values, freq=<span class="string">'Q-DEC'</span>)</div><div class="line">index</div></pre></td></tr></table></figure>
<pre><code>PeriodIndex([&apos;2001Q3&apos;, &apos;2002Q2&apos;, &apos;2003Q1&apos;], dtype=&apos;period[Q-DEC]&apos;, freq=&apos;Q-DEC&apos;)
</code></pre><h3 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h3><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。<br>假设我们有一个年度时期，希望将其转换为当年年初或年末的一个月度时期。该任务非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">p</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2007&apos;, &apos;A-DEC&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2007-01&apos;, &apos;M&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2007-12&apos;, &apos;M&apos;)
</code></pre><p>你可以将 <code>Period(&#39;2007&#39;,&#39;A-DEC&#39;)</code> 看做一个被划分为多个月度时期的时间段中的游标。  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Period频率转换示例"></p>
<p>在将高频率转换为低频率时，超时期（superperiod）是由子时期（subperiod）所属的位置决定的。例如，在A-JUN频率中，月份“2007年8月”实际上是属于周期“2008年”的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'Aug-2007'</span>, <span class="string">'M'</span>)</div><div class="line">p.asfreq(<span class="string">'A-JUN'</span>)</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2008&apos;, &apos;A-JUN&apos;)
</code></pre><p>完整的 PeriodIndex 或 TimeSeries 的频率转换方式也是如此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq=<span class="string">'A-DEC'</span>)</div><div class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2006    1.020120
2007   -0.377748
2008   -0.058147
2009   -1.282297
Freq: A-DEC, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</div></pre></td></tr></table></figure>
<pre><code>2006-01    1.020120
2007-01   -0.377748
2008-01   -0.058147
2009-01   -1.282297
Freq: M, dtype: float64
</code></pre><p>这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用“B”频率，并指明想要该时期的末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.asfreq(<span class="string">'B'</span>, how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure>
<pre><code>2006-12-29    1.020120
2007-12-31   -0.377748
2008-12-31   -0.058147
2009-12-31   -1.282297
Freq: B, dtype: float64
</code></pre><h3 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h3><p>季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期”2012Q4”根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>)</div><div class="line">p</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2012Q4&apos;, &apos;Q-JAN&apos;)
</code></pre><p>在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。下图对此进行了说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>)</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2011-11-01&apos;, &apos;D&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>)</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2012-01-31&apos;, &apos;D&apos;)
</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="不同季度型频率之间的转换"> </p>
<p>因此，Period之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span></div><div class="line">p4pm</div></pre></td></tr></table></figure>
<pre><code>Period(&apos;2012-01-30 16:00&apos;, &apos;T&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p4pm.to_timestamp()</div></pre></td></tr></table></figure>
<pre><code>Timestamp(&apos;2012-01-30 16:00:00&apos;)
</code></pre><p>period_range可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.period_range(<span class="string">'2011Q3'</span>, <span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>)</div><div class="line">ts = pd.Series(np.arange(len(rng)), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2011Q3    0
2011Q4    1
2012Q1    2
2012Q2    3
2012Q3    4
2012Q4    5
Freq: Q-JAN, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new_rng = (rng.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span></div><div class="line">ts.index = new_rng.to_timestamp()</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2010-10-28 16:00:00    0
2011-01-28 16:00:00    1
2011-04-28 16:00:00    2
2011-07-28 16:00:00    3
2011-10-28 16:00:00    4
2012-01-30 16:00:00    5
dtype: int32
</code></pre><h3 id="将Timestamp转换为Period（及其反向过程）"><a href="#将Timestamp转换为Period（及其反向过程）" class="headerlink" title="将Timestamp转换为Period（及其反向过程）"></a>将Timestamp转换为Period（及其反向过程）</h3><p>通过使用 to_period 方法，可以将由时间戳索引的 Series 和 DataFrame 对象转换为以时期索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">3</span>, freq=<span class="string">'M'</span>)</div><div class="line">ts = pd.Series(np.random.randn(<span class="number">3</span>), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-31    0.269545
2000-02-29   -0.056993
2000-03-31    0.967725
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pts = ts.to_period()</div><div class="line">pts</div></pre></td></tr></table></figure>
<pre><code>2000-01    0.269545
2000-02   -0.056993
2000-03    0.967725
Freq: M, dtype: float64
</code></pre><p>由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新PeriodIndex的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'1/29/2000'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</div><div class="line">ts2</div></pre></td></tr></table></figure>
<pre><code>2000-01-29    0.193937
2000-01-30   -1.982108
2000-01-31    1.623989
2000-02-01   -0.980946
2000-02-02    1.431045
2000-02-03    0.765108
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts2.to_period(<span class="string">'M'</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-01    0.193937
2000-01   -1.982108
2000-01    1.623989
2000-02   -0.980946
2000-02    1.431045
2000-02    0.765108
Freq: M, dtype: float64
</code></pre><p>要转换回时间戳，使用to_timestamp即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pts = ts2.to_period()</div><div class="line">pts</div></pre></td></tr></table></figure>
<pre><code>2000-01-29    0.193937
2000-01-30   -1.982108
2000-01-31    1.623989
2000-02-01   -0.980946
2000-02-02    1.431045
2000-02-03    0.765108
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pts.to_timestamp(how=<span class="string">'end'</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-01-29    0.193937
2000-01-30   -1.982108
2000-01-31    1.623989
2000-02-01   -0.980946
2000-02-02    1.431045
2000-02-03    0.765108
Freq: D, dtype: float64
</code></pre><h3 id="通过数组创建-PeriodIndex-通过多列创建时间索引"><a href="#通过数组创建-PeriodIndex-通过多列创建时间索引" class="headerlink" title="通过数组创建 PeriodIndex (通过多列创建时间索引)"></a>通过数组创建 PeriodIndex (通过多列创建时间索引)</h3><p>固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = pd.read_csv(<span class="string">'data/examples/macrodata.csv'</span>)</div><div class="line">data.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>quarter</th>
      <th>realgdp</th>
      <th>realcons</th>
      <th>realinv</th>
      <th>realgovt</th>
      <th>realdpi</th>
      <th>cpi</th>
      <th>m1</th>
      <th>tbilrate</th>
      <th>unemp</th>
      <th>pop</th>
      <th>infl</th>
      <th>realint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1959.0</td>
      <td>1.0</td>
      <td>2710.349</td>
      <td>1707.4</td>
      <td>286.898</td>
      <td>470.045</td>
      <td>1886.9</td>
      <td>28.98</td>
      <td>139.7</td>
      <td>2.82</td>
      <td>5.8</td>
      <td>177.146</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1959.0</td>
      <td>2.0</td>
      <td>2778.801</td>
      <td>1733.7</td>
      <td>310.859</td>
      <td>481.301</td>
      <td>1919.7</td>
      <td>29.15</td>
      <td>141.7</td>
      <td>3.08</td>
      <td>5.1</td>
      <td>177.830</td>
      <td>2.34</td>
      <td>0.74</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1959.0</td>
      <td>3.0</td>
      <td>2775.488</td>
      <td>1751.8</td>
      <td>289.226</td>
      <td>491.260</td>
      <td>1916.4</td>
      <td>29.35</td>
      <td>140.5</td>
      <td>3.82</td>
      <td>5.3</td>
      <td>178.657</td>
      <td>2.74</td>
      <td>1.09</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1959.0</td>
      <td>4.0</td>
      <td>2785.204</td>
      <td>1753.7</td>
      <td>299.356</td>
      <td>484.052</td>
      <td>1931.3</td>
      <td>29.37</td>
      <td>140.0</td>
      <td>4.33</td>
      <td>5.6</td>
      <td>179.386</td>
      <td>0.27</td>
      <td>4.06</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1960.0</td>
      <td>1.0</td>
      <td>2847.699</td>
      <td>1770.5</td>
      <td>331.722</td>
      <td>462.199</td>
      <td>1955.5</td>
      <td>29.54</td>
      <td>139.6</td>
      <td>3.50</td>
      <td>5.2</td>
      <td>180.007</td>
      <td>2.31</td>
      <td>1.19</td>
    </tr>
  </tbody>
</table>
</div>

<p>通过将这些时间列数组以及一个频率传入PeriodIndex，就可以将它们合并成DataFrame的一个索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">index = pd.PeriodIndex(year=data.year, quarter=data.quarter, freq=<span class="string">'Q-DEC'</span>)</div><div class="line">index</div></pre></td></tr></table></figure>
<pre><code>PeriodIndex([&apos;1959Q1&apos;, &apos;1959Q2&apos;, &apos;1959Q3&apos;, &apos;1959Q4&apos;, &apos;1960Q1&apos;, &apos;1960Q2&apos;,
             &apos;1960Q3&apos;, &apos;1960Q4&apos;, &apos;1961Q1&apos;, &apos;1961Q2&apos;,
             ...
             &apos;2007Q2&apos;, &apos;2007Q3&apos;, &apos;2007Q4&apos;, &apos;2008Q1&apos;, &apos;2008Q2&apos;, &apos;2008Q3&apos;,
             &apos;2008Q4&apos;, &apos;2009Q1&apos;, &apos;2009Q2&apos;, &apos;2009Q3&apos;],
            dtype=&apos;period[Q-DEC]&apos;, length=203, freq=&apos;Q-DEC&apos;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data.index = index</div><div class="line">data.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>quarter</th>
      <th>realgdp</th>
      <th>realcons</th>
      <th>realinv</th>
      <th>realgovt</th>
      <th>realdpi</th>
      <th>cpi</th>
      <th>m1</th>
      <th>tbilrate</th>
      <th>unemp</th>
      <th>pop</th>
      <th>infl</th>
      <th>realint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1959Q1</th>
      <td>1959.0</td>
      <td>1.0</td>
      <td>2710.349</td>
      <td>1707.4</td>
      <td>286.898</td>
      <td>470.045</td>
      <td>1886.9</td>
      <td>28.98</td>
      <td>139.7</td>
      <td>2.82</td>
      <td>5.8</td>
      <td>177.146</td>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>1959Q2</th>
      <td>1959.0</td>
      <td>2.0</td>
      <td>2778.801</td>
      <td>1733.7</td>
      <td>310.859</td>
      <td>481.301</td>
      <td>1919.7</td>
      <td>29.15</td>
      <td>141.7</td>
      <td>3.08</td>
      <td>5.1</td>
      <td>177.830</td>
      <td>2.34</td>
      <td>0.74</td>
    </tr>
    <tr>
      <th>1959Q3</th>
      <td>1959.0</td>
      <td>3.0</td>
      <td>2775.488</td>
      <td>1751.8</td>
      <td>289.226</td>
      <td>491.260</td>
      <td>1916.4</td>
      <td>29.35</td>
      <td>140.5</td>
      <td>3.82</td>
      <td>5.3</td>
      <td>178.657</td>
      <td>2.74</td>
      <td>1.09</td>
    </tr>
    <tr>
      <th>1959Q4</th>
      <td>1959.0</td>
      <td>4.0</td>
      <td>2785.204</td>
      <td>1753.7</td>
      <td>299.356</td>
      <td>484.052</td>
      <td>1931.3</td>
      <td>29.37</td>
      <td>140.0</td>
      <td>4.33</td>
      <td>5.6</td>
      <td>179.386</td>
      <td>0.27</td>
      <td>4.06</td>
    </tr>
    <tr>
      <th>1960Q1</th>
      <td>1960.0</td>
      <td>1.0</td>
      <td>2847.699</td>
      <td>1770.5</td>
      <td>331.722</td>
      <td>462.199</td>
      <td>1955.5</td>
      <td>29.54</td>
      <td>139.6</td>
      <td>3.50</td>
      <td>5.2</td>
      <td>180.007</td>
      <td>2.31</td>
      <td>1.19</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.infl.head()</div></pre></td></tr></table></figure>
<pre><code>1959Q1    0.00
1959Q2    2.34
1959Q3    2.74
1959Q4    0.27
1960Q1    2.31
Freq: Q-DEC, Name: infl, dtype: float64
</code></pre><h2 id="重采样及频率转换"><a href="#重采样及频率转换" class="headerlink" title="重采样及频率转换"></a>重采样及频率转换</h2><p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。</p>
<p>pandas对象都带有一个resample方法，它是各种频率转换工作的主力函数。resample有一个类似于groupby的API，调用resample可以分组数据，然后会调用一个聚合函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">100</span>, freq=<span class="string">'D'</span>)</div><div class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</div><div class="line">ts.head()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01   -1.798126
2000-01-02    0.937883
2000-01-03   -1.010101
2000-01-04   -0.553884
2000-01-05   -1.131896
Freq: D, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'M'</span>).mean()</div></pre></td></tr></table></figure>
<pre><code>2000-01-31   -0.163057
2000-02-29   -0.128462
2000-03-31   -0.136395
2000-04-30    0.362875
Freq: M, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'M'</span>, kind=<span class="string">'period'</span>).mean()</div></pre></td></tr></table></figure>
<pre><code>2000-01   -0.163057
2000-02   -0.128462
2000-03   -0.136395
2000-04    0.362875
Freq: M, dtype: float64
</code></pre><h3 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h3><p>将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（’M’或’BM’），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用resample对数据进行降采样时，需要考虑两样东西：  </p>
<ol>
<li>各区间哪边是闭合的。</li>
<li>如何标记各个聚合面元，用区间的开头还是末尾。</li>
</ol>
<p>为了说明，我们来看一些“1分钟”数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rng = pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">12</span>, freq=<span class="string">'T'</span>)</div><div class="line">ts = pd.Series(np.arange(<span class="number">12</span>), index=rng)</div><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int32
</code></pre><p>假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'right'</span>).sum()</div></pre></td></tr></table></figure>
<pre><code>1999-12-31 23:55:00     0
2000-01-01 00:00:00    15
2000-01-01 00:05:00    40
2000-01-01 00:10:00    11
Freq: 5T, dtype: int32
</code></pre><p>传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此00:00到00:05的区间中是包含00:05的。传入closed=’left’会让区间以左边界闭合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'left'</span>).sum()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:00:00    10
2000-01-01 00:05:00    35
2000-01-01 00:10:00    21
Freq: 5T, dtype: int32
</code></pre><p>最终的时间序列是以各面元右边界的时间戳进行标记的。传入label=’right’即可用面元的邮编界对其进行标记：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'right'</span>, label=<span class="string">'right'</span>).sum()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:00:00     0
2000-01-01 00:05:00    15
2000-01-01 00:10:00    40
2000-01-01 00:15:00    11
Freq: 5T, dtype: int32
</code></pre><p>下图说明了“1分钟”数据被转换为“5分钟”数据的处理过程。<br><img src="https://upload-images.jianshu.io/upload_images/7178691-7a77f47844f2ee8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt=""></p>
<p>最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过loffset设置一个字符串或日期偏移量即可实现这个目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'right'</span>, label=<span class="string">'right'</span>, loffset=<span class="string">'-1s'</span>).sum()</div></pre></td></tr></table></figure>
<pre><code>1999-12-31 23:59:59     0
2000-01-01 00:04:59    15
2000-01-01 00:09:59    40
2000-01-01 00:14:59    11
Freq: 5T, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'left'</span>, label=<span class="string">'right'</span>, loffset=<span class="string">'-1s'</span>).sum()</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:04:59    10
2000-01-01 00:09:59    35
2000-01-01 00:14:59    21
Freq: 5T, dtype: int32
</code></pre><p>此外，也可以通过调用结果对象的 shift 方法来实现该目的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">temp = ts.resample(<span class="string">'5min'</span>, closed=<span class="string">'left'</span>, label=<span class="string">'right'</span>).sum()</div><div class="line">temp</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:05:00    10
2000-01-01 00:10:00    35
2000-01-01 00:15:00    21
Freq: 5T, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">temp.shift(<span class="number">-1</span>, freq=<span class="string">'s'</span>)</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:04:59    10
2000-01-01 00:09:59    35
2000-01-01 00:14:59    21
Freq: 5T, dtype: int32
</code></pre><h3 id="OHLC重采样"><a href="#OHLC重采样" class="headerlink" title="OHLC重采样"></a>OHLC重采样</h3><p>金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（open，开盘）、最后一个值（close，收盘）、最大值（high，最高）以及最小值（low，最低）。传入how=’ohlc’即可得到一个含有这四种聚合值的DataFrame。整个过程很高效，只需一次扫描即可计算出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts</div></pre></td></tr></table></figure>
<pre><code>2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int32
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ts.resample(<span class="string">'5min'</span>).ohlc()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>open</th>
      <th>high</th>
      <th>low</th>
      <th>close</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-01 00:00:00</th>
      <td>0</td>
      <td>4</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>2000-01-01 00:05:00</th>
      <td>5</td>
      <td>9</td>
      <td>5</td>
      <td>9</td>
    </tr>
    <tr>
      <th>2000-01-01 00:10:00</th>
      <td>10</td>
      <td>11</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="升采样和插值"><a href="#升采样和插值" class="headerlink" title="升采样和插值"></a>升采样和插值</h3><p>在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>),</div><div class="line">                     index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">2</span>, freq=<span class="string">'W-WED'</span>),</div><div class="line">                     columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">frame</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-05</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-12</th>
      <td>0.702946</td>
      <td>-0.824366</td>
      <td>1.054700</td>
      <td>1.809035</td>
    </tr>
  </tbody>
</table>
</div>

<p>当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用asfreq方法转换成高频，不经过聚合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df_daily = frame.resample(<span class="string">'D'</span>).asfreq()</div><div class="line">df_daily</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-05</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-06</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-07</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-08</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-09</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-10</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-11</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-12</th>
      <td>0.702946</td>
      <td>-0.824366</td>
      <td>1.054700</td>
      <td>1.809035</td>
    </tr>
  </tbody>
</table>
</div>

<p>假设你想要用前面的周型值填充“非星期三”。resample 的填充和插值方式跟fillna和reindex的一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.resample(<span class="string">'D'</span>).ffill()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-05</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-06</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-07</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-08</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-09</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-10</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-11</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-12</th>
      <td>0.702946</td>
      <td>-0.824366</td>
      <td>1.054700</td>
      <td>1.809035</td>
    </tr>
  </tbody>
</table>
</div>

<p>同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.resample(<span class="string">'D'</span>).ffill(limit=<span class="number">2</span>)</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01-05</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-06</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-07</th>
      <td>0.512990</td>
      <td>1.145801</td>
      <td>0.765452</td>
      <td>-1.319816</td>
    </tr>
    <tr>
      <th>2000-01-08</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-09</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-10</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-11</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2000-01-12</th>
      <td>0.702946</td>
      <td>-0.824366</td>
      <td>1.054700</td>
      <td>1.809035</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="通过时期-period-进行重采样"><a href="#通过时期-period-进行重采样" class="headerlink" title="通过时期(period)进行重采样"></a>通过时期(period)进行重采样</h3><p>对那些使用时期索引的数据进行重采样与时间戳很像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">frame = pd.DataFrame(np.random.randn(<span class="number">24</span>, <span class="number">4</span>),</div><div class="line">                     index=pd.period_range(<span class="string">'1-2000'</span>, <span class="string">'12-2001'</span>, freq=<span class="string">'M'</span>),</div><div class="line">                     columns=[<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</div><div class="line">frame.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000-01</th>
      <td>1.031093</td>
      <td>0.497053</td>
      <td>0.741678</td>
      <td>-0.765792</td>
    </tr>
    <tr>
      <th>2000-02</th>
      <td>0.882783</td>
      <td>1.501811</td>
      <td>0.966431</td>
      <td>0.258871</td>
    </tr>
    <tr>
      <th>2000-03</th>
      <td>0.793097</td>
      <td>2.349771</td>
      <td>1.678723</td>
      <td>-0.131274</td>
    </tr>
    <tr>
      <th>2000-04</th>
      <td>0.501516</td>
      <td>-1.210646</td>
      <td>-1.090834</td>
      <td>-1.627167</td>
    </tr>
    <tr>
      <th>2000-05</th>
      <td>-0.941150</td>
      <td>-1.149196</td>
      <td>-1.078340</td>
      <td>-1.399332</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame.index</div></pre></td></tr></table></figure>
<pre><code>PeriodIndex([&apos;2000-01&apos;, &apos;2000-02&apos;, &apos;2000-03&apos;, &apos;2000-04&apos;, &apos;2000-05&apos;, &apos;2000-06&apos;,
             &apos;2000-07&apos;, &apos;2000-08&apos;, &apos;2000-09&apos;, &apos;2000-10&apos;, &apos;2000-11&apos;, &apos;2000-12&apos;,
             &apos;2001-01&apos;, &apos;2001-02&apos;, &apos;2001-03&apos;, &apos;2001-04&apos;, &apos;2001-05&apos;, &apos;2001-06&apos;,
             &apos;2001-07&apos;, &apos;2001-08&apos;, &apos;2001-09&apos;, &apos;2001-10&apos;, &apos;2001-11&apos;, &apos;2001-12&apos;],
            dtype=&apos;period[M]&apos;, freq=&apos;M&apos;)
</code></pre><p>降采样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">annual_frame = frame.resample(<span class="string">'Y'</span>).mean()</div><div class="line">annual_frame</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
  </tbody>
</table>
</div>

<p>??? 这个升采样没理解</p>
<p>升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像asfreq方法那样。convention参数默认为’start’，也可设置为’end’：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annual_frame.resample(<span class="string">'Q-DEC'</span>).ffill()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000Q1</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2000Q2</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2000Q3</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2000Q4</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q1</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2001Q2</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2001Q3</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2001Q4</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annual_frame.resample(<span class="string">'Q-DEC'</span>, convention=<span class="string">'end'</span>).ffill()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000Q4</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q1</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q2</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q3</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q4</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
  </tbody>
</table>
</div>

<p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：  </p>
<ol>
<li>在降采样中，目标频率必须是源频率的子时期（subperiod）。</li>
<li>在升采样中，目标频率必须是源频率的超时期（superperiod）。  </li>
</ol>
<p>如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由Q-MAR定义的时间区间只能升采样为A-MAR、A-JUN、A-SEP、A-DEC等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annual_frame.resample(<span class="string">'Q-MAR'</span>).ffill()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Colorado</th>
      <th>Texas</th>
      <th>New York</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000Q4</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q1</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q2</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q3</th>
      <td>0.134307</td>
      <td>-0.098188</td>
      <td>-0.306211</td>
      <td>-0.268521</td>
    </tr>
    <tr>
      <th>2001Q4</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2002Q1</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2002Q2</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
    <tr>
      <th>2002Q3</th>
      <td>-0.750393</td>
      <td>-0.031389</td>
      <td>0.054950</td>
      <td>0.275272</td>
    </tr>
  </tbody>
</table>
</div>

<h2 id="移动窗口函数"><a href="#移动窗口函数" class="headerlink" title="移动窗口函数"></a>移动窗口函数</h2><p>在移动窗口（可以带有指数衰减权数）上计算的各种统计函数也是一类常见于时间序列的数组变换。这样可以圆滑噪音数据或断裂数据。我将它们称为移动窗口函数（moving window function），其中还包括那些窗口不定长的函数（如指数加权移动平均）。跟其他统计函数一样，移动窗口函数也会自动排除缺失值。</p>
<p>开始之前，我们加载一些时间序列数据，将其重采样为工作日频率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">close_px_all = pd.read_csv(<span class="string">'data/examples/stock_px_2.csv'</span>, parse_dates=<span class="keyword">True</span>, index_col=<span class="number">0</span>)</div><div class="line">close_px = close_px_all[[<span class="string">'AAPL'</span>, <span class="string">'MSFT'</span>, <span class="string">'XOM'</span>]]</div><div class="line">close_px.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003-01-02</th>
      <td>7.40</td>
      <td>21.11</td>
      <td>29.22</td>
    </tr>
    <tr>
      <th>2003-01-03</th>
      <td>7.45</td>
      <td>21.14</td>
      <td>29.24</td>
    </tr>
    <tr>
      <th>2003-01-06</th>
      <td>7.45</td>
      <td>21.52</td>
      <td>29.96</td>
    </tr>
    <tr>
      <th>2003-01-07</th>
      <td>7.43</td>
      <td>21.93</td>
      <td>28.95</td>
    </tr>
    <tr>
      <th>2003-01-08</th>
      <td>7.28</td>
      <td>21.31</td>
      <td>28.83</td>
    </tr>
  </tbody>
</table>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px = close_px.resample(<span class="string">'B'</span>).ffill()</div><div class="line">close_px.head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003-01-02</th>
      <td>7.40</td>
      <td>21.11</td>
      <td>29.22</td>
    </tr>
    <tr>
      <th>2003-01-03</th>
      <td>7.45</td>
      <td>21.14</td>
      <td>29.24</td>
    </tr>
    <tr>
      <th>2003-01-06</th>
      <td>7.45</td>
      <td>21.52</td>
      <td>29.96</td>
    </tr>
    <tr>
      <th>2003-01-07</th>
      <td>7.43</td>
      <td>21.93</td>
      <td>28.95</td>
    </tr>
    <tr>
      <th>2003-01-08</th>
      <td>7.28</td>
      <td>21.31</td>
      <td>28.83</td>
    </tr>
  </tbody>
</table>
</div>

<p>现在引入rolling运算符，它与resample和groupby很像。可以在TimeSeries或DataFrame以及一个window（表示期数，见图11-4）上调用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close_px.AAPL.plot()</div><div class="line">close_px.AAPL.rolling(<span class="number">250</span>).mean().plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xc51a898&gt;
</code></pre><p><img src="/images/shuju/output_303_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xc41fcc0&gt;
</code></pre><p><img src="/images/shuju/output_304_1.png" alt="png"></p>
<p>表达式rolling(250)与groupby很像，但不是对其进行分组，而是创建一个按照250天分组的滑动窗口对象。然后，我们就得到了苹果公司股价的250天的移动窗口。</p>
<p>默认情况下，rolling函数需要窗口中所有的值为非NA值。可以修改该行为以解决缺失数据的问题。其实，在时间序列开始处尚不足窗口期的那些数据就是个特例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appl_std250 = close_px.AAPL.rolling(<span class="number">250</span>, min_periods=<span class="number">10</span>).std()</div><div class="line">appl_std250[<span class="number">5</span>:<span class="number">12</span>]</div></pre></td></tr></table></figure>
<pre><code>2003-01-09         NaN
2003-01-10         NaN
2003-01-13         NaN
2003-01-14         NaN
2003-01-15    0.077496
2003-01-16    0.074760
2003-01-17    0.112368
Freq: B, Name: AAPL, dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appl_std250.plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xc60f0b8&gt;
</code></pre><p><img src="/images/shuju/output_308_1.png" alt="png"></p>
<p>要计算扩展窗口平均（expanding window mean），可以使用expanding而不是rolling。“扩展”意味着，从时间序列的起始处开始窗口，增加窗口直到它超过所有的序列。apple_std250时间序列的扩展窗口平均如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">expanding_mean = appl_std250.expanding().mean()</div><div class="line">expanding_mean.plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xc6bb940&gt;
</code></pre><p><img src="/images/shuju/output_310_1.png" alt="png"></p>
<p>对DataFrame调用rolling_mean（以及与之类似的函数）会将转换应用到所有的列上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px.rolling(<span class="number">60</span>).mean().plot(logy=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xc6bba90&gt;
</code></pre><p><img src="/images/shuju/output_312_1.png" alt="png"></p>
<p>rolling函数也可以接受一个指定固定大小时间补偿字符串，而不是一组时期。这样可以方便处理不规律的时间序列。这些字符串也可以传递给resample。例如，我们可以计算20天的滚动均值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">close_px.rolling(<span class="string">'20D'</span>).mean().head()</div></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>MSFT</th>
      <th>XOM</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2003-01-02</th>
      <td>7.400000</td>
      <td>21.110000</td>
      <td>29.220000</td>
    </tr>
    <tr>
      <th>2003-01-03</th>
      <td>7.425000</td>
      <td>21.125000</td>
      <td>29.230000</td>
    </tr>
    <tr>
      <th>2003-01-06</th>
      <td>7.433333</td>
      <td>21.256667</td>
      <td>29.473333</td>
    </tr>
    <tr>
      <th>2003-01-07</th>
      <td>7.432500</td>
      <td>21.425000</td>
      <td>29.342500</td>
    </tr>
    <tr>
      <th>2003-01-08</th>
      <td>7.402000</td>
      <td>21.402000</td>
      <td>29.240000</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="指数加权函数"><a href="#指数加权函数" class="headerlink" title="指数加权函数"></a>指数加权函数</h3><p>另一种使用固定大小窗口及相等权数观测值的办法是，定义一个衰减因子（decay factor）常量，以便使近期的观测值拥有更大的权数。衰减因子的定义方式有很多，比较流行的是使用时间间隔（span），它可以使结果兼容于窗口大小等于时间间隔的简单移动窗口（simple moving window）函数。  </p>
<p>由于指数加权统计会赋予近期的观测值更大的权数，因此相对于等权统计，它能“适应”更快的变化。  </p>
<p>除了rolling和expanding，pandas还有ewm运算符。下面这个例子对比了苹果公司股价的30日移动平均和span=30的指数加权移动平均</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">aapl_px = close_px.AAPL[<span class="string">'2006'</span>:<span class="string">'2007'</span>]</div><div class="line">ma60 = aapl_px.rolling(<span class="number">30</span>, min_periods=<span class="number">20</span>).mean()</div><div class="line">ewma60 = aapl_px.ewm(span=<span class="number">30</span>).mean()</div><div class="line">ma60.plot(style=<span class="string">'k--'</span>, label=<span class="string">'Simple MA'</span>)</div><div class="line">ewma60.plot(style=<span class="string">'k-'</span>, label=<span class="string">'EW MA'</span>)</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xcadb5c0&gt;
</code></pre><p><img src="/images/shuju/output_317_1.png" alt="png"></p>
<h3 id="二元移动窗口函数"><a href="#二元移动窗口函数" class="headerlink" title="二元移动窗口函数"></a>二元移动窗口函数</h3><p>有些统计运算（如相关系数和协方差）需要在两个时间序列上执行。例如，金融分析师常常对某只股票对某个参考指数（如标准普尔500指数）的相关系数感兴趣。要进行说明，我们先计算我们感兴趣的时间序列的百分数变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spx_px = close_px_all[<span class="string">'SPX'</span>]</div><div class="line">spx_rets = spx_px.pct_change()</div><div class="line">returns = close_px.pct_change()</div></pre></td></tr></table></figure>
<p>调用rolling之后，corr聚合函数开始计算与spx_rets滚动相关系数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">corr = returns.AAPL.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</div><div class="line">corr.plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xdb4b5f8&gt;
</code></pre><p><img src="/images/shuju/output_322_1.png" alt="png"></p>
<p>假设你想要一次性计算多只股票与标准普尔500指数的相关系数。虽然编写一个循环并新建一个DataFrame不是什么难事，但比较啰嗦。其实，只需传入一个TimeSeries和一个DataFrame，rolling_corr就会自动计算TimeSeries（本例中就是spx_rets）与DataFrame各列的相关系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">corr = returns.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</div><div class="line">corr.plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xdc05dd8&gt;
</code></pre><p><img src="/images/shuju/output_324_1.png" alt="png"></p>
<h3 id="用户定义的移动窗口函数"><a href="#用户定义的移动窗口函数" class="headerlink" title="用户定义的移动窗口函数"></a>用户定义的移动窗口函数</h3><p>rolling_apply函数使你能够在移动窗口上应用自己设计的数组函数。唯一要求的就是：该函数要能从数组的各个片段中产生单个值（即约简）。比如说，当我们用rolling(…).quantile(q)计算样本分位数时，可能对样本中特定值的百分等级感兴趣。scipy.stats.percentileofscore函数就能达到这个目的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> percentileofscore</div><div class="line">score_at_2percent = <span class="keyword">lambda</span> x: percentileofscore(x, <span class="number">0.02</span>)</div><div class="line">result = returns.AAPL.rolling(<span class="number">250</span>).apply(score_at_2percent, raw=<span class="keyword">False</span>)</div><div class="line">result.plot()</div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0xdd44630&gt;
</code></pre><p><img src="/images/shuju/output_327_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/my.jpg" alt="echo-ding wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/my.jpg" alt="echo-ding 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/my.jpg" alt="echo-ding 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pandas-时间序列/" rel="tag"># pandas 时间序列</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/11/数据分析/NumPy 笔记/" rel="next" title="Numpy 基础">
                <i class="fa fa-chevron-left"></i> Numpy 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/15/数据分析/matplotlib 笔记/" rel="prev" title="matplotlib 基础">
                matplotlib 基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my.jpg"
                alt="echo-ding" />
            
              <p class="site-author-name" itemprop="name">echo-ding</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅，绝知此事要躬行。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/bunao" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:ibunao@163.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/6346736172" target="_blank" title="微博" rel="external nofollow"><i class="fa fa-fw fa-weibo"></i>微博</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎" rel="external nofollow"><i class="fa fa-fw fa-angry"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bunao.me/" title="bunao" target="_blank" rel="external nofollow">bunao</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期和时间数据类型及工具"><span class="nav-number">1.</span> <span class="nav-text">日期和时间数据类型及工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串和datetime的相互转换"><span class="nav-number">1.1.</span> <span class="nav-text">字符串和datetime的相互转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间序列基础"><span class="nav-number">2.</span> <span class="nav-text">时间序列基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引、选取、子集构造"><span class="nav-number">2.1.</span> <span class="nav-text">索引、选取、子集构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带有重复索引的时间序列"><span class="nav-number">2.2.</span> <span class="nav-text">带有重复索引的时间序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期的范围、频率以及移动"><span class="nav-number">3.</span> <span class="nav-text">日期的范围、频率以及移动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成日期范围"><span class="nav-number">3.1.</span> <span class="nav-text">生成日期范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#频率和日期偏移量"><span class="nav-number">3.2.</span> <span class="nav-text">频率和日期偏移量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WOM日期"><span class="nav-number">3.3.</span> <span class="nav-text">WOM日期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动（超前和滞后）数据"><span class="nav-number">3.4.</span> <span class="nav-text">移动（超前和滞后）数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过偏移量对日期进行位移"><span class="nav-number">3.5.</span> <span class="nav-text">通过偏移量对日期进行位移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时区处理"><span class="nav-number">4.</span> <span class="nav-text">时区处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时区本地化和转换"><span class="nav-number">4.1.</span> <span class="nav-text">时区本地化和转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timestamp对象"><span class="nav-number">4.2.</span> <span class="nav-text">Timestamp对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同时区之间的运算"><span class="nav-number">4.3.</span> <span class="nav-text">不同时区之间的运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时期-Period-及其算术运算"><span class="nav-number">5.</span> <span class="nav-text">时期(Period)及其算术运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时期的频率转换"><span class="nav-number">5.1.</span> <span class="nav-text">时期的频率转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按季度计算的时期频率"><span class="nav-number">5.2.</span> <span class="nav-text">按季度计算的时期频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将Timestamp转换为Period（及其反向过程）"><span class="nav-number">5.3.</span> <span class="nav-text">将Timestamp转换为Period（及其反向过程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过数组创建-PeriodIndex-通过多列创建时间索引"><span class="nav-number">5.4.</span> <span class="nav-text">通过数组创建 PeriodIndex (通过多列创建时间索引)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重采样及频率转换"><span class="nav-number">6.</span> <span class="nav-text">重采样及频率转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#降采样"><span class="nav-number">6.1.</span> <span class="nav-text">降采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OHLC重采样"><span class="nav-number">6.2.</span> <span class="nav-text">OHLC重采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#升采样和插值"><span class="nav-number">6.3.</span> <span class="nav-text">升采样和插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过时期-period-进行重采样"><span class="nav-number">6.4.</span> <span class="nav-text">通过时期(period)进行重采样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动窗口函数"><span class="nav-number">7.</span> <span class="nav-text">移动窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指数加权函数"><span class="nav-number">7.1.</span> <span class="nav-text">指数加权函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二元移动窗口函数"><span class="nav-number">7.2.</span> <span class="nav-text">二元移动窗口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户定义的移动窗口函数"><span class="nav-number">7.3.</span> <span class="nav-text">用户定义的移动窗口函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">echo-ding</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io" rel="external nofollow" >Hexo</a> 强力驱动 v3.3.7</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "JoifQWva3MrLxWwEjXGYYvNw-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "JoifQWva3MrLxWwEjXGYYvNw-gzGzoHsz",
                'X-LC-Key': "IEzrlKqyuxO8jhwp2ds1P0Rf",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
